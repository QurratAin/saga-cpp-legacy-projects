/* monitorC.cpp
   Generated by gSOAP 2.7.9l from Monitorable_service.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "monitorH.h"

SOAP_SOURCE_STAMP("@(#) monitorC.cpp ver 2.7.9l 2008-02-22 04:18:05 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__FaultSubcodeValues:
		return soap_in_xsd__FaultSubcodeValues(soap, NULL, NULL, "xsd:FaultSubcodeValues");
	case SOAP_TYPE_xsd__RelationshipTypeValues:
		return soap_in_xsd__RelationshipTypeValues(soap, NULL, NULL, "xsd:RelationshipTypeValues");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__FaultSubcodeValues_:
		return soap_in_xsd__FaultSubcodeValues_(soap, NULL, NULL, "xsd:FaultSubcodeValues");
	case SOAP_TYPE_xsd__RelationshipTypeValues_:
		return soap_in_xsd__RelationshipTypeValues_(soap, NULL, NULL, "xsd:RelationshipTypeValues");
	case SOAP_TYPE_basefaults__BaseFaultType:
		return soap_in_basefaults__BaseFaultType(soap, NULL, NULL, "basefaults:BaseFaultType");
	case SOAP_TYPE_xsd__AttributedURI:
		return soap_in_xsd__AttributedURI(soap, NULL, NULL, "xsd:AttributedURI");
	case SOAP_TYPE_xsd__AttributedQName:
		return soap_in_xsd__AttributedQName(soap, NULL, NULL, "xsd:AttributedQName");
	case SOAP_TYPE_xsd__ReplyAfterType:
		return soap_in_xsd__ReplyAfterType(soap, NULL, NULL, "xsd:ReplyAfterType");
	case SOAP_TYPE_xsd__Relationship:
		return soap_in_xsd__Relationship(soap, NULL, NULL, "xsd:Relationship");
	case SOAP_TYPE_xsd__ServiceNameType:
		return soap_in_xsd__ServiceNameType(soap, NULL, NULL, "xsd:ServiceNameType");
	case SOAP_TYPE_xsd__ReferencePropertiesType:
		return soap_in_xsd__ReferencePropertiesType(soap, NULL, NULL, "xsd:ReferencePropertiesType");
	case SOAP_TYPE_xsd__EndpointReferenceType:
		return soap_in_xsd__EndpointReferenceType(soap, NULL, NULL, "xsd:EndpointReferenceType");
	case SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType:
		return soap_in_lifetime__TerminationTimeChangeRejectedFaultType(soap, NULL, NULL, "lifetime:TerminationTimeChangeRejectedFaultType");
	case SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType:
		return soap_in_lifetime__UnableToSetTerminationTimeFaultType(soap, NULL, NULL, "lifetime:UnableToSetTerminationTimeFaultType");
	case SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType:
		return soap_in_lifetime__ResourceNotDestroyedFaultType(soap, NULL, NULL, "lifetime:ResourceNotDestroyedFaultType");
	case SOAP_TYPE_lifetime__ResourceUnknownFaultType:
		return soap_in_lifetime__ResourceUnknownFaultType(soap, NULL, NULL, "lifetime:ResourceUnknownFaultType");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__NCName_:
		return soap_in_xsd__NCName_(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_lifetime__DestroyResponse:
		return soap_in_PointerTo_lifetime__DestroyResponse(soap, NULL, NULL, "lifetime:DestroyResponse");
	case SOAP_TYPE_PointerTo_lifetime__Destroy:
		return soap_in_PointerTo_lifetime__Destroy(soap, NULL, NULL, "lifetime:Destroy");
	case SOAP_TYPE_PointerToPointerTobasefaults__BaseFaultType:
		return soap_in_PointerToPointerTobasefaults__BaseFaultType(soap, NULL, NULL, "basefaults:BaseFaultType");
	case SOAP_TYPE_PointerTobasefaults__BaseFaultType:
		return soap_in_PointerTobasefaults__BaseFaultType(soap, NULL, NULL, "basefaults:BaseFaultType");
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_Description:
		return soap_in_PointerTo_basefaults__BaseFaultType_Description(soap, NULL, NULL, "basefaults:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, NULL, NULL, "basefaults:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__EndpointReferenceType:
		return soap_in_PointerToxsd__EndpointReferenceType(soap, NULL, NULL, "xsd:EndpointReferenceType");
	case SOAP_TYPE_PointerToxsd__ServiceNameType:
		return soap_in_PointerToxsd__ServiceNameType(soap, NULL, NULL, "xsd:ServiceNameType");
	case SOAP_TYPE_PointerToxsd__AttributedQName:
		return soap_in_PointerToxsd__AttributedQName(soap, NULL, NULL, "xsd:AttributedQName");
	case SOAP_TYPE_PointerToxsd__ReferencePropertiesType:
		return soap_in_PointerToxsd__ReferencePropertiesType(soap, NULL, NULL, "xsd:ReferencePropertiesType");
	case SOAP_TYPE_PointerToxsd__AttributedURI:
		return soap_in_PointerToxsd__AttributedURI(soap, NULL, NULL, "xsd:AttributedURI");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{	char **s;
		s = soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_xsd__FaultSubcodeValues_;
			return soap_in_xsd__FaultSubcodeValues_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_xsd__RelationshipTypeValues_;
			return soap_in_xsd__RelationshipTypeValues_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "basefaults:BaseFaultType"))
		{	*type = SOAP_TYPE_basefaults__BaseFaultType;
			return soap_in_basefaults__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:AttributedURI"))
		{	*type = SOAP_TYPE_xsd__AttributedURI;
			return soap_in_xsd__AttributedURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:AttributedQName"))
		{	*type = SOAP_TYPE_xsd__AttributedQName;
			return soap_in_xsd__AttributedQName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ReplyAfterType"))
		{	*type = SOAP_TYPE_xsd__ReplyAfterType;
			return soap_in_xsd__ReplyAfterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:Relationship"))
		{	*type = SOAP_TYPE_xsd__Relationship;
			return soap_in_xsd__Relationship(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ServiceNameType"))
		{	*type = SOAP_TYPE_xsd__ServiceNameType;
			return soap_in_xsd__ServiceNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ReferencePropertiesType"))
		{	*type = SOAP_TYPE_xsd__ReferencePropertiesType;
			return soap_in_xsd__ReferencePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:EndpointReferenceType"))
		{	*type = SOAP_TYPE_xsd__EndpointReferenceType;
			return soap_in_xsd__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:TerminationTimeChangeRejectedFaultType"))
		{	*type = SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType;
			return soap_in_lifetime__TerminationTimeChangeRejectedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:UnableToSetTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType;
			return soap_in_lifetime__UnableToSetTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:ResourceNotDestroyedFaultType"))
		{	*type = SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType;
			return soap_in_lifetime__ResourceNotDestroyedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:ResourceUnknownFaultType"))
		{	*type = SOAP_TYPE_lifetime__ResourceUnknownFaultType;
			return soap_in_lifetime__ResourceUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger_;
			return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName_;
			return soap_in_xsd__NCName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_xsd__FaultSubcodeValues;
			return soap_in_xsd__FaultSubcodeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_xsd__RelationshipTypeValues;
			return soap_in_xsd__RelationshipTypeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NCName;
			s = soap_in_xsd__NCName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "basefaults:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__basefaults__BaseFaultType_Description;
			return soap_in__basefaults__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "basefaults:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__basefaults__BaseFaultType_ErrorCode;
			return soap_in__basefaults__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:TerminationNotification"))
		{	*type = SOAP_TYPE__lifetime__TerminationNotification;
			return soap_in__lifetime__TerminationNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:SetTerminationTimeResponse"))
		{	*type = SOAP_TYPE__lifetime__SetTerminationTimeResponse;
			return soap_in__lifetime__SetTerminationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:SetTerminationTime"))
		{	*type = SOAP_TYPE__lifetime__SetTerminationTime;
			return soap_in__lifetime__SetTerminationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:DestroyResponse"))
		{	*type = SOAP_TYPE__lifetime__DestroyResponse;
			return soap_in__lifetime__DestroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:Destroy"))
		{	*type = SOAP_TYPE__lifetime__Destroy;
			return soap_in__lifetime__Destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lifetime:ScheduledResourceTerminationRP"))
		{	*type = SOAP_TYPE__lifetime__ScheduledResourceTerminationRP;
			return soap_in__lifetime__ScheduledResourceTerminationRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	char **s;
			*type = SOAP_TYPE__xml__lang;
			s = soap_in__xml__lang(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__FaultSubcodeValues:
		return soap_out_xsd__FaultSubcodeValues(soap, tag, id, (const enum xsd__FaultSubcodeValues *)ptr, "xsd:FaultSubcodeValues");
	case SOAP_TYPE_xsd__RelationshipTypeValues:
		return soap_out_xsd__RelationshipTypeValues(soap, tag, id, (const enum xsd__RelationshipTypeValues *)ptr, "xsd:RelationshipTypeValues");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__basefaults__BaseFaultType_Description:
		return ((_basefaults__BaseFaultType_Description *)ptr)->soap_out(soap, "basefaults:BaseFaultType-Description", id, NULL);
	case SOAP_TYPE__basefaults__BaseFaultType_ErrorCode:
		return ((_basefaults__BaseFaultType_ErrorCode *)ptr)->soap_out(soap, "basefaults:BaseFaultType-ErrorCode", id, NULL);
	case SOAP_TYPE_xsd__FaultSubcodeValues_:
		return ((xsd__FaultSubcodeValues_ *)ptr)->soap_out(soap, tag, id, "xsd:FaultSubcodeValues");
	case SOAP_TYPE_xsd__RelationshipTypeValues_:
		return ((xsd__RelationshipTypeValues_ *)ptr)->soap_out(soap, tag, id, "xsd:RelationshipTypeValues");
	case SOAP_TYPE_basefaults__BaseFaultType:
		return ((basefaults__BaseFaultType *)ptr)->soap_out(soap, tag, id, "basefaults:BaseFaultType");
	case SOAP_TYPE_xsd__AttributedURI:
		return ((xsd__AttributedURI *)ptr)->soap_out(soap, tag, id, "xsd:AttributedURI");
	case SOAP_TYPE_xsd__AttributedQName:
		return ((xsd__AttributedQName *)ptr)->soap_out(soap, tag, id, "xsd:AttributedQName");
	case SOAP_TYPE_xsd__ReplyAfterType:
		return ((xsd__ReplyAfterType *)ptr)->soap_out(soap, tag, id, "xsd:ReplyAfterType");
	case SOAP_TYPE_xsd__Relationship:
		return ((xsd__Relationship *)ptr)->soap_out(soap, tag, id, "xsd:Relationship");
	case SOAP_TYPE_xsd__ServiceNameType:
		return ((xsd__ServiceNameType *)ptr)->soap_out(soap, tag, id, "xsd:ServiceNameType");
	case SOAP_TYPE_xsd__ReferencePropertiesType:
		return ((xsd__ReferencePropertiesType *)ptr)->soap_out(soap, tag, id, "xsd:ReferencePropertiesType");
	case SOAP_TYPE_xsd__EndpointReferenceType:
		return ((xsd__EndpointReferenceType *)ptr)->soap_out(soap, tag, id, "xsd:EndpointReferenceType");
	case SOAP_TYPE__lifetime__TerminationNotification:
		return ((_lifetime__TerminationNotification *)ptr)->soap_out(soap, "lifetime:TerminationNotification", id, NULL);
	case SOAP_TYPE__lifetime__SetTerminationTimeResponse:
		return ((_lifetime__SetTerminationTimeResponse *)ptr)->soap_out(soap, "lifetime:SetTerminationTimeResponse", id, NULL);
	case SOAP_TYPE__lifetime__SetTerminationTime:
		return ((_lifetime__SetTerminationTime *)ptr)->soap_out(soap, "lifetime:SetTerminationTime", id, NULL);
	case SOAP_TYPE__lifetime__DestroyResponse:
		return ((_lifetime__DestroyResponse *)ptr)->soap_out(soap, "lifetime:DestroyResponse", id, NULL);
	case SOAP_TYPE__lifetime__Destroy:
		return ((_lifetime__Destroy *)ptr)->soap_out(soap, "lifetime:Destroy", id, NULL);
	case SOAP_TYPE__lifetime__ScheduledResourceTerminationRP:
		return ((_lifetime__ScheduledResourceTerminationRP *)ptr)->soap_out(soap, "lifetime:ScheduledResourceTerminationRP", id, NULL);
	case SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType:
		return ((lifetime__TerminationTimeChangeRejectedFaultType *)ptr)->soap_out(soap, tag, id, "lifetime:TerminationTimeChangeRejectedFaultType");
	case SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType:
		return ((lifetime__UnableToSetTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "lifetime:UnableToSetTerminationTimeFaultType");
	case SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType:
		return ((lifetime__ResourceNotDestroyedFaultType *)ptr)->soap_out(soap, tag, id, "lifetime:ResourceNotDestroyedFaultType");
	case SOAP_TYPE_lifetime__ResourceUnknownFaultType:
		return ((lifetime__ResourceUnknownFaultType *)ptr)->soap_out(soap, tag, id, "lifetime:ResourceUnknownFaultType");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return ((xsd__nonNegativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return ((xsd__QName *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__NCName_:
		return ((xsd__NCName_ *)ptr)->soap_out(soap, tag, id, "xsd:NCName");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTo_lifetime__DestroyResponse:
		return soap_out_PointerTo_lifetime__DestroyResponse(soap, tag, id, (_lifetime__DestroyResponse *const*)ptr, "lifetime:DestroyResponse");
	case SOAP_TYPE_PointerTo_lifetime__Destroy:
		return soap_out_PointerTo_lifetime__Destroy(soap, tag, id, (_lifetime__Destroy *const*)ptr, "lifetime:Destroy");
	case SOAP_TYPE_PointerToPointerTobasefaults__BaseFaultType:
		return soap_out_PointerToPointerTobasefaults__BaseFaultType(soap, tag, id, (basefaults__BaseFaultType **const*)ptr, "basefaults:BaseFaultType");
	case SOAP_TYPE_PointerTobasefaults__BaseFaultType:
		return soap_out_PointerTobasefaults__BaseFaultType(soap, tag, id, (basefaults__BaseFaultType *const*)ptr, "basefaults:BaseFaultType");
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_Description:
		return soap_out_PointerTo_basefaults__BaseFaultType_Description(soap, tag, id, (_basefaults__BaseFaultType_Description *const*)ptr, "basefaults:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, tag, id, (_basefaults__BaseFaultType_ErrorCode *const*)ptr, "basefaults:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__EndpointReferenceType:
		return soap_out_PointerToxsd__EndpointReferenceType(soap, tag, id, (xsd__EndpointReferenceType *const*)ptr, "xsd:EndpointReferenceType");
	case SOAP_TYPE_PointerToxsd__ServiceNameType:
		return soap_out_PointerToxsd__ServiceNameType(soap, tag, id, (xsd__ServiceNameType *const*)ptr, "xsd:ServiceNameType");
	case SOAP_TYPE_PointerToxsd__AttributedQName:
		return soap_out_PointerToxsd__AttributedQName(soap, tag, id, (xsd__AttributedQName *const*)ptr, "xsd:AttributedQName");
	case SOAP_TYPE_PointerToxsd__ReferencePropertiesType:
		return soap_out_PointerToxsd__ReferencePropertiesType(soap, tag, id, (xsd__ReferencePropertiesType *const*)ptr, "xsd:ReferencePropertiesType");
	case SOAP_TYPE_PointerToxsd__AttributedURI:
		return soap_out_PointerToxsd__AttributedURI(soap, tag, id, (xsd__AttributedURI *const*)ptr, "xsd:AttributedURI");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE__xml__lang:
		return soap_out_string(soap, "xml:lang", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__basefaults__BaseFaultType_Description:
		((_basefaults__BaseFaultType_Description *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__basefaults__BaseFaultType_ErrorCode:
		((_basefaults__BaseFaultType_ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__FaultSubcodeValues_:
		((xsd__FaultSubcodeValues_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__RelationshipTypeValues_:
		((xsd__RelationshipTypeValues_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_basefaults__BaseFaultType:
		((basefaults__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__AttributedURI:
		((xsd__AttributedURI *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__AttributedQName:
		((xsd__AttributedQName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__ReplyAfterType:
		((xsd__ReplyAfterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__Relationship:
		((xsd__Relationship *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__ServiceNameType:
		((xsd__ServiceNameType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__ReferencePropertiesType:
		((xsd__ReferencePropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__EndpointReferenceType:
		((xsd__EndpointReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__TerminationNotification:
		((_lifetime__TerminationNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__SetTerminationTimeResponse:
		((_lifetime__SetTerminationTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__SetTerminationTime:
		((_lifetime__SetTerminationTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__DestroyResponse:
		((_lifetime__DestroyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__Destroy:
		((_lifetime__Destroy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__lifetime__ScheduledResourceTerminationRP:
		((_lifetime__ScheduledResourceTerminationRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType:
		((lifetime__TerminationTimeChangeRejectedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType:
		((lifetime__UnableToSetTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType:
		((lifetime__ResourceNotDestroyedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lifetime__ResourceUnknownFaultType:
		((lifetime__ResourceUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		((xsd__nonNegativeInteger_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		((xsd__QName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NCName_:
		((xsd__NCName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___migol__Destroy:
		soap_serialize___migol__Destroy(soap, (const struct __migol__Destroy *)ptr);
		break;
	case SOAP_TYPE___migol__checkPoint:
		soap_serialize___migol__checkPoint(soap, (const struct __migol__checkPoint *)ptr);
		break;
	case SOAP_TYPE___migol__checkPointResponse:
		soap_serialize___migol__checkPointResponse(soap, (const struct __migol__checkPointResponse *)ptr);
		break;
	case SOAP_TYPE___migol__checkService:
		soap_serialize___migol__checkService(soap, (const struct __migol__checkService *)ptr);
		break;
	case SOAP_TYPE___migol__checkServiceResponse:
		soap_serialize___migol__checkServiceResponse(soap, (const struct __migol__checkServiceResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTo_lifetime__DestroyResponse:
		soap_serialize_PointerTo_lifetime__DestroyResponse(soap, (_lifetime__DestroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_lifetime__Destroy:
		soap_serialize_PointerTo_lifetime__Destroy(soap, (_lifetime__Destroy *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobasefaults__BaseFaultType:
		soap_serialize_PointerToPointerTobasefaults__BaseFaultType(soap, (basefaults__BaseFaultType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobasefaults__BaseFaultType:
		soap_serialize_PointerTobasefaults__BaseFaultType(soap, (basefaults__BaseFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_Description:
		soap_serialize_PointerTo_basefaults__BaseFaultType_Description(soap, (_basefaults__BaseFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_basefaults__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, (_basefaults__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__EndpointReferenceType:
		soap_serialize_PointerToxsd__EndpointReferenceType(soap, (xsd__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ServiceNameType:
		soap_serialize_PointerToxsd__ServiceNameType(soap, (xsd__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__AttributedQName:
		soap_serialize_PointerToxsd__AttributedQName(soap, (xsd__AttributedQName *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ReferencePropertiesType:
		soap_serialize_PointerToxsd__ReferencePropertiesType(soap, (xsd__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__AttributedURI:
		soap_serialize_PointerToxsd__AttributedURI(soap, (xsd__AttributedURI *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName_:
		return (void*)soap_instantiate_xsd__NCName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return (void*)soap_instantiate_xsd__nonNegativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__RelationshipTypeValues_:
		return (void*)soap_instantiate_xsd__RelationshipTypeValues_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__FaultSubcodeValues_:
		return (void*)soap_instantiate_xsd__FaultSubcodeValues_(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__ScheduledResourceTerminationRP:
		return (void*)soap_instantiate__lifetime__ScheduledResourceTerminationRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__Destroy:
		return (void*)soap_instantiate__lifetime__Destroy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__DestroyResponse:
		return (void*)soap_instantiate__lifetime__DestroyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__SetTerminationTime:
		return (void*)soap_instantiate__lifetime__SetTerminationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__SetTerminationTimeResponse:
		return (void*)soap_instantiate__lifetime__SetTerminationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__lifetime__TerminationNotification:
		return (void*)soap_instantiate__lifetime__TerminationNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__EndpointReferenceType:
		return (void*)soap_instantiate_xsd__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ReferencePropertiesType:
		return (void*)soap_instantiate_xsd__ReferencePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__basefaults__BaseFaultType_ErrorCode:
		return (void*)soap_instantiate__basefaults__BaseFaultType_ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__basefaults__BaseFaultType_Description:
		return (void*)soap_instantiate__basefaults__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_basefaults__BaseFaultType:
		return (void*)soap_instantiate_basefaults__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lifetime__ResourceUnknownFaultType:
		return (void*)soap_instantiate_lifetime__ResourceUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType:
		return (void*)soap_instantiate_lifetime__ResourceNotDestroyedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType:
		return (void*)soap_instantiate_lifetime__UnableToSetTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType:
		return (void*)soap_instantiate_lifetime__TerminationTimeChangeRejectedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ServiceNameType:
		return (void*)soap_instantiate_xsd__ServiceNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__Relationship:
		return (void*)soap_instantiate_xsd__Relationship(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ReplyAfterType:
		return (void*)soap_instantiate_xsd__ReplyAfterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__AttributedQName:
		return (void*)soap_instantiate_xsd__AttributedQName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__AttributedURI:
		return (void*)soap_instantiate_xsd__AttributedURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE___migol__checkServiceResponse:
		return (void*)soap_instantiate___migol__checkServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___migol__checkService:
		return (void*)soap_instantiate___migol__checkService(soap, -1, type, arrayType, n);
	case SOAP_TYPE___migol__checkPointResponse:
		return (void*)soap_instantiate___migol__checkPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___migol__checkPoint:
		return (void*)soap_instantiate___migol__checkPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE___migol__Destroy:
		return (void*)soap_instantiate___migol__Destroy(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__NCName_:
		if (p->size < 0)
			delete (xsd__NCName_*)p->ptr;
		else
			delete[] (xsd__NCName_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			delete (xsd__QName*)p->ptr;
		else
			delete[] (xsd__QName*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			delete (xsd__anyURI_*)p->ptr;
		else
			delete[] (xsd__anyURI_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		if (p->size < 0)
			delete (xsd__nonNegativeInteger_*)p->ptr;
		else
			delete[] (xsd__nonNegativeInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__RelationshipTypeValues_:
		if (p->size < 0)
			delete (xsd__RelationshipTypeValues_*)p->ptr;
		else
			delete[] (xsd__RelationshipTypeValues_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__FaultSubcodeValues_:
		if (p->size < 0)
			delete (xsd__FaultSubcodeValues_*)p->ptr;
		else
			delete[] (xsd__FaultSubcodeValues_*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__ScheduledResourceTerminationRP:
		if (p->size < 0)
			delete (_lifetime__ScheduledResourceTerminationRP*)p->ptr;
		else
			delete[] (_lifetime__ScheduledResourceTerminationRP*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__Destroy:
		if (p->size < 0)
			delete (_lifetime__Destroy*)p->ptr;
		else
			delete[] (_lifetime__Destroy*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__DestroyResponse:
		if (p->size < 0)
			delete (_lifetime__DestroyResponse*)p->ptr;
		else
			delete[] (_lifetime__DestroyResponse*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__SetTerminationTime:
		if (p->size < 0)
			delete (_lifetime__SetTerminationTime*)p->ptr;
		else
			delete[] (_lifetime__SetTerminationTime*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__SetTerminationTimeResponse:
		if (p->size < 0)
			delete (_lifetime__SetTerminationTimeResponse*)p->ptr;
		else
			delete[] (_lifetime__SetTerminationTimeResponse*)p->ptr;
		break;
	case SOAP_TYPE__lifetime__TerminationNotification:
		if (p->size < 0)
			delete (_lifetime__TerminationNotification*)p->ptr;
		else
			delete[] (_lifetime__TerminationNotification*)p->ptr;
		break;
	case SOAP_TYPE_xsd__EndpointReferenceType:
		if (p->size < 0)
			delete (xsd__EndpointReferenceType*)p->ptr;
		else
			delete[] (xsd__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__ReferencePropertiesType:
		if (p->size < 0)
			delete (xsd__ReferencePropertiesType*)p->ptr;
		else
			delete[] (xsd__ReferencePropertiesType*)p->ptr;
		break;
	case SOAP_TYPE__basefaults__BaseFaultType_ErrorCode:
		if (p->size < 0)
			delete (_basefaults__BaseFaultType_ErrorCode*)p->ptr;
		else
			delete[] (_basefaults__BaseFaultType_ErrorCode*)p->ptr;
		break;
	case SOAP_TYPE__basefaults__BaseFaultType_Description:
		if (p->size < 0)
			delete (_basefaults__BaseFaultType_Description*)p->ptr;
		else
			delete[] (_basefaults__BaseFaultType_Description*)p->ptr;
		break;
	case SOAP_TYPE_basefaults__BaseFaultType:
		if (p->size < 0)
			delete (basefaults__BaseFaultType*)p->ptr;
		else
			delete[] (basefaults__BaseFaultType*)p->ptr;
		break;
	case SOAP_TYPE_lifetime__ResourceUnknownFaultType:
		if (p->size < 0)
			delete (lifetime__ResourceUnknownFaultType*)p->ptr;
		else
			delete[] (lifetime__ResourceUnknownFaultType*)p->ptr;
		break;
	case SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType:
		if (p->size < 0)
			delete (lifetime__ResourceNotDestroyedFaultType*)p->ptr;
		else
			delete[] (lifetime__ResourceNotDestroyedFaultType*)p->ptr;
		break;
	case SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType:
		if (p->size < 0)
			delete (lifetime__UnableToSetTerminationTimeFaultType*)p->ptr;
		else
			delete[] (lifetime__UnableToSetTerminationTimeFaultType*)p->ptr;
		break;
	case SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType:
		if (p->size < 0)
			delete (lifetime__TerminationTimeChangeRejectedFaultType*)p->ptr;
		else
			delete[] (lifetime__TerminationTimeChangeRejectedFaultType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__ServiceNameType:
		if (p->size < 0)
			delete (xsd__ServiceNameType*)p->ptr;
		else
			delete[] (xsd__ServiceNameType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__Relationship:
		if (p->size < 0)
			delete (xsd__Relationship*)p->ptr;
		else
			delete[] (xsd__Relationship*)p->ptr;
		break;
	case SOAP_TYPE_xsd__ReplyAfterType:
		if (p->size < 0)
			delete (xsd__ReplyAfterType*)p->ptr;
		else
			delete[] (xsd__ReplyAfterType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__AttributedQName:
		if (p->size < 0)
			delete (xsd__AttributedQName*)p->ptr;
		else
			delete[] (xsd__AttributedQName*)p->ptr;
		break;
	case SOAP_TYPE_xsd__AttributedURI:
		if (p->size < 0)
			delete (xsd__AttributedURI*)p->ptr;
		else
			delete[] (xsd__AttributedURI*)p->ptr;
		break;
	case SOAP_TYPE___migol__checkServiceResponse:
		if (p->size < 0)
			delete (struct __migol__checkServiceResponse*)p->ptr;
		else
			delete[] (struct __migol__checkServiceResponse*)p->ptr;
		break;
	case SOAP_TYPE___migol__checkService:
		if (p->size < 0)
			delete (struct __migol__checkService*)p->ptr;
		else
			delete[] (struct __migol__checkService*)p->ptr;
		break;
	case SOAP_TYPE___migol__checkPointResponse:
		if (p->size < 0)
			delete (struct __migol__checkPointResponse*)p->ptr;
		else
			delete[] (struct __migol__checkPointResponse*)p->ptr;
		break;
	case SOAP_TYPE___migol__checkPoint:
		if (p->size < 0)
			delete (struct __migol__checkPoint*)p->ptr;
		else
			delete[] (struct __migol__checkPoint*)p->ptr;
		break;
	case SOAP_TYPE___migol__Destroy:
		if (p->size < 0)
			delete (struct __migol__Destroy*)p->ptr;
		else
			delete[] (struct __migol__Destroy*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__FaultSubcodeValues(struct soap *soap, enum xsd__FaultSubcodeValues *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__FaultSubcodeValues
	*a = SOAP_DEFAULT_xsd__FaultSubcodeValues;
#else
	*a = (enum xsd__FaultSubcodeValues)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__FaultSubcodeValues(struct soap *soap, const enum xsd__FaultSubcodeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__FaultSubcodeValues);
	if (soap_out_xsd__FaultSubcodeValues(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__FaultSubcodeValues[] =
{	{ (long)xsd__FaultSubcodeValues__xsd__InvalidMessageInformationHeader, "xsd:InvalidMessageInformationHeader" },
	{ (long)xsd__FaultSubcodeValues__xsd__MessageInformationHeaderRequired, "xsd:MessageInformationHeaderRequired" },
	{ (long)xsd__FaultSubcodeValues__xsd__DestinationUnreachable, "xsd:DestinationUnreachable" },
	{ (long)xsd__FaultSubcodeValues__xsd__ActionNotSupported, "xsd:ActionNotSupported" },
	{ (long)xsd__FaultSubcodeValues__xsd__EndpointUnavailable, "xsd:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__FaultSubcodeValues2s(struct soap *soap, enum xsd__FaultSubcodeValues n)
{	const char *s = soap_code_str(soap_codes_xsd__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum xsd__FaultSubcodeValues *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__FaultSubcodeValues), type) || soap_send(soap, soap_xsd__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__FaultSubcodeValues * SOAP_FMAC4 soap_get_xsd__FaultSubcodeValues(struct soap *soap, enum xsd__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__FaultSubcodeValues(struct soap *soap, const char *s, enum xsd__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_xsd__FaultSubcodeValues, t);
	if (map)
		*a = (enum xsd__FaultSubcodeValues)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__FaultSubcodeValues * SOAP_FMAC4 soap_in_xsd__FaultSubcodeValues(struct soap *soap, const char *tag, enum xsd__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xsd__FaultSubcodeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__FaultSubcodeValues, sizeof(enum xsd__FaultSubcodeValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__FaultSubcodeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__FaultSubcodeValues, 0, sizeof(enum xsd__FaultSubcodeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__RelationshipTypeValues(struct soap *soap, enum xsd__RelationshipTypeValues *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__RelationshipTypeValues
	*a = SOAP_DEFAULT_xsd__RelationshipTypeValues;
#else
	*a = (enum xsd__RelationshipTypeValues)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__RelationshipTypeValues(struct soap *soap, const enum xsd__RelationshipTypeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__RelationshipTypeValues);
	if (soap_out_xsd__RelationshipTypeValues(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__RelationshipTypeValues[] =
{	{ (long)xsd__RelationshipTypeValues__xsd__Reply, "xsd:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__RelationshipTypeValues2s(struct soap *soap, enum xsd__RelationshipTypeValues n)
{	const char *s = soap_code_str(soap_codes_xsd__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum xsd__RelationshipTypeValues *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__RelationshipTypeValues), type) || soap_send(soap, soap_xsd__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__RelationshipTypeValues * SOAP_FMAC4 soap_get_xsd__RelationshipTypeValues(struct soap *soap, enum xsd__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__RelationshipTypeValues(struct soap *soap, const char *s, enum xsd__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_xsd__RelationshipTypeValues, t);
	if (map)
		*a = (enum xsd__RelationshipTypeValues)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__RelationshipTypeValues * SOAP_FMAC4 soap_in_xsd__RelationshipTypeValues(struct soap *soap, const char *tag, enum xsd__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xsd__RelationshipTypeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__RelationshipTypeValues, sizeof(enum xsd__RelationshipTypeValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__RelationshipTypeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__RelationshipTypeValues, 0, sizeof(enum xsd__RelationshipTypeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _basefaults__BaseFaultType_Description::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->_basefaults__BaseFaultType_Description::__item);
	soap_default__xml__lang(soap, &this->_basefaults__BaseFaultType_Description::xml__lang);
}

void _basefaults__BaseFaultType_Description::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_basefaults__BaseFaultType_Description::__item);
}

int _basefaults__BaseFaultType_Description::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__basefaults__BaseFaultType_Description);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _basefaults__BaseFaultType_Description::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__basefaults__BaseFaultType_Description(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__basefaults__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const _basefaults__BaseFaultType_Description *a, const char *type)
{
	if (((_basefaults__BaseFaultType_Description *)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", ((_basefaults__BaseFaultType_Description *)a)->xml__lang);
	return soap_out_string(soap, tag, id, &a->_basefaults__BaseFaultType_Description::__item, "");
}

void *_basefaults__BaseFaultType_Description::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__basefaults__BaseFaultType_Description(soap, this, tag, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_Description * SOAP_FMAC4 soap_get__basefaults__BaseFaultType_Description(struct soap *soap, _basefaults__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__basefaults__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_basefaults__BaseFaultType_Description::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__basefaults__BaseFaultType_Description(soap, tag, this, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_Description * SOAP_FMAC4 soap_in__basefaults__BaseFaultType_Description(struct soap *soap, const char *tag, _basefaults__BaseFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_basefaults__BaseFaultType_Description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__basefaults__BaseFaultType_Description, sizeof(_basefaults__BaseFaultType_Description), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__basefaults__BaseFaultType_Description)
			return (_basefaults__BaseFaultType_Description *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "xml:lang", 0), &((_basefaults__BaseFaultType_Description *)a)->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, &(a->_basefaults__BaseFaultType_Description::__item), ""))
		return NULL;
	return a;
}

SOAP_FMAC5 _basefaults__BaseFaultType_Description * SOAP_FMAC6 soap_new__basefaults__BaseFaultType_Description(struct soap *soap, int n)
{	return soap_instantiate__basefaults__BaseFaultType_Description(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__basefaults__BaseFaultType_Description(struct soap *soap, _basefaults__BaseFaultType_Description *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _basefaults__BaseFaultType_Description * SOAP_FMAC4 soap_instantiate__basefaults__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__basefaults__BaseFaultType_Description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__basefaults__BaseFaultType_Description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _basefaults__BaseFaultType_Description;
		if (size)
			*size = sizeof(_basefaults__BaseFaultType_Description);
	}
	else
	{	cp->ptr = (void*)new _basefaults__BaseFaultType_Description[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_basefaults__BaseFaultType_Description);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_basefaults__BaseFaultType_Description*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__basefaults__BaseFaultType_Description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _basefaults__BaseFaultType_Description %p -> %p\n", q, p));
	*(_basefaults__BaseFaultType_Description*)p = *(_basefaults__BaseFaultType_Description*)q;
}

void _basefaults__BaseFaultType_ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->_basefaults__BaseFaultType_ErrorCode::dialect);
}

void _basefaults__BaseFaultType_ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int _basefaults__BaseFaultType_ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _basefaults__BaseFaultType_ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__basefaults__BaseFaultType_ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__basefaults__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const _basefaults__BaseFaultType_ErrorCode *a, const char *type)
{
	if (((_basefaults__BaseFaultType_ErrorCode *)a)->dialect)
		soap_set_attr(soap, "dialect", ((_basefaults__BaseFaultType_ErrorCode *)a)->dialect);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_basefaults__BaseFaultType_ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__basefaults__BaseFaultType_ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__basefaults__BaseFaultType_ErrorCode(struct soap *soap, _basefaults__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__basefaults__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_basefaults__BaseFaultType_ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__basefaults__BaseFaultType_ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__basefaults__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _basefaults__BaseFaultType_ErrorCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_basefaults__BaseFaultType_ErrorCode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode, sizeof(_basefaults__BaseFaultType_ErrorCode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__basefaults__BaseFaultType_ErrorCode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_basefaults__BaseFaultType_ErrorCode *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &((_basefaults__BaseFaultType_ErrorCode *)a)->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_basefaults__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode, 0, sizeof(_basefaults__BaseFaultType_ErrorCode), 0, soap_copy__basefaults__BaseFaultType_ErrorCode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _basefaults__BaseFaultType_ErrorCode * SOAP_FMAC6 soap_new__basefaults__BaseFaultType_ErrorCode(struct soap *soap, int n)
{	return soap_instantiate__basefaults__BaseFaultType_ErrorCode(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__basefaults__BaseFaultType_ErrorCode(struct soap *soap, _basefaults__BaseFaultType_ErrorCode *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _basefaults__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_instantiate__basefaults__BaseFaultType_ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__basefaults__BaseFaultType_ErrorCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _basefaults__BaseFaultType_ErrorCode;
		if (size)
			*size = sizeof(_basefaults__BaseFaultType_ErrorCode);
	}
	else
	{	cp->ptr = (void*)new _basefaults__BaseFaultType_ErrorCode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_basefaults__BaseFaultType_ErrorCode);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_basefaults__BaseFaultType_ErrorCode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__basefaults__BaseFaultType_ErrorCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _basefaults__BaseFaultType_ErrorCode %p -> %p\n", q, p));
	*(_basefaults__BaseFaultType_ErrorCode*)p = *(_basefaults__BaseFaultType_ErrorCode*)q;
}

void xsd__FaultSubcodeValues_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__FaultSubcodeValues(soap, &this->xsd__FaultSubcodeValues_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__FaultSubcodeValues_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__FaultSubcodeValues_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__FaultSubcodeValues_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__FaultSubcodeValues_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__FaultSubcodeValues_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__FaultSubcodeValues_(struct soap *soap, const char *tag, int id, const xsd__FaultSubcodeValues_ *a, const char *type)
{
	return soap_out_xsd__FaultSubcodeValues(soap, tag, id, &(a->xsd__FaultSubcodeValues_::__item), "xsd:FaultSubcodeValues");
}

void *xsd__FaultSubcodeValues_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__FaultSubcodeValues_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__FaultSubcodeValues_ * SOAP_FMAC4 soap_get_xsd__FaultSubcodeValues_(struct soap *soap, xsd__FaultSubcodeValues_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__FaultSubcodeValues_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__FaultSubcodeValues_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__FaultSubcodeValues_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__FaultSubcodeValues_ * SOAP_FMAC4 soap_in_xsd__FaultSubcodeValues_(struct soap *soap, const char *tag, xsd__FaultSubcodeValues_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__FaultSubcodeValues_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__FaultSubcodeValues_, sizeof(xsd__FaultSubcodeValues_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__FaultSubcodeValues_)
			return (xsd__FaultSubcodeValues_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__FaultSubcodeValues(soap, tag, &(a->xsd__FaultSubcodeValues_::__item), "xsd:FaultSubcodeValues"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__FaultSubcodeValues_ * SOAP_FMAC6 soap_new_xsd__FaultSubcodeValues_(struct soap *soap, int n)
{	return soap_instantiate_xsd__FaultSubcodeValues_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__FaultSubcodeValues_(struct soap *soap, xsd__FaultSubcodeValues_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__FaultSubcodeValues_ * SOAP_FMAC4 soap_instantiate_xsd__FaultSubcodeValues_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__FaultSubcodeValues_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__FaultSubcodeValues_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__FaultSubcodeValues_;
		if (size)
			*size = sizeof(xsd__FaultSubcodeValues_);
		((xsd__FaultSubcodeValues_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__FaultSubcodeValues_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__FaultSubcodeValues_);
		for (int i = 0; i < n; i++)
			((xsd__FaultSubcodeValues_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__FaultSubcodeValues_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__FaultSubcodeValues_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__FaultSubcodeValues_ %p -> %p\n", q, p));
	*(xsd__FaultSubcodeValues_*)p = *(xsd__FaultSubcodeValues_*)q;
}

void xsd__RelationshipTypeValues_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__RelationshipTypeValues(soap, &this->xsd__RelationshipTypeValues_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__RelationshipTypeValues_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__RelationshipTypeValues_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__RelationshipTypeValues_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__RelationshipTypeValues_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__RelationshipTypeValues_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__RelationshipTypeValues_(struct soap *soap, const char *tag, int id, const xsd__RelationshipTypeValues_ *a, const char *type)
{
	return soap_out_xsd__RelationshipTypeValues(soap, tag, id, &(a->xsd__RelationshipTypeValues_::__item), "xsd:RelationshipTypeValues");
}

void *xsd__RelationshipTypeValues_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__RelationshipTypeValues_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__RelationshipTypeValues_ * SOAP_FMAC4 soap_get_xsd__RelationshipTypeValues_(struct soap *soap, xsd__RelationshipTypeValues_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__RelationshipTypeValues_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__RelationshipTypeValues_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__RelationshipTypeValues_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__RelationshipTypeValues_ * SOAP_FMAC4 soap_in_xsd__RelationshipTypeValues_(struct soap *soap, const char *tag, xsd__RelationshipTypeValues_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__RelationshipTypeValues_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__RelationshipTypeValues_, sizeof(xsd__RelationshipTypeValues_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__RelationshipTypeValues_)
			return (xsd__RelationshipTypeValues_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__RelationshipTypeValues(soap, tag, &(a->xsd__RelationshipTypeValues_::__item), "xsd:RelationshipTypeValues"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__RelationshipTypeValues_ * SOAP_FMAC6 soap_new_xsd__RelationshipTypeValues_(struct soap *soap, int n)
{	return soap_instantiate_xsd__RelationshipTypeValues_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__RelationshipTypeValues_(struct soap *soap, xsd__RelationshipTypeValues_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__RelationshipTypeValues_ * SOAP_FMAC4 soap_instantiate_xsd__RelationshipTypeValues_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__RelationshipTypeValues_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__RelationshipTypeValues_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__RelationshipTypeValues_;
		if (size)
			*size = sizeof(xsd__RelationshipTypeValues_);
		((xsd__RelationshipTypeValues_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__RelationshipTypeValues_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__RelationshipTypeValues_);
		for (int i = 0; i < n; i++)
			((xsd__RelationshipTypeValues_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__RelationshipTypeValues_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__RelationshipTypeValues_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__RelationshipTypeValues_ %p -> %p\n", q, p));
	*(xsd__RelationshipTypeValues_*)p = *(xsd__RelationshipTypeValues_*)q;
}

void basefaults__BaseFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->basefaults__BaseFaultType::Timestamp);
	this->basefaults__BaseFaultType::Originator = NULL;
	this->basefaults__BaseFaultType::ErrorCode = NULL;
	this->basefaults__BaseFaultType::__sizeDescription = 0;
	this->basefaults__BaseFaultType::Description = NULL;
	this->basefaults__BaseFaultType::__sizeFaultCause = 0;
	this->basefaults__BaseFaultType::FaultCause = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void basefaults__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->basefaults__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__EndpointReferenceType(soap, &this->basefaults__BaseFaultType::Originator);
	soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, &this->basefaults__BaseFaultType::ErrorCode);
	if (this->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->basefaults__BaseFaultType::Description + i, SOAP_TYPE__basefaults__BaseFaultType_Description);
			this->basefaults__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	if (this->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeFaultCause; i++)
		{
			soap_serialize_PointerTobasefaults__BaseFaultType(soap, this->basefaults__BaseFaultType::FaultCause + i);
		}
	}
	/* transient soap skipped */
}

int basefaults__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_basefaults__BaseFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int basefaults__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_basefaults__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_basefaults__BaseFaultType(struct soap *soap, const char *tag, int id, const basefaults__BaseFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_basefaults__BaseFaultType), "basefaults:BaseFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "basefaults:Timestamp", -1, &(a->basefaults__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", -1, &(a->basefaults__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", -1, &(a->basefaults__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeDescription; i++)
			if (a->basefaults__BaseFaultType::Description[i].soap_out(soap, "basefaults:Description", -1, ""))
				return soap->error;
	}
	if (a->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeFaultCause; i++)
			if (soap_out_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", -1, a->basefaults__BaseFaultType::FaultCause + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *basefaults__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_basefaults__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 basefaults__BaseFaultType * SOAP_FMAC4 soap_get_basefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_basefaults__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *basefaults__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_basefaults__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 basefaults__BaseFaultType * SOAP_FMAC4 soap_in_basefaults__BaseFaultType(struct soap *soap, const char *tag, basefaults__BaseFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (basefaults__BaseFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_basefaults__BaseFaultType, sizeof(basefaults__BaseFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_basefaults__BaseFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (basefaults__BaseFaultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_Timestamp1 = 1, soap_flag_Originator1 = 1, soap_flag_ErrorCode1 = 1, soap_flag_Description1 = 1, soap_flag_FaultCause1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "basefaults:Timestamp", &(a->basefaults__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", &(a->basefaults__BaseFaultType::Originator), "xsd:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", &(a->basefaults__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			if (soap_flag_Description1 && soap->error == SOAP_TAG_MISMATCH)
			{	_basefaults__BaseFaultType_Description *p;
				_basefaults__BaseFaultType_Description q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeDescription = 0; !soap_element_begin_in(soap, "basefaults:Description", 1, NULL); a->basefaults__BaseFaultType::__sizeDescription++)
				{	p = (_basefaults__BaseFaultType_Description *)soap_push_block(soap, sizeof(_basefaults__BaseFaultType_Description));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(_basefaults__BaseFaultType_Description));
					p->soap_default(soap);
					soap_revert(soap);
					if (!soap_in__basefaults__BaseFaultType_Description(soap, "basefaults:Description", p, ""))
						break;
					soap_flag_Description1 = 0;
				}
				a->basefaults__BaseFaultType::Description = (_basefaults__BaseFaultType_Description *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Description1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	basefaults__BaseFaultType **p;
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeFaultCause = 0; !soap_element_begin_in(soap, "basefaults:FaultCause", 1, NULL); a->basefaults__BaseFaultType::__sizeFaultCause++)
				{	p = (basefaults__BaseFaultType **)soap_push_block(soap, sizeof(basefaults__BaseFaultType *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", p, "basefaults:BaseFaultType"))
						break;
					soap_flag_FaultCause1 = 0;
				}
				a->basefaults__BaseFaultType::FaultCause = (basefaults__BaseFaultType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (basefaults__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_basefaults__BaseFaultType, 0, sizeof(basefaults__BaseFaultType), 0, soap_copy_basefaults__BaseFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 basefaults__BaseFaultType * SOAP_FMAC6 soap_new_basefaults__BaseFaultType(struct soap *soap, int n)
{	return soap_instantiate_basefaults__BaseFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_basefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 basefaults__BaseFaultType * SOAP_FMAC4 soap_instantiate_basefaults__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_basefaults__BaseFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_basefaults__BaseFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "lifetime:ResourceUnknownFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__ResourceUnknownFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__ResourceUnknownFaultType);
			((lifetime__ResourceUnknownFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__ResourceUnknownFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__ResourceUnknownFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__ResourceUnknownFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:ResourceNotDestroyedFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__ResourceNotDestroyedFaultType);
			((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__ResourceNotDestroyedFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__ResourceNotDestroyedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:UnableToSetTerminationTimeFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__UnableToSetTerminationTimeFaultType);
			((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__UnableToSetTerminationTimeFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:TerminationTimeChangeRejectedFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
			((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new basefaults__BaseFaultType;
		if (size)
			*size = sizeof(basefaults__BaseFaultType);
		((basefaults__BaseFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new basefaults__BaseFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(basefaults__BaseFaultType);
		for (int i = 0; i < n; i++)
			((basefaults__BaseFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (basefaults__BaseFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_basefaults__BaseFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying basefaults__BaseFaultType %p -> %p\n", q, p));
	*(basefaults__BaseFaultType*)p = *(basefaults__BaseFaultType*)q;
}

void xsd__AttributedURI::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->xsd__AttributedURI::__item);
	this->xsd__AttributedURI::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__AttributedURI::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->xsd__AttributedURI::__item);
	/* transient soap skipped */
}

int xsd__AttributedURI::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__AttributedURI);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__AttributedURI::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__AttributedURI(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__AttributedURI(struct soap *soap, const char *tag, int id, const xsd__AttributedURI *a, const char *type)
{
	if (((xsd__AttributedURI *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__AttributedURI *)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__AttributedURI::__item), "xsd:AttributedURI");
}

void *xsd__AttributedURI::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__AttributedURI(soap, this, tag, type);
}

SOAP_FMAC3 xsd__AttributedURI * SOAP_FMAC4 soap_get_xsd__AttributedURI(struct soap *soap, xsd__AttributedURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__AttributedURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__AttributedURI::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__AttributedURI(soap, tag, this, type);
}

SOAP_FMAC3 xsd__AttributedURI * SOAP_FMAC4 soap_in_xsd__AttributedURI(struct soap *soap, const char *tag, xsd__AttributedURI *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__AttributedURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__AttributedURI, sizeof(xsd__AttributedURI), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__AttributedURI)
			return (xsd__AttributedURI *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__AttributedURI *)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__AttributedURI::__item), "xsd:AttributedURI"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__AttributedURI * SOAP_FMAC6 soap_new_xsd__AttributedURI(struct soap *soap, int n)
{	return soap_instantiate_xsd__AttributedURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__AttributedURI(struct soap *soap, xsd__AttributedURI *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__AttributedURI * SOAP_FMAC4 soap_instantiate_xsd__AttributedURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__AttributedURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__AttributedURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__AttributedURI;
		if (size)
			*size = sizeof(xsd__AttributedURI);
		((xsd__AttributedURI*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__AttributedURI[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__AttributedURI);
		for (int i = 0; i < n; i++)
			((xsd__AttributedURI*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__AttributedURI*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__AttributedURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__AttributedURI %p -> %p\n", q, p));
	*(xsd__AttributedURI*)p = *(xsd__AttributedURI*)q;
}

void xsd__AttributedQName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__QName(soap, &this->xsd__AttributedQName::__item);
	this->xsd__AttributedQName::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__AttributedQName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &this->xsd__AttributedQName::__item);
	/* transient soap skipped */
}

int xsd__AttributedQName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__AttributedQName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__AttributedQName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__AttributedQName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__AttributedQName(struct soap *soap, const char *tag, int id, const xsd__AttributedQName *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (((xsd__AttributedQName *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__AttributedQName *)a)->__anyAttribute);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "xsd:AttributedQName");
}

void *xsd__AttributedQName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__AttributedQName(soap, this, tag, type);
}

SOAP_FMAC3 xsd__AttributedQName * SOAP_FMAC4 soap_get_xsd__AttributedQName(struct soap *soap, xsd__AttributedQName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__AttributedQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__AttributedQName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__AttributedQName(soap, tag, this, type);
}

SOAP_FMAC3 xsd__AttributedQName * SOAP_FMAC4 soap_in_xsd__AttributedQName(struct soap *soap, const char *tag, xsd__AttributedQName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__AttributedQName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__AttributedQName, sizeof(xsd__AttributedQName), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__AttributedQName)
			return (xsd__AttributedQName *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__AttributedQName *)a)->__anyAttribute))
		return NULL;
	if (!soap_in__QName(soap, tag, &(a->xsd__AttributedQName::__item), "xsd:AttributedQName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__AttributedQName * SOAP_FMAC6 soap_new_xsd__AttributedQName(struct soap *soap, int n)
{	return soap_instantiate_xsd__AttributedQName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__AttributedQName(struct soap *soap, xsd__AttributedQName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__AttributedQName * SOAP_FMAC4 soap_instantiate_xsd__AttributedQName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__AttributedQName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__AttributedQName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__AttributedQName;
		if (size)
			*size = sizeof(xsd__AttributedQName);
		((xsd__AttributedQName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__AttributedQName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__AttributedQName);
		for (int i = 0; i < n; i++)
			((xsd__AttributedQName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__AttributedQName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__AttributedQName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__AttributedQName %p -> %p\n", q, p));
	*(xsd__AttributedQName*)p = *(xsd__AttributedQName*)q;
}

void xsd__ReplyAfterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->xsd__ReplyAfterType::__item);
	this->xsd__ReplyAfterType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__ReplyAfterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->xsd__ReplyAfterType::__item);
	/* transient soap skipped */
}

int xsd__ReplyAfterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__ReplyAfterType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__ReplyAfterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ReplyAfterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ReplyAfterType(struct soap *soap, const char *tag, int id, const xsd__ReplyAfterType *a, const char *type)
{
	if (((xsd__ReplyAfterType *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__ReplyAfterType *)a)->__anyAttribute);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &(a->xsd__ReplyAfterType::__item), "xsd:ReplyAfterType");
}

void *xsd__ReplyAfterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ReplyAfterType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ReplyAfterType * SOAP_FMAC4 soap_get_xsd__ReplyAfterType(struct soap *soap, xsd__ReplyAfterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ReplyAfterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__ReplyAfterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__ReplyAfterType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ReplyAfterType * SOAP_FMAC4 soap_in_xsd__ReplyAfterType(struct soap *soap, const char *tag, xsd__ReplyAfterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__ReplyAfterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__ReplyAfterType, sizeof(xsd__ReplyAfterType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__ReplyAfterType)
			return (xsd__ReplyAfterType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__ReplyAfterType *)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->xsd__ReplyAfterType::__item), "xsd:ReplyAfterType"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__ReplyAfterType * SOAP_FMAC6 soap_new_xsd__ReplyAfterType(struct soap *soap, int n)
{	return soap_instantiate_xsd__ReplyAfterType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ReplyAfterType(struct soap *soap, xsd__ReplyAfterType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__ReplyAfterType * SOAP_FMAC4 soap_instantiate_xsd__ReplyAfterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ReplyAfterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__ReplyAfterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__ReplyAfterType;
		if (size)
			*size = sizeof(xsd__ReplyAfterType);
		((xsd__ReplyAfterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__ReplyAfterType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__ReplyAfterType);
		for (int i = 0; i < n; i++)
			((xsd__ReplyAfterType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__ReplyAfterType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ReplyAfterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__ReplyAfterType %p -> %p\n", q, p));
	*(xsd__ReplyAfterType*)p = *(xsd__ReplyAfterType*)q;
}

void xsd__Relationship::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->xsd__Relationship::__item);
	soap_default__QName(soap, &this->xsd__Relationship::RelationshipType);
	this->xsd__Relationship::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__Relationship::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->xsd__Relationship::__item);
	/* transient soap skipped */
}

int xsd__Relationship::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__Relationship);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__Relationship::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__Relationship(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Relationship(struct soap *soap, const char *tag, int id, const xsd__Relationship *a, const char *type)
{
	if (((xsd__Relationship *)a)->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, ((xsd__Relationship *)a)->RelationshipType));
	if (((xsd__Relationship *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__Relationship *)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__Relationship::__item), "xsd:Relationship");
}

void *xsd__Relationship::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__Relationship(soap, this, tag, type);
}

SOAP_FMAC3 xsd__Relationship * SOAP_FMAC4 soap_get_xsd__Relationship(struct soap *soap, xsd__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__Relationship::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__Relationship(soap, tag, this, type);
}

SOAP_FMAC3 xsd__Relationship * SOAP_FMAC4 soap_in_xsd__Relationship(struct soap *soap, const char *tag, xsd__Relationship *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__Relationship *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__Relationship, sizeof(xsd__Relationship), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__Relationship)
			return (xsd__Relationship *)a->soap_in(soap, tag, type);
	}
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &((xsd__Relationship *)a)->RelationshipType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__Relationship *)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__Relationship::__item), "xsd:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__Relationship * SOAP_FMAC6 soap_new_xsd__Relationship(struct soap *soap, int n)
{	return soap_instantiate_xsd__Relationship(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__Relationship(struct soap *soap, xsd__Relationship *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__Relationship * SOAP_FMAC4 soap_instantiate_xsd__Relationship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__Relationship(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__Relationship, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__Relationship;
		if (size)
			*size = sizeof(xsd__Relationship);
		((xsd__Relationship*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__Relationship[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__Relationship);
		for (int i = 0; i < n; i++)
			((xsd__Relationship*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__Relationship*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__Relationship(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__Relationship %p -> %p\n", q, p));
	*(xsd__Relationship*)p = *(xsd__Relationship*)q;
}

void xsd__ServiceNameType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__QName(soap, &this->xsd__ServiceNameType::__item);
	soap_default_xsd__NCName(soap, &this->xsd__ServiceNameType::PortName);
	this->xsd__ServiceNameType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__ServiceNameType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &this->xsd__ServiceNameType::__item);
	/* transient soap skipped */
}

int xsd__ServiceNameType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__ServiceNameType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__ServiceNameType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ServiceNameType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ServiceNameType(struct soap *soap, const char *tag, int id, const xsd__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (((xsd__ServiceNameType *)a)->PortName)
		soap_set_attr(soap, "PortName", ((xsd__ServiceNameType *)a)->PortName);
	if (((xsd__ServiceNameType *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__ServiceNameType *)a)->__anyAttribute);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "xsd:ServiceNameType");
}

void *xsd__ServiceNameType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ServiceNameType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ServiceNameType * SOAP_FMAC4 soap_get_xsd__ServiceNameType(struct soap *soap, xsd__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__ServiceNameType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__ServiceNameType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ServiceNameType * SOAP_FMAC4 soap_in_xsd__ServiceNameType(struct soap *soap, const char *tag, xsd__ServiceNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__ServiceNameType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__ServiceNameType, sizeof(xsd__ServiceNameType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__ServiceNameType)
			return (xsd__ServiceNameType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &((xsd__ServiceNameType *)a)->PortName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__ServiceNameType *)a)->__anyAttribute))
		return NULL;
	if (!soap_in__QName(soap, tag, &(a->xsd__ServiceNameType::__item), "xsd:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__ServiceNameType * SOAP_FMAC6 soap_new_xsd__ServiceNameType(struct soap *soap, int n)
{	return soap_instantiate_xsd__ServiceNameType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ServiceNameType(struct soap *soap, xsd__ServiceNameType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__ServiceNameType * SOAP_FMAC4 soap_instantiate_xsd__ServiceNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ServiceNameType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__ServiceNameType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__ServiceNameType;
		if (size)
			*size = sizeof(xsd__ServiceNameType);
		((xsd__ServiceNameType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__ServiceNameType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__ServiceNameType);
		for (int i = 0; i < n; i++)
			((xsd__ServiceNameType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__ServiceNameType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ServiceNameType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__ServiceNameType %p -> %p\n", q, p));
	*(xsd__ServiceNameType*)p = *(xsd__ServiceNameType*)q;
}

void xsd__ReferencePropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__ReferencePropertiesType::__size = 0;
	this->xsd__ReferencePropertiesType::__any = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__ReferencePropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__ReferencePropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__ReferencePropertiesType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__ReferencePropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ReferencePropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const xsd__ReferencePropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__ReferencePropertiesType), "xsd:ReferencePropertiesType"))
		return soap->error;
	/* transient soap skipped */
	if (a->xsd__ReferencePropertiesType::__any)
	{	int i;
		for (i = 0; i < a->xsd__ReferencePropertiesType::__size; i++)
			soap_outliteral(soap, "-any", a->xsd__ReferencePropertiesType::__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

void *xsd__ReferencePropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ReferencePropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ReferencePropertiesType * SOAP_FMAC4 soap_get_xsd__ReferencePropertiesType(struct soap *soap, xsd__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__ReferencePropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__ReferencePropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ReferencePropertiesType * SOAP_FMAC4 soap_in_xsd__ReferencePropertiesType(struct soap *soap, const char *tag, xsd__ReferencePropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xsd__ReferencePropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__ReferencePropertiesType, sizeof(xsd__ReferencePropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__ReferencePropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__ReferencePropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->xsd__ReferencePropertiesType::__size = 0; !soap_peek_element(soap); a->xsd__ReferencePropertiesType::__size++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					if (!p)
						return NULL;
					*p = NULL;
					if (!soap_inliteral(soap, "-any", p))
						break;
					soap_flag___any1 = 0;
				}
				a->xsd__ReferencePropertiesType::__any = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__ReferencePropertiesType, 0, sizeof(xsd__ReferencePropertiesType), 0, soap_copy_xsd__ReferencePropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__ReferencePropertiesType * SOAP_FMAC6 soap_new_xsd__ReferencePropertiesType(struct soap *soap, int n)
{	return soap_instantiate_xsd__ReferencePropertiesType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ReferencePropertiesType(struct soap *soap, xsd__ReferencePropertiesType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__ReferencePropertiesType * SOAP_FMAC4 soap_instantiate_xsd__ReferencePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ReferencePropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__ReferencePropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__ReferencePropertiesType;
		if (size)
			*size = sizeof(xsd__ReferencePropertiesType);
		((xsd__ReferencePropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__ReferencePropertiesType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__ReferencePropertiesType);
		for (int i = 0; i < n; i++)
			((xsd__ReferencePropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__ReferencePropertiesType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ReferencePropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__ReferencePropertiesType %p -> %p\n", q, p));
	*(xsd__ReferencePropertiesType*)p = *(xsd__ReferencePropertiesType*)q;
}

void xsd__EndpointReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__EndpointReferenceType::Address = NULL;
	this->xsd__EndpointReferenceType::ReferenceProperties = NULL;
	this->xsd__EndpointReferenceType::PortType = NULL;
	this->xsd__EndpointReferenceType::ServiceName = NULL;
	this->xsd__EndpointReferenceType::__size = 0;
	this->xsd__EndpointReferenceType::__any = NULL;
	this->xsd__EndpointReferenceType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__AttributedURI(soap, &this->xsd__EndpointReferenceType::Address);
	soap_serialize_PointerToxsd__ReferencePropertiesType(soap, &this->xsd__EndpointReferenceType::ReferenceProperties);
	soap_serialize_PointerToxsd__AttributedQName(soap, &this->xsd__EndpointReferenceType::PortType);
	soap_serialize_PointerToxsd__ServiceNameType(soap, &this->xsd__EndpointReferenceType::ServiceName);
	/* transient soap skipped */
}

int xsd__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__EndpointReferenceType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__EndpointReferenceType(struct soap *soap, const char *tag, int id, const xsd__EndpointReferenceType *a, const char *type)
{
	if (((xsd__EndpointReferenceType *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((xsd__EndpointReferenceType *)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__EndpointReferenceType), "xsd:EndpointReferenceType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__AttributedURI(soap, "xsd:Address", -1, &(a->xsd__EndpointReferenceType::Address), ""))
		return soap->error;
	if (soap_out_PointerToxsd__ReferencePropertiesType(soap, "xsd:ReferenceProperties", -1, &(a->xsd__EndpointReferenceType::ReferenceProperties), ""))
		return soap->error;
	if (soap_out_PointerToxsd__AttributedQName(soap, "xsd:PortType", -1, &(a->xsd__EndpointReferenceType::PortType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__ServiceNameType(soap, "xsd:ServiceName", -1, &(a->xsd__EndpointReferenceType::ServiceName), ""))
		return soap->error;
	if (a->xsd__EndpointReferenceType::__any)
	{	int i;
		for (i = 0; i < a->xsd__EndpointReferenceType::__size; i++)
			soap_outliteral(soap, "-any", a->xsd__EndpointReferenceType::__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

void *xsd__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__EndpointReferenceType * SOAP_FMAC4 soap_get_xsd__EndpointReferenceType(struct soap *soap, xsd__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__EndpointReferenceType * SOAP_FMAC4 soap_in_xsd__EndpointReferenceType(struct soap *soap, const char *tag, xsd__EndpointReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xsd__EndpointReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__EndpointReferenceType, sizeof(xsd__EndpointReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__EndpointReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__EndpointReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((xsd__EndpointReferenceType *)a)->__anyAttribute))
		return NULL;
	short soap_flag___item2 = 1, soap_flag_Address1 = 1, soap_flag_ReferenceProperties1 = 1, soap_flag_PortType1 = 1, soap_flag_ServiceName1 = 1, soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__AttributedURI(soap, "xsd:Address", &(a->xsd__EndpointReferenceType::Address), "xsd:AttributedURI"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_ReferenceProperties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__ReferencePropertiesType(soap, "xsd:ReferenceProperties", &(a->xsd__EndpointReferenceType::ReferenceProperties), "xsd:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties1--;
					continue;
				}
			if (soap_flag_PortType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__AttributedQName(soap, "xsd:PortType", &(a->xsd__EndpointReferenceType::PortType), "xsd:AttributedQName"))
				{	soap_flag_PortType1--;
					continue;
				}
			if (soap_flag_ServiceName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__ServiceNameType(soap, "xsd:ServiceName", &(a->xsd__EndpointReferenceType::ServiceName), "xsd:ServiceNameType"))
				{	soap_flag_ServiceName1--;
					continue;
				}
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->xsd__EndpointReferenceType::__size = 0; !soap_peek_element(soap); a->xsd__EndpointReferenceType::__size++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					if (!p)
						return NULL;
					*p = NULL;
					if (!soap_inliteral(soap, "-any", p))
						break;
					soap_flag___any1 = 0;
				}
				a->xsd__EndpointReferenceType::__any = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__EndpointReferenceType, 0, sizeof(xsd__EndpointReferenceType), 0, soap_copy_xsd__EndpointReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__EndpointReferenceType * SOAP_FMAC6 soap_new_xsd__EndpointReferenceType(struct soap *soap, int n)
{	return soap_instantiate_xsd__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__EndpointReferenceType(struct soap *soap, xsd__EndpointReferenceType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__EndpointReferenceType * SOAP_FMAC4 soap_instantiate_xsd__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__EndpointReferenceType;
		if (size)
			*size = sizeof(xsd__EndpointReferenceType);
		((xsd__EndpointReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__EndpointReferenceType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__EndpointReferenceType);
		for (int i = 0; i < n; i++)
			((xsd__EndpointReferenceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__EndpointReferenceType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__EndpointReferenceType %p -> %p\n", q, p));
	*(xsd__EndpointReferenceType*)p = *(xsd__EndpointReferenceType*)q;
}

void _lifetime__TerminationNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_lifetime__TerminationNotification::TerminationTime);
	this->_lifetime__TerminationNotification::TerminationReason = NULL;
	/* transient soap skipped */
}

void _lifetime__TerminationNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_lifetime__TerminationNotification::TerminationTime, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__anyType(soap, &this->_lifetime__TerminationNotification::TerminationReason);
	/* transient soap skipped */
}

int _lifetime__TerminationNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__TerminationNotification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__TerminationNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__TerminationNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__TerminationNotification(struct soap *soap, const char *tag, int id, const _lifetime__TerminationNotification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__TerminationNotification), type))
		return soap->error;
	if (soap_out_time(soap, "lifetime:TerminationTime", -1, &(a->_lifetime__TerminationNotification::TerminationTime), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "lifetime:TerminationReason", -1, &(a->_lifetime__TerminationNotification::TerminationReason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__TerminationNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__TerminationNotification(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__TerminationNotification * SOAP_FMAC4 soap_get__lifetime__TerminationNotification(struct soap *soap, _lifetime__TerminationNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__TerminationNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__TerminationNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__TerminationNotification(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__TerminationNotification * SOAP_FMAC4 soap_in__lifetime__TerminationNotification(struct soap *soap, const char *tag, _lifetime__TerminationNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__TerminationNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__TerminationNotification, sizeof(_lifetime__TerminationNotification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__TerminationNotification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__TerminationNotification *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_TerminationTime1 = 1, soap_flag_TerminationReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "lifetime:TerminationTime", &(a->_lifetime__TerminationNotification::TerminationTime), "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			if (soap_flag_TerminationReason1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "lifetime:TerminationReason", &(a->_lifetime__TerminationNotification::TerminationReason), "xsd:anyType"))
				{	soap_flag_TerminationReason1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__TerminationNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__TerminationNotification, 0, sizeof(_lifetime__TerminationNotification), 0, soap_copy__lifetime__TerminationNotification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__TerminationNotification * SOAP_FMAC6 soap_new__lifetime__TerminationNotification(struct soap *soap, int n)
{	return soap_instantiate__lifetime__TerminationNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__TerminationNotification(struct soap *soap, _lifetime__TerminationNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__TerminationNotification * SOAP_FMAC4 soap_instantiate__lifetime__TerminationNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__TerminationNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__TerminationNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__TerminationNotification;
		if (size)
			*size = sizeof(_lifetime__TerminationNotification);
		((_lifetime__TerminationNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__TerminationNotification[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__TerminationNotification);
		for (int i = 0; i < n; i++)
			((_lifetime__TerminationNotification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__TerminationNotification*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__TerminationNotification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__TerminationNotification %p -> %p\n", q, p));
	*(_lifetime__TerminationNotification*)p = *(_lifetime__TerminationNotification*)q;
}

void _lifetime__SetTerminationTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_lifetime__SetTerminationTimeResponse::NewTerminationTime = NULL;
	soap_default_time(soap, &this->_lifetime__SetTerminationTimeResponse::CurrentTime);
	/* transient soap skipped */
}

void _lifetime__SetTerminationTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_lifetime__SetTerminationTimeResponse::NewTerminationTime);
	soap_embedded(soap, &this->_lifetime__SetTerminationTimeResponse::CurrentTime, SOAP_TYPE_time);
	/* transient soap skipped */
}

int _lifetime__SetTerminationTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__SetTerminationTimeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__SetTerminationTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__SetTerminationTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__SetTerminationTimeResponse(struct soap *soap, const char *tag, int id, const _lifetime__SetTerminationTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__SetTerminationTimeResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lifetime:NewTerminationTime", -1, &(a->_lifetime__SetTerminationTimeResponse::NewTerminationTime), ""))
		return soap->error;
	if (soap_out_time(soap, "lifetime:CurrentTime", -1, &(a->_lifetime__SetTerminationTimeResponse::CurrentTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__SetTerminationTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__SetTerminationTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__SetTerminationTimeResponse * SOAP_FMAC4 soap_get__lifetime__SetTerminationTimeResponse(struct soap *soap, _lifetime__SetTerminationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__SetTerminationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__SetTerminationTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__SetTerminationTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__SetTerminationTimeResponse * SOAP_FMAC4 soap_in__lifetime__SetTerminationTimeResponse(struct soap *soap, const char *tag, _lifetime__SetTerminationTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__SetTerminationTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__SetTerminationTimeResponse, sizeof(_lifetime__SetTerminationTimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__SetTerminationTimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__SetTerminationTimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_NewTerminationTime1 = 1, soap_flag_CurrentTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewTerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lifetime:NewTerminationTime", &(a->_lifetime__SetTerminationTimeResponse::NewTerminationTime), "xsd:dateTime"))
				{	soap_flag_NewTerminationTime1--;
					continue;
				}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "lifetime:CurrentTime", &(a->_lifetime__SetTerminationTimeResponse::CurrentTime), "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__SetTerminationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__SetTerminationTimeResponse, 0, sizeof(_lifetime__SetTerminationTimeResponse), 0, soap_copy__lifetime__SetTerminationTimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__SetTerminationTimeResponse * SOAP_FMAC6 soap_new__lifetime__SetTerminationTimeResponse(struct soap *soap, int n)
{	return soap_instantiate__lifetime__SetTerminationTimeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__SetTerminationTimeResponse(struct soap *soap, _lifetime__SetTerminationTimeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__SetTerminationTimeResponse * SOAP_FMAC4 soap_instantiate__lifetime__SetTerminationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__SetTerminationTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__SetTerminationTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__SetTerminationTimeResponse;
		if (size)
			*size = sizeof(_lifetime__SetTerminationTimeResponse);
		((_lifetime__SetTerminationTimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__SetTerminationTimeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__SetTerminationTimeResponse);
		for (int i = 0; i < n; i++)
			((_lifetime__SetTerminationTimeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__SetTerminationTimeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__SetTerminationTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__SetTerminationTimeResponse %p -> %p\n", q, p));
	*(_lifetime__SetTerminationTimeResponse*)p = *(_lifetime__SetTerminationTimeResponse*)q;
}

void _lifetime__SetTerminationTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_lifetime__SetTerminationTime::RequestedTerminationTime = NULL;
	/* transient soap skipped */
}

void _lifetime__SetTerminationTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_lifetime__SetTerminationTime::RequestedTerminationTime);
	/* transient soap skipped */
}

int _lifetime__SetTerminationTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__SetTerminationTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__SetTerminationTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__SetTerminationTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__SetTerminationTime(struct soap *soap, const char *tag, int id, const _lifetime__SetTerminationTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__SetTerminationTime), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lifetime:RequestedTerminationTime", -1, &(a->_lifetime__SetTerminationTime::RequestedTerminationTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__SetTerminationTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__SetTerminationTime(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__SetTerminationTime * SOAP_FMAC4 soap_get__lifetime__SetTerminationTime(struct soap *soap, _lifetime__SetTerminationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__SetTerminationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__SetTerminationTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__SetTerminationTime(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__SetTerminationTime * SOAP_FMAC4 soap_in__lifetime__SetTerminationTime(struct soap *soap, const char *tag, _lifetime__SetTerminationTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__SetTerminationTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__SetTerminationTime, sizeof(_lifetime__SetTerminationTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__SetTerminationTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__SetTerminationTime *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_RequestedTerminationTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestedTerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lifetime:RequestedTerminationTime", &(a->_lifetime__SetTerminationTime::RequestedTerminationTime), "xsd:dateTime"))
				{	soap_flag_RequestedTerminationTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__SetTerminationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__SetTerminationTime, 0, sizeof(_lifetime__SetTerminationTime), 0, soap_copy__lifetime__SetTerminationTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__SetTerminationTime * SOAP_FMAC6 soap_new__lifetime__SetTerminationTime(struct soap *soap, int n)
{	return soap_instantiate__lifetime__SetTerminationTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__SetTerminationTime(struct soap *soap, _lifetime__SetTerminationTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__SetTerminationTime * SOAP_FMAC4 soap_instantiate__lifetime__SetTerminationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__SetTerminationTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__SetTerminationTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__SetTerminationTime;
		if (size)
			*size = sizeof(_lifetime__SetTerminationTime);
		((_lifetime__SetTerminationTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__SetTerminationTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__SetTerminationTime);
		for (int i = 0; i < n; i++)
			((_lifetime__SetTerminationTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__SetTerminationTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__SetTerminationTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__SetTerminationTime %p -> %p\n", q, p));
	*(_lifetime__SetTerminationTime*)p = *(_lifetime__SetTerminationTime*)q;
}

void _lifetime__DestroyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _lifetime__DestroyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _lifetime__DestroyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__DestroyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__DestroyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__DestroyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__DestroyResponse(struct soap *soap, const char *tag, int id, const _lifetime__DestroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__DestroyResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__DestroyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__DestroyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__DestroyResponse * SOAP_FMAC4 soap_get__lifetime__DestroyResponse(struct soap *soap, _lifetime__DestroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__DestroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__DestroyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__DestroyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__DestroyResponse * SOAP_FMAC4 soap_in__lifetime__DestroyResponse(struct soap *soap, const char *tag, _lifetime__DestroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__DestroyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__DestroyResponse, sizeof(_lifetime__DestroyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__DestroyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__DestroyResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__DestroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__DestroyResponse, 0, sizeof(_lifetime__DestroyResponse), 0, soap_copy__lifetime__DestroyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__DestroyResponse * SOAP_FMAC6 soap_new__lifetime__DestroyResponse(struct soap *soap, int n)
{	return soap_instantiate__lifetime__DestroyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__DestroyResponse(struct soap *soap, _lifetime__DestroyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__DestroyResponse * SOAP_FMAC4 soap_instantiate__lifetime__DestroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__DestroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__DestroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__DestroyResponse;
		if (size)
			*size = sizeof(_lifetime__DestroyResponse);
		((_lifetime__DestroyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__DestroyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__DestroyResponse);
		for (int i = 0; i < n; i++)
			((_lifetime__DestroyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__DestroyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__DestroyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__DestroyResponse %p -> %p\n", q, p));
	*(_lifetime__DestroyResponse*)p = *(_lifetime__DestroyResponse*)q;
}

void _lifetime__Destroy::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _lifetime__Destroy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _lifetime__Destroy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__Destroy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__Destroy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__Destroy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__Destroy(struct soap *soap, const char *tag, int id, const _lifetime__Destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__Destroy), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__Destroy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__Destroy(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__Destroy * SOAP_FMAC4 soap_get__lifetime__Destroy(struct soap *soap, _lifetime__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__Destroy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__Destroy(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__Destroy * SOAP_FMAC4 soap_in__lifetime__Destroy(struct soap *soap, const char *tag, _lifetime__Destroy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__Destroy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__Destroy, sizeof(_lifetime__Destroy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__Destroy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__Destroy *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__Destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__Destroy, 0, sizeof(_lifetime__Destroy), 0, soap_copy__lifetime__Destroy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__Destroy * SOAP_FMAC6 soap_new__lifetime__Destroy(struct soap *soap, int n)
{	return soap_instantiate__lifetime__Destroy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__Destroy(struct soap *soap, _lifetime__Destroy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__Destroy * SOAP_FMAC4 soap_instantiate__lifetime__Destroy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__Destroy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__Destroy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__Destroy;
		if (size)
			*size = sizeof(_lifetime__Destroy);
		((_lifetime__Destroy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__Destroy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__Destroy);
		for (int i = 0; i < n; i++)
			((_lifetime__Destroy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__Destroy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__Destroy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__Destroy %p -> %p\n", q, p));
	*(_lifetime__Destroy*)p = *(_lifetime__Destroy*)q;
}

void _lifetime__ScheduledResourceTerminationRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_lifetime__ScheduledResourceTerminationRP::lifetime__CurrentTime);
	soap_default_time(soap, &this->_lifetime__ScheduledResourceTerminationRP::lifetime__TerminationTime);
	/* transient soap skipped */
}

void _lifetime__ScheduledResourceTerminationRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_lifetime__ScheduledResourceTerminationRP::lifetime__CurrentTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->_lifetime__ScheduledResourceTerminationRP::lifetime__TerminationTime, SOAP_TYPE_time);
	/* transient soap skipped */
}

int _lifetime__ScheduledResourceTerminationRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__lifetime__ScheduledResourceTerminationRP);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _lifetime__ScheduledResourceTerminationRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__lifetime__ScheduledResourceTerminationRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__lifetime__ScheduledResourceTerminationRP(struct soap *soap, const char *tag, int id, const _lifetime__ScheduledResourceTerminationRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__lifetime__ScheduledResourceTerminationRP), type))
		return soap->error;
	if (soap_out_time(soap, "lifetime:CurrentTime", -1, &(a->_lifetime__ScheduledResourceTerminationRP::lifetime__CurrentTime), ""))
		return soap->error;
	if (soap_out_time(soap, "lifetime:TerminationTime", -1, &(a->_lifetime__ScheduledResourceTerminationRP::lifetime__TerminationTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_lifetime__ScheduledResourceTerminationRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__lifetime__ScheduledResourceTerminationRP(soap, this, tag, type);
}

SOAP_FMAC3 _lifetime__ScheduledResourceTerminationRP * SOAP_FMAC4 soap_get__lifetime__ScheduledResourceTerminationRP(struct soap *soap, _lifetime__ScheduledResourceTerminationRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__lifetime__ScheduledResourceTerminationRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_lifetime__ScheduledResourceTerminationRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__lifetime__ScheduledResourceTerminationRP(soap, tag, this, type);
}

SOAP_FMAC3 _lifetime__ScheduledResourceTerminationRP * SOAP_FMAC4 soap_in__lifetime__ScheduledResourceTerminationRP(struct soap *soap, const char *tag, _lifetime__ScheduledResourceTerminationRP *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_lifetime__ScheduledResourceTerminationRP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__lifetime__ScheduledResourceTerminationRP, sizeof(_lifetime__ScheduledResourceTerminationRP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__lifetime__ScheduledResourceTerminationRP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_lifetime__ScheduledResourceTerminationRP *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_lifetime__CurrentTime1 = 1, soap_flag_lifetime__TerminationTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime__CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "lifetime:CurrentTime", &(a->_lifetime__ScheduledResourceTerminationRP::lifetime__CurrentTime), "xsd:dateTime"))
				{	soap_flag_lifetime__CurrentTime1--;
					continue;
				}
			if (soap_flag_lifetime__TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "lifetime:TerminationTime", &(a->_lifetime__ScheduledResourceTerminationRP::lifetime__TerminationTime), "xsd:dateTime"))
				{	soap_flag_lifetime__TerminationTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_lifetime__ScheduledResourceTerminationRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__lifetime__ScheduledResourceTerminationRP, 0, sizeof(_lifetime__ScheduledResourceTerminationRP), 0, soap_copy__lifetime__ScheduledResourceTerminationRP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lifetime__CurrentTime1 > 0 || soap_flag_lifetime__TerminationTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _lifetime__ScheduledResourceTerminationRP * SOAP_FMAC6 soap_new__lifetime__ScheduledResourceTerminationRP(struct soap *soap, int n)
{	return soap_instantiate__lifetime__ScheduledResourceTerminationRP(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__lifetime__ScheduledResourceTerminationRP(struct soap *soap, _lifetime__ScheduledResourceTerminationRP *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _lifetime__ScheduledResourceTerminationRP * SOAP_FMAC4 soap_instantiate__lifetime__ScheduledResourceTerminationRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__lifetime__ScheduledResourceTerminationRP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__lifetime__ScheduledResourceTerminationRP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _lifetime__ScheduledResourceTerminationRP;
		if (size)
			*size = sizeof(_lifetime__ScheduledResourceTerminationRP);
		((_lifetime__ScheduledResourceTerminationRP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _lifetime__ScheduledResourceTerminationRP[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_lifetime__ScheduledResourceTerminationRP);
		for (int i = 0; i < n; i++)
			((_lifetime__ScheduledResourceTerminationRP*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_lifetime__ScheduledResourceTerminationRP*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__lifetime__ScheduledResourceTerminationRP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _lifetime__ScheduledResourceTerminationRP %p -> %p\n", q, p));
	*(_lifetime__ScheduledResourceTerminationRP*)p = *(_lifetime__ScheduledResourceTerminationRP*)q;
}

void lifetime__TerminationTimeChangeRejectedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->basefaults__BaseFaultType::Timestamp);
	this->basefaults__BaseFaultType::Originator = NULL;
	this->basefaults__BaseFaultType::ErrorCode = NULL;
	this->basefaults__BaseFaultType::__sizeDescription = 0;
	this->basefaults__BaseFaultType::Description = NULL;
	this->basefaults__BaseFaultType::__sizeFaultCause = 0;
	this->basefaults__BaseFaultType::FaultCause = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void lifetime__TerminationTimeChangeRejectedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->basefaults__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__EndpointReferenceType(soap, &this->basefaults__BaseFaultType::Originator);
	soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, &this->basefaults__BaseFaultType::ErrorCode);
	if (this->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->basefaults__BaseFaultType::Description + i, SOAP_TYPE__basefaults__BaseFaultType_Description);
			this->basefaults__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	if (this->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeFaultCause; i++)
		{
			soap_serialize_PointerTobasefaults__BaseFaultType(soap, this->basefaults__BaseFaultType::FaultCause + i);
		}
	}
	/* transient soap skipped */
}

int lifetime__TerminationTimeChangeRejectedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int lifetime__TerminationTimeChangeRejectedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lifetime__TerminationTimeChangeRejectedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, const char *tag, int id, const lifetime__TerminationTimeChangeRejectedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType), "lifetime:TerminationTimeChangeRejectedFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "basefaults:Timestamp", -1, &(a->basefaults__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", -1, &(a->basefaults__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", -1, &(a->basefaults__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeDescription; i++)
			if (a->basefaults__BaseFaultType::Description[i].soap_out(soap, "basefaults:Description", -1, ""))
				return soap->error;
	}
	if (a->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeFaultCause; i++)
			if (soap_out_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", -1, a->basefaults__BaseFaultType::FaultCause + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *lifetime__TerminationTimeChangeRejectedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lifetime__TerminationTimeChangeRejectedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 lifetime__TerminationTimeChangeRejectedFaultType * SOAP_FMAC4 soap_get_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, lifetime__TerminationTimeChangeRejectedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lifetime__TerminationTimeChangeRejectedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *lifetime__TerminationTimeChangeRejectedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_lifetime__TerminationTimeChangeRejectedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 lifetime__TerminationTimeChangeRejectedFaultType * SOAP_FMAC4 soap_in_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, const char *tag, lifetime__TerminationTimeChangeRejectedFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lifetime__TerminationTimeChangeRejectedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType, sizeof(lifetime__TerminationTimeChangeRejectedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (lifetime__TerminationTimeChangeRejectedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item3 = 1, soap_flag_Timestamp2 = 1, soap_flag_Originator2 = 1, soap_flag_ErrorCode2 = 1, soap_flag_Description2 = 1, soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "basefaults:Timestamp", &(a->basefaults__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", &(a->basefaults__BaseFaultType::Originator), "xsd:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", &(a->basefaults__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
			{	_basefaults__BaseFaultType_Description *p;
				_basefaults__BaseFaultType_Description q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeDescription = 0; !soap_element_begin_in(soap, "basefaults:Description", 1, NULL); a->basefaults__BaseFaultType::__sizeDescription++)
				{	p = (_basefaults__BaseFaultType_Description *)soap_push_block(soap, sizeof(_basefaults__BaseFaultType_Description));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(_basefaults__BaseFaultType_Description));
					p->soap_default(soap);
					soap_revert(soap);
					if (!soap_in__basefaults__BaseFaultType_Description(soap, "basefaults:Description", p, ""))
						break;
					soap_flag_Description2 = 0;
				}
				a->basefaults__BaseFaultType::Description = (_basefaults__BaseFaultType_Description *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	basefaults__BaseFaultType **p;
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeFaultCause = 0; !soap_element_begin_in(soap, "basefaults:FaultCause", 1, NULL); a->basefaults__BaseFaultType::__sizeFaultCause++)
				{	p = (basefaults__BaseFaultType **)soap_push_block(soap, sizeof(basefaults__BaseFaultType *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", p, "basefaults:BaseFaultType"))
						break;
					soap_flag_FaultCause2 = 0;
				}
				a->basefaults__BaseFaultType::FaultCause = (basefaults__BaseFaultType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lifetime__TerminationTimeChangeRejectedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType, 0, sizeof(lifetime__TerminationTimeChangeRejectedFaultType), 0, soap_copy_lifetime__TerminationTimeChangeRejectedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 lifetime__TerminationTimeChangeRejectedFaultType * SOAP_FMAC6 soap_new_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, int n)
{	return soap_instantiate_lifetime__TerminationTimeChangeRejectedFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, lifetime__TerminationTimeChangeRejectedFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 lifetime__TerminationTimeChangeRejectedFaultType * SOAP_FMAC4 soap_instantiate_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lifetime__TerminationTimeChangeRejectedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType;
		if (size)
			*size = sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
		((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
		for (int i = 0; i < n; i++)
			((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_lifetime__TerminationTimeChangeRejectedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying lifetime__TerminationTimeChangeRejectedFaultType %p -> %p\n", q, p));
	*(lifetime__TerminationTimeChangeRejectedFaultType*)p = *(lifetime__TerminationTimeChangeRejectedFaultType*)q;
}

void lifetime__UnableToSetTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->basefaults__BaseFaultType::Timestamp);
	this->basefaults__BaseFaultType::Originator = NULL;
	this->basefaults__BaseFaultType::ErrorCode = NULL;
	this->basefaults__BaseFaultType::__sizeDescription = 0;
	this->basefaults__BaseFaultType::Description = NULL;
	this->basefaults__BaseFaultType::__sizeFaultCause = 0;
	this->basefaults__BaseFaultType::FaultCause = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void lifetime__UnableToSetTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->basefaults__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__EndpointReferenceType(soap, &this->basefaults__BaseFaultType::Originator);
	soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, &this->basefaults__BaseFaultType::ErrorCode);
	if (this->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->basefaults__BaseFaultType::Description + i, SOAP_TYPE__basefaults__BaseFaultType_Description);
			this->basefaults__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	if (this->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeFaultCause; i++)
		{
			soap_serialize_PointerTobasefaults__BaseFaultType(soap, this->basefaults__BaseFaultType::FaultCause + i);
		}
	}
	/* transient soap skipped */
}

int lifetime__UnableToSetTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int lifetime__UnableToSetTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lifetime__UnableToSetTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const lifetime__UnableToSetTerminationTimeFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType), "lifetime:UnableToSetTerminationTimeFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "basefaults:Timestamp", -1, &(a->basefaults__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", -1, &(a->basefaults__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", -1, &(a->basefaults__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeDescription; i++)
			if (a->basefaults__BaseFaultType::Description[i].soap_out(soap, "basefaults:Description", -1, ""))
				return soap->error;
	}
	if (a->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeFaultCause; i++)
			if (soap_out_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", -1, a->basefaults__BaseFaultType::FaultCause + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *lifetime__UnableToSetTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lifetime__UnableToSetTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 lifetime__UnableToSetTerminationTimeFaultType * SOAP_FMAC4 soap_get_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, lifetime__UnableToSetTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lifetime__UnableToSetTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *lifetime__UnableToSetTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_lifetime__UnableToSetTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 lifetime__UnableToSetTerminationTimeFaultType * SOAP_FMAC4 soap_in_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, const char *tag, lifetime__UnableToSetTerminationTimeFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lifetime__UnableToSetTerminationTimeFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType, sizeof(lifetime__UnableToSetTerminationTimeFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (lifetime__UnableToSetTerminationTimeFaultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item3 = 1, soap_flag_Timestamp2 = 1, soap_flag_Originator2 = 1, soap_flag_ErrorCode2 = 1, soap_flag_Description2 = 1, soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "basefaults:Timestamp", &(a->basefaults__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", &(a->basefaults__BaseFaultType::Originator), "xsd:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", &(a->basefaults__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
			{	_basefaults__BaseFaultType_Description *p;
				_basefaults__BaseFaultType_Description q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeDescription = 0; !soap_element_begin_in(soap, "basefaults:Description", 1, NULL); a->basefaults__BaseFaultType::__sizeDescription++)
				{	p = (_basefaults__BaseFaultType_Description *)soap_push_block(soap, sizeof(_basefaults__BaseFaultType_Description));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(_basefaults__BaseFaultType_Description));
					p->soap_default(soap);
					soap_revert(soap);
					if (!soap_in__basefaults__BaseFaultType_Description(soap, "basefaults:Description", p, ""))
						break;
					soap_flag_Description2 = 0;
				}
				a->basefaults__BaseFaultType::Description = (_basefaults__BaseFaultType_Description *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	basefaults__BaseFaultType **p;
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeFaultCause = 0; !soap_element_begin_in(soap, "basefaults:FaultCause", 1, NULL); a->basefaults__BaseFaultType::__sizeFaultCause++)
				{	p = (basefaults__BaseFaultType **)soap_push_block(soap, sizeof(basefaults__BaseFaultType *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", p, "basefaults:BaseFaultType"))
						break;
					soap_flag_FaultCause2 = 0;
				}
				a->basefaults__BaseFaultType::FaultCause = (basefaults__BaseFaultType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lifetime__UnableToSetTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType, 0, sizeof(lifetime__UnableToSetTerminationTimeFaultType), 0, soap_copy_lifetime__UnableToSetTerminationTimeFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 lifetime__UnableToSetTerminationTimeFaultType * SOAP_FMAC6 soap_new_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, int n)
{	return soap_instantiate_lifetime__UnableToSetTerminationTimeFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, lifetime__UnableToSetTerminationTimeFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 lifetime__UnableToSetTerminationTimeFaultType * SOAP_FMAC4 soap_instantiate_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lifetime__UnableToSetTerminationTimeFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType;
		if (size)
			*size = sizeof(lifetime__UnableToSetTerminationTimeFaultType);
		((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(lifetime__UnableToSetTerminationTimeFaultType);
		for (int i = 0; i < n; i++)
			((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_lifetime__UnableToSetTerminationTimeFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying lifetime__UnableToSetTerminationTimeFaultType %p -> %p\n", q, p));
	*(lifetime__UnableToSetTerminationTimeFaultType*)p = *(lifetime__UnableToSetTerminationTimeFaultType*)q;
}

void lifetime__ResourceNotDestroyedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->basefaults__BaseFaultType::Timestamp);
	this->basefaults__BaseFaultType::Originator = NULL;
	this->basefaults__BaseFaultType::ErrorCode = NULL;
	this->basefaults__BaseFaultType::__sizeDescription = 0;
	this->basefaults__BaseFaultType::Description = NULL;
	this->basefaults__BaseFaultType::__sizeFaultCause = 0;
	this->basefaults__BaseFaultType::FaultCause = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void lifetime__ResourceNotDestroyedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->basefaults__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__EndpointReferenceType(soap, &this->basefaults__BaseFaultType::Originator);
	soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, &this->basefaults__BaseFaultType::ErrorCode);
	if (this->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->basefaults__BaseFaultType::Description + i, SOAP_TYPE__basefaults__BaseFaultType_Description);
			this->basefaults__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	if (this->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeFaultCause; i++)
		{
			soap_serialize_PointerTobasefaults__BaseFaultType(soap, this->basefaults__BaseFaultType::FaultCause + i);
		}
	}
	/* transient soap skipped */
}

int lifetime__ResourceNotDestroyedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int lifetime__ResourceNotDestroyedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lifetime__ResourceNotDestroyedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, const char *tag, int id, const lifetime__ResourceNotDestroyedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType), "lifetime:ResourceNotDestroyedFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "basefaults:Timestamp", -1, &(a->basefaults__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", -1, &(a->basefaults__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", -1, &(a->basefaults__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeDescription; i++)
			if (a->basefaults__BaseFaultType::Description[i].soap_out(soap, "basefaults:Description", -1, ""))
				return soap->error;
	}
	if (a->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeFaultCause; i++)
			if (soap_out_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", -1, a->basefaults__BaseFaultType::FaultCause + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *lifetime__ResourceNotDestroyedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lifetime__ResourceNotDestroyedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 lifetime__ResourceNotDestroyedFaultType * SOAP_FMAC4 soap_get_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, lifetime__ResourceNotDestroyedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lifetime__ResourceNotDestroyedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *lifetime__ResourceNotDestroyedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_lifetime__ResourceNotDestroyedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 lifetime__ResourceNotDestroyedFaultType * SOAP_FMAC4 soap_in_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, const char *tag, lifetime__ResourceNotDestroyedFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lifetime__ResourceNotDestroyedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType, sizeof(lifetime__ResourceNotDestroyedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (lifetime__ResourceNotDestroyedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item3 = 1, soap_flag_Timestamp2 = 1, soap_flag_Originator2 = 1, soap_flag_ErrorCode2 = 1, soap_flag_Description2 = 1, soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "basefaults:Timestamp", &(a->basefaults__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", &(a->basefaults__BaseFaultType::Originator), "xsd:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", &(a->basefaults__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
			{	_basefaults__BaseFaultType_Description *p;
				_basefaults__BaseFaultType_Description q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeDescription = 0; !soap_element_begin_in(soap, "basefaults:Description", 1, NULL); a->basefaults__BaseFaultType::__sizeDescription++)
				{	p = (_basefaults__BaseFaultType_Description *)soap_push_block(soap, sizeof(_basefaults__BaseFaultType_Description));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(_basefaults__BaseFaultType_Description));
					p->soap_default(soap);
					soap_revert(soap);
					if (!soap_in__basefaults__BaseFaultType_Description(soap, "basefaults:Description", p, ""))
						break;
					soap_flag_Description2 = 0;
				}
				a->basefaults__BaseFaultType::Description = (_basefaults__BaseFaultType_Description *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	basefaults__BaseFaultType **p;
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeFaultCause = 0; !soap_element_begin_in(soap, "basefaults:FaultCause", 1, NULL); a->basefaults__BaseFaultType::__sizeFaultCause++)
				{	p = (basefaults__BaseFaultType **)soap_push_block(soap, sizeof(basefaults__BaseFaultType *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", p, "basefaults:BaseFaultType"))
						break;
					soap_flag_FaultCause2 = 0;
				}
				a->basefaults__BaseFaultType::FaultCause = (basefaults__BaseFaultType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lifetime__ResourceNotDestroyedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType, 0, sizeof(lifetime__ResourceNotDestroyedFaultType), 0, soap_copy_lifetime__ResourceNotDestroyedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 lifetime__ResourceNotDestroyedFaultType * SOAP_FMAC6 soap_new_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, int n)
{	return soap_instantiate_lifetime__ResourceNotDestroyedFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, lifetime__ResourceNotDestroyedFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 lifetime__ResourceNotDestroyedFaultType * SOAP_FMAC4 soap_instantiate_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lifetime__ResourceNotDestroyedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType;
		if (size)
			*size = sizeof(lifetime__ResourceNotDestroyedFaultType);
		((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(lifetime__ResourceNotDestroyedFaultType);
		for (int i = 0; i < n; i++)
			((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (lifetime__ResourceNotDestroyedFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_lifetime__ResourceNotDestroyedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying lifetime__ResourceNotDestroyedFaultType %p -> %p\n", q, p));
	*(lifetime__ResourceNotDestroyedFaultType*)p = *(lifetime__ResourceNotDestroyedFaultType*)q;
}

void lifetime__ResourceUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->basefaults__BaseFaultType::Timestamp);
	this->basefaults__BaseFaultType::Originator = NULL;
	this->basefaults__BaseFaultType::ErrorCode = NULL;
	this->basefaults__BaseFaultType::__sizeDescription = 0;
	this->basefaults__BaseFaultType::Description = NULL;
	this->basefaults__BaseFaultType::__sizeFaultCause = 0;
	this->basefaults__BaseFaultType::FaultCause = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void lifetime__ResourceUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->basefaults__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__EndpointReferenceType(soap, &this->basefaults__BaseFaultType::Originator);
	soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, &this->basefaults__BaseFaultType::ErrorCode);
	if (this->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->basefaults__BaseFaultType::Description + i, SOAP_TYPE__basefaults__BaseFaultType_Description);
			this->basefaults__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	if (this->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < this->basefaults__BaseFaultType::__sizeFaultCause; i++)
		{
			soap_serialize_PointerTobasefaults__BaseFaultType(soap, this->basefaults__BaseFaultType::FaultCause + i);
		}
	}
	/* transient soap skipped */
}

int lifetime__ResourceUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_lifetime__ResourceUnknownFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int lifetime__ResourceUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lifetime__ResourceUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lifetime__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const lifetime__ResourceUnknownFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lifetime__ResourceUnknownFaultType), "lifetime:ResourceUnknownFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "basefaults:Timestamp", -1, &(a->basefaults__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", -1, &(a->basefaults__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", -1, &(a->basefaults__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->basefaults__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeDescription; i++)
			if (a->basefaults__BaseFaultType::Description[i].soap_out(soap, "basefaults:Description", -1, ""))
				return soap->error;
	}
	if (a->basefaults__BaseFaultType::FaultCause)
	{	int i;
		for (i = 0; i < a->basefaults__BaseFaultType::__sizeFaultCause; i++)
			if (soap_out_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", -1, a->basefaults__BaseFaultType::FaultCause + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *lifetime__ResourceUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lifetime__ResourceUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 lifetime__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_lifetime__ResourceUnknownFaultType(struct soap *soap, lifetime__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lifetime__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *lifetime__ResourceUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_lifetime__ResourceUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 lifetime__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_lifetime__ResourceUnknownFaultType(struct soap *soap, const char *tag, lifetime__ResourceUnknownFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lifetime__ResourceUnknownFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_lifetime__ResourceUnknownFaultType, sizeof(lifetime__ResourceUnknownFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_lifetime__ResourceUnknownFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (lifetime__ResourceUnknownFaultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item3 = 1, soap_flag_Timestamp2 = 1, soap_flag_Originator2 = 1, soap_flag_ErrorCode2 = 1, soap_flag_Description2 = 1, soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "basefaults:Timestamp", &(a->basefaults__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__EndpointReferenceType(soap, "basefaults:Originator", &(a->basefaults__BaseFaultType::Originator), "xsd:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, "basefaults:ErrorCode", &(a->basefaults__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
			{	_basefaults__BaseFaultType_Description *p;
				_basefaults__BaseFaultType_Description q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeDescription = 0; !soap_element_begin_in(soap, "basefaults:Description", 1, NULL); a->basefaults__BaseFaultType::__sizeDescription++)
				{	p = (_basefaults__BaseFaultType_Description *)soap_push_block(soap, sizeof(_basefaults__BaseFaultType_Description));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(_basefaults__BaseFaultType_Description));
					p->soap_default(soap);
					soap_revert(soap);
					if (!soap_in__basefaults__BaseFaultType_Description(soap, "basefaults:Description", p, ""))
						break;
					soap_flag_Description2 = 0;
				}
				a->basefaults__BaseFaultType::Description = (_basefaults__BaseFaultType_Description *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Description2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	basefaults__BaseFaultType **p;
				soap_new_block(soap);
				for (a->basefaults__BaseFaultType::__sizeFaultCause = 0; !soap_element_begin_in(soap, "basefaults:FaultCause", 1, NULL); a->basefaults__BaseFaultType::__sizeFaultCause++)
				{	p = (basefaults__BaseFaultType **)soap_push_block(soap, sizeof(basefaults__BaseFaultType *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTobasefaults__BaseFaultType(soap, "basefaults:FaultCause", p, "basefaults:BaseFaultType"))
						break;
					soap_flag_FaultCause2 = 0;
				}
				a->basefaults__BaseFaultType::FaultCause = (basefaults__BaseFaultType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lifetime__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lifetime__ResourceUnknownFaultType, 0, sizeof(lifetime__ResourceUnknownFaultType), 0, soap_copy_lifetime__ResourceUnknownFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 lifetime__ResourceUnknownFaultType * SOAP_FMAC6 soap_new_lifetime__ResourceUnknownFaultType(struct soap *soap, int n)
{	return soap_instantiate_lifetime__ResourceUnknownFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_lifetime__ResourceUnknownFaultType(struct soap *soap, lifetime__ResourceUnknownFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 lifetime__ResourceUnknownFaultType * SOAP_FMAC4 soap_instantiate_lifetime__ResourceUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lifetime__ResourceUnknownFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_lifetime__ResourceUnknownFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType;
		if (size)
			*size = sizeof(lifetime__ResourceUnknownFaultType);
		((lifetime__ResourceUnknownFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(lifetime__ResourceUnknownFaultType);
		for (int i = 0; i < n; i++)
			((lifetime__ResourceUnknownFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (lifetime__ResourceUnknownFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_lifetime__ResourceUnknownFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying lifetime__ResourceUnknownFaultType %p -> %p\n", q, p));
	*(lifetime__ResourceUnknownFaultType*)p = *(lifetime__ResourceUnknownFaultType*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string * SOAP_FMAC6 soap_new_xsd__string(struct soap *soap, int n)
{	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(struct soap *soap, xsd__string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__nonNegativeInteger_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__nonNegativeInteger_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger_::__item);
	/* transient soap skipped */
}

int xsd__nonNegativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__nonNegativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger_ *a, const char *type)
{
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &(a->xsd__nonNegativeInteger_::__item), "xsd:nonNegativeInteger");
}

void *xsd__nonNegativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__nonNegativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonNegativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, xsd__nonNegativeInteger_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger_, sizeof(xsd__nonNegativeInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__nonNegativeInteger_)
			return (xsd__nonNegativeInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->xsd__nonNegativeInteger_::__item), "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__nonNegativeInteger_ * SOAP_FMAC6 soap_new_xsd__nonNegativeInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonNegativeInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_instantiate_xsd__nonNegativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonNegativeInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
		if (size)
			*size = sizeof(xsd__nonNegativeInteger_);
		((xsd__nonNegativeInteger_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__nonNegativeInteger_);
		for (int i = 0; i < n; i++)
			((xsd__nonNegativeInteger_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__nonNegativeInteger_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__nonNegativeInteger_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__nonNegativeInteger_ %p -> %p\n", q, p));
	*(xsd__nonNegativeInteger_*)p = *(xsd__nonNegativeInteger_*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->xsd__dateTime::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime * SOAP_FMAC6 soap_new_xsd__dateTime(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(struct soap *soap, xsd__dateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean * SOAP_FMAC6 soap_new_xsd__boolean(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(struct soap *soap, xsd__boolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	/* transient soap skipped */
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyURI_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__anyURI_::__item), "xsd:anyURI");
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__anyURI_::__item), "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_new_xsd__anyURI_(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyURI_;
		if (size)
			*size = sizeof(xsd__anyURI_);
		((xsd__anyURI_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyURI_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyURI_);
		for (int i = 0; i < n; i++)
			((xsd__anyURI_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyURI_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

void xsd__QName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__QName(soap, &this->xsd__QName::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__QName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &this->xsd__QName::__item);
	/* transient soap skipped */
}

int xsd__QName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__QName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "xsd:QName");
}

void *xsd__QName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__QName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, xsd__QName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName, sizeof(xsd__QName), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__QName)
			return (xsd__QName *)a->soap_in(soap, tag, type);
	}
	if (!soap_in__QName(soap, tag, &(a->xsd__QName::__item), "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__QName * SOAP_FMAC6 soap_new_xsd__QName(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(struct soap *soap, xsd__QName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__QName;
		if (size)
			*size = sizeof(xsd__QName);
		((xsd__QName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__QName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName);
		for (int i = 0; i < n; i++)
			((xsd__QName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName %p -> %p\n", q, p));
	*(xsd__QName*)p = *(xsd__QName*)q;
}

void xsd__NCName_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->xsd__NCName_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__NCName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__NCName(soap, &this->xsd__NCName_::__item);
	/* transient soap skipped */
}

int xsd__NCName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__NCName_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__NCName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__NCName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName_(struct soap *soap, const char *tag, int id, const xsd__NCName_ *a, const char *type)
{
	return soap_out_xsd__NCName(soap, tag, id, &(a->xsd__NCName_::__item), "xsd:NCName");
}

void *xsd__NCName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__NCName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_get_xsd__NCName_(struct soap *soap, xsd__NCName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__NCName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__NCName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_in_xsd__NCName_(struct soap *soap, const char *tag, xsd__NCName_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__NCName_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__NCName_, sizeof(xsd__NCName_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__NCName_)
			return (xsd__NCName_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__NCName(soap, tag, &(a->xsd__NCName_::__item), "xsd:NCName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__NCName_ * SOAP_FMAC6 soap_new_xsd__NCName_(struct soap *soap, int n)
{	return soap_instantiate_xsd__NCName_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NCName_(struct soap *soap, xsd__NCName_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_instantiate_xsd__NCName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__NCName_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__NCName_;
		if (size)
			*size = sizeof(xsd__NCName_);
		((xsd__NCName_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__NCName_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__NCName_);
		for (int i = 0; i < n; i++)
			((xsd__NCName_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__NCName_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NCName_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__NCName_ %p -> %p\n", q, p));
	*(xsd__NCName_*)p = *(xsd__NCName_*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:NCName"))
	{	cp->type = SOAP_TYPE_xsd__NCName_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__NCName_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__NCName_);
			((xsd__NCName_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__NCName_[n];
			if (size)
				*size = n * sizeof(xsd__NCName_);
			for (int i = 0; i < n; i++)
				((xsd__NCName_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__NCName_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:QName"))
	{	cp->type = SOAP_TYPE_xsd__QName;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__QName;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__QName);
			((xsd__QName*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__QName[n];
			if (size)
				*size = n * sizeof(xsd__QName);
			for (int i = 0; i < n; i++)
				((xsd__QName*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__QName*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__anyURI_);
			((xsd__anyURI_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
			for (int i = 0; i < n; i++)
				((xsd__anyURI_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
			((xsd__nonNegativeInteger_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
			for (int i = 0; i < n; i++)
				((xsd__nonNegativeInteger_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:RelationshipTypeValues"))
	{	cp->type = SOAP_TYPE_xsd__RelationshipTypeValues_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__RelationshipTypeValues_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__RelationshipTypeValues_);
			((xsd__RelationshipTypeValues_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__RelationshipTypeValues_[n];
			if (size)
				*size = n * sizeof(xsd__RelationshipTypeValues_);
			for (int i = 0; i < n; i++)
				((xsd__RelationshipTypeValues_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__RelationshipTypeValues_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:FaultSubcodeValues"))
	{	cp->type = SOAP_TYPE_xsd__FaultSubcodeValues_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__FaultSubcodeValues_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__FaultSubcodeValues_);
			((xsd__FaultSubcodeValues_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__FaultSubcodeValues_[n];
			if (size)
				*size = n * sizeof(xsd__FaultSubcodeValues_);
			for (int i = 0; i < n; i++)
				((xsd__FaultSubcodeValues_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__FaultSubcodeValues_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:EndpointReferenceType"))
	{	cp->type = SOAP_TYPE_xsd__EndpointReferenceType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__EndpointReferenceType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__EndpointReferenceType);
			((xsd__EndpointReferenceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__EndpointReferenceType[n];
			if (size)
				*size = n * sizeof(xsd__EndpointReferenceType);
			for (int i = 0; i < n; i++)
				((xsd__EndpointReferenceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__EndpointReferenceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:ReferencePropertiesType"))
	{	cp->type = SOAP_TYPE_xsd__ReferencePropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__ReferencePropertiesType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__ReferencePropertiesType);
			((xsd__ReferencePropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__ReferencePropertiesType[n];
			if (size)
				*size = n * sizeof(xsd__ReferencePropertiesType);
			for (int i = 0; i < n; i++)
				((xsd__ReferencePropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__ReferencePropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "basefaults:BaseFaultType"))
	{	cp->type = SOAP_TYPE_basefaults__BaseFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new basefaults__BaseFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(basefaults__BaseFaultType);
			((basefaults__BaseFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new basefaults__BaseFaultType[n];
			if (size)
				*size = n * sizeof(basefaults__BaseFaultType);
			for (int i = 0; i < n; i++)
				((basefaults__BaseFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (basefaults__BaseFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:ResourceUnknownFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__ResourceUnknownFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__ResourceUnknownFaultType);
			((lifetime__ResourceUnknownFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__ResourceUnknownFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__ResourceUnknownFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__ResourceUnknownFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__ResourceUnknownFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:ResourceNotDestroyedFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__ResourceNotDestroyedFaultType);
			((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__ResourceNotDestroyedFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__ResourceNotDestroyedFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__ResourceNotDestroyedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__ResourceNotDestroyedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:UnableToSetTerminationTimeFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__UnableToSetTerminationTimeFaultType);
			((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__UnableToSetTerminationTimeFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__UnableToSetTerminationTimeFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__UnableToSetTerminationTimeFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "lifetime:TerminationTimeChangeRejectedFaultType"))
	{	cp->type = SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
			((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new lifetime__TerminationTimeChangeRejectedFaultType[n];
			if (size)
				*size = n * sizeof(lifetime__TerminationTimeChangeRejectedFaultType);
			for (int i = 0; i < n; i++)
				((lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (lifetime__TerminationTimeChangeRejectedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:ServiceNameType"))
	{	cp->type = SOAP_TYPE_xsd__ServiceNameType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__ServiceNameType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__ServiceNameType);
			((xsd__ServiceNameType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__ServiceNameType[n];
			if (size)
				*size = n * sizeof(xsd__ServiceNameType);
			for (int i = 0; i < n; i++)
				((xsd__ServiceNameType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__ServiceNameType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:Relationship"))
	{	cp->type = SOAP_TYPE_xsd__Relationship;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__Relationship;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__Relationship);
			((xsd__Relationship*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__Relationship[n];
			if (size)
				*size = n * sizeof(xsd__Relationship);
			for (int i = 0; i < n; i++)
				((xsd__Relationship*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__Relationship*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:ReplyAfterType"))
	{	cp->type = SOAP_TYPE_xsd__ReplyAfterType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__ReplyAfterType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__ReplyAfterType);
			((xsd__ReplyAfterType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__ReplyAfterType[n];
			if (size)
				*size = n * sizeof(xsd__ReplyAfterType);
			for (int i = 0; i < n; i++)
				((xsd__ReplyAfterType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__ReplyAfterType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:AttributedQName"))
	{	cp->type = SOAP_TYPE_xsd__AttributedQName;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__AttributedQName;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__AttributedQName);
			((xsd__AttributedQName*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__AttributedQName[n];
			if (size)
				*size = n * sizeof(xsd__AttributedQName);
			for (int i = 0; i < n; i++)
				((xsd__AttributedQName*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__AttributedQName*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:AttributedURI"))
	{	cp->type = SOAP_TYPE_xsd__AttributedURI;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__AttributedURI;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__AttributedURI);
			((xsd__AttributedURI*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__AttributedURI[n];
			if (size)
				*size = n * sizeof(xsd__AttributedURI);
			for (int i = 0; i < n; i++)
				((xsd__AttributedURI*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__AttributedURI*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___migol__Destroy(struct soap *soap, struct __migol__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lifetime__Destroy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___migol__Destroy(struct soap *soap, const struct __migol__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_lifetime__Destroy(soap, &a->lifetime__Destroy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___migol__Destroy(struct soap *soap, const struct __migol__Destroy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___migol__Destroy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___migol__Destroy(struct soap *soap, const char *tag, int id, const struct __migol__Destroy *a, const char *type)
{
	if (soap_out_PointerTo_lifetime__Destroy(soap, "lifetime:Destroy", -1, &a->lifetime__Destroy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __migol__Destroy * SOAP_FMAC4 soap_get___migol__Destroy(struct soap *soap, struct __migol__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in___migol__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __migol__Destroy * SOAP_FMAC4 soap_in___migol__Destroy(struct soap *soap, const char *tag, struct __migol__Destroy *a, const char *type)
{
	short soap_flag_lifetime__Destroy = 1;
	short soap_flag;
	a = (struct __migol__Destroy *)soap_id_enter(soap, "", a, SOAP_TYPE___migol__Destroy, sizeof(struct __migol__Destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___migol__Destroy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime__Destroy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_lifetime__Destroy(soap, "lifetime:Destroy", &a->lifetime__Destroy, ""))
				{	soap_flag_lifetime__Destroy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __migol__Destroy * SOAP_FMAC6 soap_new___migol__Destroy(struct soap *soap, int n)
{	return soap_instantiate___migol__Destroy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___migol__Destroy(struct soap *soap, struct __migol__Destroy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __migol__Destroy * SOAP_FMAC4 soap_instantiate___migol__Destroy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___migol__Destroy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___migol__Destroy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __migol__Destroy;
		if (size)
			*size = sizeof(struct __migol__Destroy);
	}
	else
	{	cp->ptr = (void*)new struct __migol__Destroy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __migol__Destroy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __migol__Destroy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___migol__Destroy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __migol__Destroy %p -> %p\n", q, p));
	*(struct __migol__Destroy*)p = *(struct __migol__Destroy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___migol__checkPoint(struct soap *soap, struct __migol__checkPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->migoldef__checkPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___migol__checkPoint(struct soap *soap, const struct __migol__checkPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___migol__checkPoint(struct soap *soap, const struct __migol__checkPoint *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___migol__checkPoint(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___migol__checkPoint(struct soap *soap, const char *tag, int id, const struct __migol__checkPoint *a, const char *type)
{
	soap_outliteral(soap, "migoldef:checkPoint", &a->migoldef__checkPoint, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __migol__checkPoint * SOAP_FMAC4 soap_get___migol__checkPoint(struct soap *soap, struct __migol__checkPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___migol__checkPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __migol__checkPoint * SOAP_FMAC4 soap_in___migol__checkPoint(struct soap *soap, const char *tag, struct __migol__checkPoint *a, const char *type)
{
	short soap_flag_migoldef__checkPoint = 1;
	short soap_flag;
	a = (struct __migol__checkPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___migol__checkPoint, sizeof(struct __migol__checkPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___migol__checkPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_migoldef__checkPoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "migoldef:checkPoint", &a->migoldef__checkPoint))
				{	soap_flag_migoldef__checkPoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __migol__checkPoint * SOAP_FMAC6 soap_new___migol__checkPoint(struct soap *soap, int n)
{	return soap_instantiate___migol__checkPoint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___migol__checkPoint(struct soap *soap, struct __migol__checkPoint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __migol__checkPoint * SOAP_FMAC4 soap_instantiate___migol__checkPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___migol__checkPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___migol__checkPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __migol__checkPoint;
		if (size)
			*size = sizeof(struct __migol__checkPoint);
	}
	else
	{	cp->ptr = (void*)new struct __migol__checkPoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __migol__checkPoint);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __migol__checkPoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___migol__checkPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __migol__checkPoint %p -> %p\n", q, p));
	*(struct __migol__checkPoint*)p = *(struct __migol__checkPoint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___migol__checkPointResponse(struct soap *soap, struct __migol__checkPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->migoldef__checkPointResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___migol__checkPointResponse(struct soap *soap, const struct __migol__checkPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___migol__checkPointResponse(struct soap *soap, const struct __migol__checkPointResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___migol__checkPointResponse(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___migol__checkPointResponse(struct soap *soap, const char *tag, int id, const struct __migol__checkPointResponse *a, const char *type)
{
	soap_element_result(soap, "migoldef:checkPointResponse");
	if (soap_out_bool(soap, "migoldef:checkPointResponse", -1, &a->migoldef__checkPointResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __migol__checkPointResponse * SOAP_FMAC4 soap_get___migol__checkPointResponse(struct soap *soap, struct __migol__checkPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___migol__checkPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __migol__checkPointResponse * SOAP_FMAC4 soap_in___migol__checkPointResponse(struct soap *soap, const char *tag, struct __migol__checkPointResponse *a, const char *type)
{
	short soap_flag_migoldef__checkPointResponse = 1;
	short soap_flag;
	a = (struct __migol__checkPointResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___migol__checkPointResponse, sizeof(struct __migol__checkPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___migol__checkPointResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_migoldef__checkPointResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "migoldef:checkPointResponse", &a->migoldef__checkPointResponse, "xsd:boolean"))
				{	soap_flag_migoldef__checkPointResponse--;
					continue;
				}
			soap_check_result(soap, "migoldef:checkPointResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_migoldef__checkPointResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct __migol__checkPointResponse * SOAP_FMAC6 soap_new___migol__checkPointResponse(struct soap *soap, int n)
{	return soap_instantiate___migol__checkPointResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___migol__checkPointResponse(struct soap *soap, struct __migol__checkPointResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __migol__checkPointResponse * SOAP_FMAC4 soap_instantiate___migol__checkPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___migol__checkPointResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___migol__checkPointResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __migol__checkPointResponse;
		if (size)
			*size = sizeof(struct __migol__checkPointResponse);
	}
	else
	{	cp->ptr = (void*)new struct __migol__checkPointResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __migol__checkPointResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __migol__checkPointResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___migol__checkPointResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __migol__checkPointResponse %p -> %p\n", q, p));
	*(struct __migol__checkPointResponse*)p = *(struct __migol__checkPointResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___migol__checkService(struct soap *soap, struct __migol__checkService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->migoldef__checkService = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___migol__checkService(struct soap *soap, const struct __migol__checkService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___migol__checkService(struct soap *soap, const struct __migol__checkService *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___migol__checkService(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___migol__checkService(struct soap *soap, const char *tag, int id, const struct __migol__checkService *a, const char *type)
{
	soap_outliteral(soap, "migoldef:checkService", &a->migoldef__checkService, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __migol__checkService * SOAP_FMAC4 soap_get___migol__checkService(struct soap *soap, struct __migol__checkService *p, const char *tag, const char *type)
{
	if ((p = soap_in___migol__checkService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __migol__checkService * SOAP_FMAC4 soap_in___migol__checkService(struct soap *soap, const char *tag, struct __migol__checkService *a, const char *type)
{
	short soap_flag_migoldef__checkService = 1;
	short soap_flag;
	a = (struct __migol__checkService *)soap_id_enter(soap, "", a, SOAP_TYPE___migol__checkService, sizeof(struct __migol__checkService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___migol__checkService(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_migoldef__checkService && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "migoldef:checkService", &a->migoldef__checkService))
				{	soap_flag_migoldef__checkService--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __migol__checkService * SOAP_FMAC6 soap_new___migol__checkService(struct soap *soap, int n)
{	return soap_instantiate___migol__checkService(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___migol__checkService(struct soap *soap, struct __migol__checkService *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __migol__checkService * SOAP_FMAC4 soap_instantiate___migol__checkService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___migol__checkService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___migol__checkService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __migol__checkService;
		if (size)
			*size = sizeof(struct __migol__checkService);
	}
	else
	{	cp->ptr = (void*)new struct __migol__checkService[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __migol__checkService);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __migol__checkService*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___migol__checkService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __migol__checkService %p -> %p\n", q, p));
	*(struct __migol__checkService*)p = *(struct __migol__checkService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___migol__checkServiceResponse(struct soap *soap, struct __migol__checkServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->migoldef__checkServiceResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___migol__checkServiceResponse(struct soap *soap, const struct __migol__checkServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___migol__checkServiceResponse(struct soap *soap, const struct __migol__checkServiceResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___migol__checkServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___migol__checkServiceResponse(struct soap *soap, const char *tag, int id, const struct __migol__checkServiceResponse *a, const char *type)
{
	soap_element_result(soap, "migoldef:checkServiceResponse");
	if (soap_out_bool(soap, "migoldef:checkServiceResponse", -1, &a->migoldef__checkServiceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __migol__checkServiceResponse * SOAP_FMAC4 soap_get___migol__checkServiceResponse(struct soap *soap, struct __migol__checkServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___migol__checkServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __migol__checkServiceResponse * SOAP_FMAC4 soap_in___migol__checkServiceResponse(struct soap *soap, const char *tag, struct __migol__checkServiceResponse *a, const char *type)
{
	short soap_flag_migoldef__checkServiceResponse = 1;
	short soap_flag;
	a = (struct __migol__checkServiceResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___migol__checkServiceResponse, sizeof(struct __migol__checkServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___migol__checkServiceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_migoldef__checkServiceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "migoldef:checkServiceResponse", &a->migoldef__checkServiceResponse, "xsd:boolean"))
				{	soap_flag_migoldef__checkServiceResponse--;
					continue;
				}
			soap_check_result(soap, "migoldef:checkServiceResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_migoldef__checkServiceResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct __migol__checkServiceResponse * SOAP_FMAC6 soap_new___migol__checkServiceResponse(struct soap *soap, int n)
{	return soap_instantiate___migol__checkServiceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___migol__checkServiceResponse(struct soap *soap, struct __migol__checkServiceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __migol__checkServiceResponse * SOAP_FMAC4 soap_instantiate___migol__checkServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___migol__checkServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___migol__checkServiceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __migol__checkServiceResponse;
		if (size)
			*size = sizeof(struct __migol__checkServiceResponse);
	}
	else
	{	cp->ptr = (void*)new struct __migol__checkServiceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __migol__checkServiceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __migol__checkServiceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___migol__checkServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __migol__checkServiceResponse %p -> %p\n", q, p));
	*(struct __migol__checkServiceResponse*)p = *(struct __migol__checkServiceResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_lifetime__DestroyResponse(struct soap *soap, _lifetime__DestroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__lifetime__DestroyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_lifetime__DestroyResponse(struct soap *soap, _lifetime__DestroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_lifetime__DestroyResponse);
	if (soap_out_PointerTo_lifetime__DestroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_lifetime__DestroyResponse(struct soap *soap, const char *tag, int id, _lifetime__DestroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__lifetime__DestroyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _lifetime__DestroyResponse ** SOAP_FMAC4 soap_get_PointerTo_lifetime__DestroyResponse(struct soap *soap, _lifetime__DestroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_lifetime__DestroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _lifetime__DestroyResponse ** SOAP_FMAC4 soap_in_PointerTo_lifetime__DestroyResponse(struct soap *soap, const char *tag, _lifetime__DestroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_lifetime__DestroyResponse **)soap_malloc(soap, sizeof(_lifetime__DestroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_lifetime__DestroyResponse *)soap_instantiate__lifetime__DestroyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_lifetime__DestroyResponse ** p = (_lifetime__DestroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__lifetime__DestroyResponse, sizeof(_lifetime__DestroyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_lifetime__Destroy(struct soap *soap, _lifetime__Destroy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__lifetime__Destroy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_lifetime__Destroy(struct soap *soap, _lifetime__Destroy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_lifetime__Destroy);
	if (soap_out_PointerTo_lifetime__Destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_lifetime__Destroy(struct soap *soap, const char *tag, int id, _lifetime__Destroy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__lifetime__Destroy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _lifetime__Destroy ** SOAP_FMAC4 soap_get_PointerTo_lifetime__Destroy(struct soap *soap, _lifetime__Destroy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_lifetime__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _lifetime__Destroy ** SOAP_FMAC4 soap_in_PointerTo_lifetime__Destroy(struct soap *soap, const char *tag, _lifetime__Destroy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_lifetime__Destroy **)soap_malloc(soap, sizeof(_lifetime__Destroy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_lifetime__Destroy *)soap_instantiate__lifetime__Destroy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_lifetime__Destroy ** p = (_lifetime__Destroy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__lifetime__Destroy, sizeof(_lifetime__Destroy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobasefaults__BaseFaultType))
		soap_serialize_PointerTobasefaults__BaseFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobasefaults__BaseFaultType);
	if (soap_out_PointerToPointerTobasefaults__BaseFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobasefaults__BaseFaultType(struct soap *soap, const char *tag, int id, basefaults__BaseFaultType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobasefaults__BaseFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobasefaults__BaseFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 basefaults__BaseFaultType *** SOAP_FMAC4 soap_get_PointerToPointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobasefaults__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 basefaults__BaseFaultType *** SOAP_FMAC4 soap_in_PointerToPointerTobasefaults__BaseFaultType(struct soap *soap, const char *tag, basefaults__BaseFaultType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (basefaults__BaseFaultType ***)soap_malloc(soap, sizeof(basefaults__BaseFaultType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobasefaults__BaseFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (basefaults__BaseFaultType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobasefaults__BaseFaultType, sizeof(basefaults__BaseFaultType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_basefaults__BaseFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobasefaults__BaseFaultType);
	if (soap_out_PointerTobasefaults__BaseFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobasefaults__BaseFaultType(struct soap *soap, const char *tag, int id, basefaults__BaseFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_basefaults__BaseFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 basefaults__BaseFaultType ** SOAP_FMAC4 soap_get_PointerTobasefaults__BaseFaultType(struct soap *soap, basefaults__BaseFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobasefaults__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 basefaults__BaseFaultType ** SOAP_FMAC4 soap_in_PointerTobasefaults__BaseFaultType(struct soap *soap, const char *tag, basefaults__BaseFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (basefaults__BaseFaultType **)soap_malloc(soap, sizeof(basefaults__BaseFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (basefaults__BaseFaultType *)soap_instantiate_basefaults__BaseFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	basefaults__BaseFaultType ** p = (basefaults__BaseFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_basefaults__BaseFaultType, sizeof(basefaults__BaseFaultType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (basefaults__BaseFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__ResourceUnknownFaultType, sizeof(lifetime__ResourceUnknownFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (basefaults__BaseFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType, sizeof(lifetime__ResourceNotDestroyedFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (basefaults__BaseFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType, sizeof(lifetime__UnableToSetTerminationTimeFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (basefaults__BaseFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType, sizeof(lifetime__TerminationTimeChangeRejectedFaultType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_basefaults__BaseFaultType_Description(struct soap *soap, _basefaults__BaseFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__basefaults__BaseFaultType_Description))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_basefaults__BaseFaultType_Description(struct soap *soap, _basefaults__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_basefaults__BaseFaultType_Description);
	if (soap_out_PointerTo_basefaults__BaseFaultType_Description(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_basefaults__BaseFaultType_Description(struct soap *soap, const char *tag, int id, _basefaults__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__basefaults__BaseFaultType_Description);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_basefaults__BaseFaultType_Description(struct soap *soap, _basefaults__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_basefaults__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _basefaults__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_basefaults__BaseFaultType_Description(struct soap *soap, const char *tag, _basefaults__BaseFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_basefaults__BaseFaultType_Description **)soap_malloc(soap, sizeof(_basefaults__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_basefaults__BaseFaultType_Description *)soap_instantiate__basefaults__BaseFaultType_Description(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_basefaults__BaseFaultType_Description ** p = (_basefaults__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__basefaults__BaseFaultType_Description, sizeof(_basefaults__BaseFaultType_Description), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_basefaults__BaseFaultType_ErrorCode(struct soap *soap, _basefaults__BaseFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_basefaults__BaseFaultType_ErrorCode(struct soap *soap, _basefaults__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_basefaults__BaseFaultType_ErrorCode);
	if (soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_basefaults__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _basefaults__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _basefaults__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_basefaults__BaseFaultType_ErrorCode(struct soap *soap, _basefaults__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _basefaults__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_basefaults__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _basefaults__BaseFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_basefaults__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_basefaults__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_basefaults__BaseFaultType_ErrorCode *)soap_instantiate__basefaults__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_basefaults__BaseFaultType_ErrorCode ** p = (_basefaults__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__basefaults__BaseFaultType_ErrorCode, sizeof(_basefaults__BaseFaultType_ErrorCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__EndpointReferenceType(struct soap *soap, xsd__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__EndpointReferenceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__EndpointReferenceType(struct soap *soap, xsd__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__EndpointReferenceType);
	if (soap_out_PointerToxsd__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__EndpointReferenceType(struct soap *soap, const char *tag, int id, xsd__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerToxsd__EndpointReferenceType(struct soap *soap, xsd__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerToxsd__EndpointReferenceType(struct soap *soap, const char *tag, xsd__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__EndpointReferenceType **)soap_malloc(soap, sizeof(xsd__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__EndpointReferenceType *)soap_instantiate_xsd__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__EndpointReferenceType ** p = (xsd__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__EndpointReferenceType, sizeof(xsd__EndpointReferenceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ServiceNameType(struct soap *soap, xsd__ServiceNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ServiceNameType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ServiceNameType(struct soap *soap, xsd__ServiceNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ServiceNameType);
	if (soap_out_PointerToxsd__ServiceNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ServiceNameType(struct soap *soap, const char *tag, int id, xsd__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ServiceNameType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__ServiceNameType ** SOAP_FMAC4 soap_get_PointerToxsd__ServiceNameType(struct soap *soap, xsd__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__ServiceNameType ** SOAP_FMAC4 soap_in_PointerToxsd__ServiceNameType(struct soap *soap, const char *tag, xsd__ServiceNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__ServiceNameType **)soap_malloc(soap, sizeof(xsd__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__ServiceNameType *)soap_instantiate_xsd__ServiceNameType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__ServiceNameType ** p = (xsd__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ServiceNameType, sizeof(xsd__ServiceNameType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__AttributedQName(struct soap *soap, xsd__AttributedQName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__AttributedQName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__AttributedQName(struct soap *soap, xsd__AttributedQName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__AttributedQName);
	if (soap_out_PointerToxsd__AttributedQName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__AttributedQName(struct soap *soap, const char *tag, int id, xsd__AttributedQName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__AttributedQName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__AttributedQName ** SOAP_FMAC4 soap_get_PointerToxsd__AttributedQName(struct soap *soap, xsd__AttributedQName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__AttributedQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__AttributedQName ** SOAP_FMAC4 soap_in_PointerToxsd__AttributedQName(struct soap *soap, const char *tag, xsd__AttributedQName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__AttributedQName **)soap_malloc(soap, sizeof(xsd__AttributedQName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__AttributedQName *)soap_instantiate_xsd__AttributedQName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__AttributedQName ** p = (xsd__AttributedQName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__AttributedQName, sizeof(xsd__AttributedQName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ReferencePropertiesType(struct soap *soap, xsd__ReferencePropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ReferencePropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ReferencePropertiesType(struct soap *soap, xsd__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ReferencePropertiesType);
	if (soap_out_PointerToxsd__ReferencePropertiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ReferencePropertiesType(struct soap *soap, const char *tag, int id, xsd__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ReferencePropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerToxsd__ReferencePropertiesType(struct soap *soap, xsd__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerToxsd__ReferencePropertiesType(struct soap *soap, const char *tag, xsd__ReferencePropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__ReferencePropertiesType **)soap_malloc(soap, sizeof(xsd__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__ReferencePropertiesType *)soap_instantiate_xsd__ReferencePropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__ReferencePropertiesType ** p = (xsd__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ReferencePropertiesType, sizeof(xsd__ReferencePropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__AttributedURI(struct soap *soap, xsd__AttributedURI *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__AttributedURI))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__AttributedURI(struct soap *soap, xsd__AttributedURI *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__AttributedURI);
	if (soap_out_PointerToxsd__AttributedURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__AttributedURI(struct soap *soap, const char *tag, int id, xsd__AttributedURI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__AttributedURI);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__AttributedURI ** SOAP_FMAC4 soap_get_PointerToxsd__AttributedURI(struct soap *soap, xsd__AttributedURI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__AttributedURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__AttributedURI ** SOAP_FMAC4 soap_in_PointerToxsd__AttributedURI(struct soap *soap, const char *tag, xsd__AttributedURI **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__AttributedURI **)soap_malloc(soap, sizeof(xsd__AttributedURI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__AttributedURI *)soap_instantiate_xsd__AttributedURI(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__AttributedURI ** p = (xsd__AttributedURI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__AttributedURI, sizeof(xsd__AttributedURI), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName_, sizeof(xsd__NCName_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(xsd__QName), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger_, sizeof(xsd__nonNegativeInteger_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__RelationshipTypeValues_, sizeof(xsd__RelationshipTypeValues_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__FaultSubcodeValues_, sizeof(xsd__FaultSubcodeValues_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__EndpointReferenceType, sizeof(xsd__EndpointReferenceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ReferencePropertiesType, sizeof(xsd__ReferencePropertiesType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_basefaults__BaseFaultType, sizeof(basefaults__BaseFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__ResourceUnknownFaultType, sizeof(lifetime__ResourceUnknownFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__ResourceNotDestroyedFaultType, sizeof(lifetime__ResourceNotDestroyedFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__UnableToSetTerminationTimeFaultType, sizeof(lifetime__UnableToSetTerminationTimeFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lifetime__TerminationTimeChangeRejectedFaultType, sizeof(lifetime__TerminationTimeChangeRejectedFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ServiceNameType, sizeof(xsd__ServiceNameType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__Relationship, sizeof(xsd__Relationship), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ReplyAfterType, sizeof(xsd__ReplyAfterType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__AttributedQName, sizeof(xsd__AttributedQName), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__AttributedURI, sizeof(xsd__AttributedURI), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xml__lang(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xml__lang(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xml__lang);
	if (soap_out__xml__lang(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xml__lang(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__xml__lang);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__xml__lang(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__xml__lang(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__xml__lang, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__nonNegativeInteger(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NCName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of monitorC.cpp */
