\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{times}
\usepackage{multirow}
\usepackage{listings}
\usepackage{times}
\usepackage{paralist}
%\usepackage{epsfig}
\usepackage[figtopcap]{subfigure}
\usepackage[hypertex]{hyperref}
\usepackage{subfigure}
\usepackage{color}


%\documentclass{rspublic}

\usepackage{ifpdf}


\newif\ifdraft
\drafttrue
\ifdraft
\newcommand{\jhanote}[1]{ {\textcolor{red} { ***shantenu: #1 }}}
\newcommand{\alnote}[1]{ {\textcolor{blue} { ***andre: #1 }}}
\newcommand{\athotanote}[1]{ {\textcolor{green} { ***athota: #1 }}}
\else
\newcommand{\alnote}[1]{}
\newcommand{\jhanote}[1]{}
\newcommand{\athotanote}[1]{}
\fi

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}

\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\setlength\parindent{0.1in}
\setlength\parskip{0.25em}


\ifpdf
  \DeclareGraphicsExtensions{.pdf, .jpg}
 \else
  \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\note}[1]{ {\textcolor{red} { ***NOTE: #1 }}}

\begin{document}

\title{\LARGE Running Asynchronous Replica-Exchange Simulations Across Heterogeneous Distributed Infrastructures}
 
\author{Abhinav Thota$^{1,2}$, Andre Luckow$^{1}$, Shantenu Jha$^{1,2,3}$\\
   \small{\emph{$^{1}$Center for Computation \& Technology, Louisiana State University, USA}}\\
   \small{\emph{$^{2}$Department of Computer Science, Louisiana State University, USA}}\\
   \small{\emph{$^{3}$e-Science Institute, University of Edinburgh, UK}}
   }
 
\maketitle

\section{Introduction}
 
Developing applications that are able to orchestrate heterogeneous
resources across distributed resources is a complex task.  Inevitably,
the design and development of an applicaiton is influenced and
constrained by the programming systems and the infrastructure it is
developed against. Breaking this coupling between the development and
the underlying infrastructure, to enable applications to be flexible
(across infrastructure), extensible (to new methods of communiction
and coordination) and scalable is an important design objective of
distributed applications -- both logically distributed and physically
distributed.

In this work, we focus on the Replica-Exchange (RE)
~\cite{hansmann,Sugita:1999rm} Methods -- which represent a class of
algorithms that involve a large number of loosely-coupled ensembles.
RE simulations are used to understand physical phenomena -- ranging
from protein folding dynamics to binding affinity calculations.

In this work, we develop a flexible, extensible and scalable
implementation of RE that can utilise a range of infrastructure
concurrently (and autonomically/adaptively), that supports different
coordination mechanisms (publish-subscribe, centralised notification),
different replica pairing mechanisms (synchronous versus asynchronous)
and thereby different variants of the RE algorithm. We implement and
demonstrate how flexible and robust implementation enables the
effecient use of a broad range of infrastructure.

% Several classes of applications, which are well suited for loosely
% coupled Grids, exist; that belongs to this category are
% \emph{Replica Exchange (RE)} simulations.  1 para intro to
% replica-exchange, and how it is traditionally done (ie case I)

\section{Replica-Exchange Approach}

The RE algorithm involves the concurrent execution of multiple similar
simulations, the \emph{replicas}.  There is a loose-coupling between
the replicas in form of periodic exchange attempts between paired
replicas. Previously, we demonstrated the usage of the SAGA Pilot-Job
framework~\cite{saga_bigjob_condor_cloud} -- called the BigJob, to run
replica exchange simulations across multiple, heterogeneous
distributed Grid and Cloud infrastructures~\cite{Luckow:2008fp}.
\alnote{maybe we should also intro SAGA at some point} \jhanote{Yes}
Further, we introduced several adaptivity modes, e.\,g.\ adaptive
sampling that are able to react to dynamic changes in resource
availabilities.

\alnote{Not sure how many technical we need to provide...}  Depending
on the number of processes \texttt{N}, the manager created \texttt{N/2} pairs
of replicas.  Before launching a job, the manager ensured that all
required input files are transferred to the respective resource. For
this purpose, the SAGA File API and the GridFTP adaptor were used. The
replica jobs were then submitted to the resource using the SAGA CPR
API and the MIGOL/GRAM middleware.

For the vanilla implementation of RE, when replicas reach a
pre-determined state (e.g. the NAMD job finishes after a fixed number
of steps), a decision as to whether to exchange temperatures between
previously paired replicas is determined using the Metropolis scheme.
The run of an ensemble of replicas in parallel and the subsequent
pairwise exchange attempt are referred to as generation. No two
replicas can belong to different generations. If the exchange attempt
was successful, parameters such as the temperature were swapped. Both
jobs were then relaunched.  \athotanote{I have tried to put here how
  the adaptive repex was done, supposing that it was case 1. Or should
  a general explanation of a replica exchange be here?} \jhanote{I
  think this is ok}
 
% 1 para limitation on traditional replica exchange
The major limitation of this model is that the replicas are paired and
that exchanges can only take place between neighboring replicas.  This
limits the group of replicas which are available for
exchange. Moreover, the replicas are stuck with their partners,
sometimes waiting for them to complete while there are possibly other
replicas available which are paired to their partners.  This puts a
strain on the number of exchanges that can take place within a certain
time.  \athotanote{is it better to have a wide group of replicas?
  need some input here!}

\jhanote{The point is really the following: Paired-replicas are Ok if
  it can be guaranteed that equal resources will be available, or the
  resource availabilty can be predicted in advance. However, in
  distributed systems, whereby definition, resource availability
  fluctates it is important to have a scheme/implementation that does
  not depend on a static, well-defined model of resource availability
  and execution. This forms the motivation for coming up with a
  formulation of a well known algorithm that makes it suitable for a
  range of infrastruture.}
  

  
\subsection{Asynchronous Replica Exchange}
%- Introduce asynchronous Replica Exchange --  1 para on case II and case III (algorithmically)

To overcome these limitations we propose an asynchronous replica
exchange algorithm similar to Parashar et al.~\cite{parashar_arepex}
where replicas can perform exchanges asynchronously. The possibility
to conduct exchanges asynchronously also eliminates the need to limit
exchanges to fixed pairs of replicas and allows exchanges with any
other replica available.
 
\alnote{We need to highlight how we particularly differ from Parashar
  et al: no comet, no MPI jobs, production Grids, understand
  performance sentence...}

The AsyncRE frameworks builds upon the SAGA BigJob and RE frameworks
discussed previously.  In the following we present two variants of the
Asynchronous RE algorithm. The first is a centralized mechanism where
all the replicas are managed by a master. The master will closely
monitor the replicas and will make the exchanges when feasible.  The
second is a decentralized mechanism where each replica is on its own
and a wrapper script will perform the the required actions to look for
partners and will make the exchange.

%Describe how we implement Case II and Case III (you can use figures)
%using SAGA and the advantages


\subsubsection{Centralized Asynchronous RE}

%%%%% FIGURE %%%%%
\begin{figure}
\centering
\includegraphics[scale=0.50]{figures/centralized_architecture}
\caption{\small Centralized Asynchronous Replica Exchange}
\label{fig:centralized}
%\vspace{-1em}
\end{figure}

We are calling the centralized version of the replica exchange case
2. \jhanote{Bad English. ``We are calling.. ``} \jhanote{Also, Case I
  has not been explicitly defined/mentioned}
In this case, one or more BigJobs are launched and the replicas are
submitted to the BigJobs as and when they become active. The master,
which also launches the BigJob, now monitors the replicas. When a
replica is done running, the master will start a search for an
appropriate partner from all the available replicas. The matching
mechanism that is being used here is the Metropolis scheme. The
energies of the two replicas which are negotiating an exchange are
compared and a decision is reached.  Whether or not a successful
exchange was possible, the master again monitors the replicas and when
it finds a replica which has finished running, it tries to find it a
partner.  After each successful exchange the replicas are resubmitted
to the BigJob(s) and restarted.

\subsubsection{Decentralized Asynchronous RE}

%%%%% FIGURE %%%%%
\begin{figure}
\centering

\subfigure[Overall Architecture]{
\includegraphics[width=0.57\textwidth]{figures/decentralized_architecture.pdf}
\label{fig:subfig2}
}
\subfigure[Control Flow: Replica Exchange]{
\includegraphics[width=0.35\textwidth]{figures/asyncre.pdf}
\label{fig:subfig1}
}

% \includegraphics[scale=0.50]{figures/decentralized_architecture.pdf}
\caption{\small Decentralized Asynchronous Replica Exchange}
\label{fig:decentralized}
%\vspace{-1em}
\end{figure}
%%%%% FIGURE %%%%%

Case 3 is the decentralized version. \jhanote{The distinction between
  Case 3 and 2 needs to be made more clear. The following is
  ``implementation detail''. What is the conceptual difference between
  Case 3 and Case 2?}  In this case, similar to the above case, one or
more BigJobs are launched but instead of submitting the replicas as
sub-jobs, the sub-job now is a wrapper script inside which is the
replica. The script then launches the replica as the sub-job and
monitors the replica and looks for partners to exchange as and when
the replica is done. In this case the too the various functions needed
to make the exchange are carried out by the wrapper script. In this
case the replicas will only have to restarted but not resubmitted to
the BigJob(s). The temperatures, energies and states of a replica are
reported to and retrieved from the SAGA advert service in real-time.

\section{Conclusion}
With this asynchronous replica exchange mechanism we can improve the
number of exchanges per unit time, a key parameter in judging the
performance of a replica-exchange mechanism. \athotanote{is this
  right? }  We are also going to have a wider group of replicas to
look at for each replica as we are not pairing the replicas. Also, we
have the usual advantages of using a pilot-job, such as reduced queue
wait times by not having to submit to the queue.  Unfortunately we
dont have results \jhanote{What results can we present -- any? some?},
so we will say, (i) we establish the ability to scale-out (distributed
and exa-scale) across different infrastructure (ii) compare the Async
versus sync formulation at unprecedented scales \jhanote{At least
  outline what infrastructure we / you are planning to use?} (iii)
compare different implementations of the Async version
 
 \bibliographystyle{IEEEtran} 
 \bibliography{literature,saga}


\end{document}

