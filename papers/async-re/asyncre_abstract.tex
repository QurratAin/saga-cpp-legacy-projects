\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{times}
\usepackage{multirow}
\usepackage{listings}
\usepackage{times}
\usepackage{paralist}
\usepackage{epsfig}
\usepackage[figtopcap]{subfigure}
\usepackage[hypertex]{hyperref}
\usepackage{subfigure}
\usepackage{color}



%\documentclass{rspublic}

\usepackage{ifpdf}

\newif\ifdraft
%\drafttrue
\ifdraft
\newcommand{\jhanote}[1]{ {\textcolor{red} { ***shantenu: #1 }}}
\newcommand{\alnote}[1]{ {\textcolor{blue} { ***andre: #1 }}}
\newcommand{\athotanote}[1]{ {\textcolor{green} { ***athota: #1 }}}
\else
\newcommand{\alnote}[1]{}
\newcommand{\jhanote}[1]{}
\newcommand{\athotanote}[1]{}
\fi

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}

\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\setlength\parindent{0.1in}
\setlength\parskip{0.25em}


\ifpdf
  \DeclareGraphicsExtensions{.pdf, .jpg}
 \else
  \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\note}[1]{ {\textcolor{red} { ***NOTE: #1 }}}

\begin{document}
\title{\LARGE Efficient Replica-Exchange Simulations on
  Large-Scale Production Infrastructure}

%Running Asynchronous Replica-Exchange Simulations Across Heterogeneous Distributed Infrastructures}
 
\author{Abhinav Thota$^{1,2}$, Andre Luckow$^{1}$, Shantenu Jha$^{1,2,3}$\\
   \small{\emph{$^{1}$Center for Computation \& Technology, Louisiana State University, USA}}\\
   \small{\emph{$^{2}$Department of Computer Science, Louisiana State University, USA}}\\
   \small{\emph{$^{3}$e-Science Institute, University of Edinburgh, UK}}
   }
 
\maketitle

\section{Introduction}
 
Developing applications that are able to orchestrate heterogeneous
resources across distributed resources is a complex task.  Inevitably,
the design and development of an application is influenced and
constrained by the programming systems and the infrastructure it is
developed against. Breaking this coupling between the development and
the underlying infrastructure, to enable applications to be flexible
(across infrastructure), extensible (to new methods of communication
and coordination) and scalable is an important design objective of
distributed applications -- both logically distributed and physically
distributed.

In this work, we focus on the Replica-Exchange (RE)~\cite{hansmann,Sugita:1999rm} 
methods -- which represent a class of
algorithms that involve a large number of loosely-coupled ensembles.
RE simulations are used to understand physical phenomena -- ranging
from protein folding dynamics to binding affinity calculations.
We develop a flexible, extensible and scalable
implementation of RE that can utilise a range of infrastructure
concurrently (and autonomically/adaptively), that supports different
coordination mechanisms (publish-subscribe, centralised notification),
different replica pairing mechanisms (synchronous versus asynchronous)
and thereby different variants of the RE algorithm. We implement and
demonstrate how a flexible and robust implementation enables the
efficient use of a broad range of infrastructure.

% Several classes of applications, which are well suited for loosely
% coupled Grids, exist; that belongs to this category are
% \emph{Replica Exchange (RE)} simulations.  1 para intro to
% replica-exchange, and how it is traditionally done (ie case I)

\section{Replica-Exchange Approach}

The RE algorithm involves the concurrent execution of multiple similar
simulations, the \emph{replicas}.  There is a loose-coupling between
the replicas in form of periodic exchange attempts between paired
replicas. Previously, we demonstrated the usage of the SAGA Pilot-Job
framework~\cite{saga_bigjob_condor_cloud} -- called the BigJob, to run
RE simulations across multiple, heterogeneous
distributed Grid and Cloud infrastructures~\cite{Luckow:2008fp}.
%\alnote{maybe we should also intro SAGA at some point} \jhanote{Yes}
The Simple API for Grid Applications (SAGA)~\cite{saga_gfd90} is an
API standardization effort within the Open Grid Forum
(OGF)~\cite{ogf_web}, an international standards development body
concerned primarily with standards for distributed computing.
The various tasks that are carried out using the SAGA APIs include file staging, job
spawning and the conduction of the exchange attempts.
%Further, we introduced several adaptivity modes, e.\,g.\ adaptive
%sampling that are able to react to dynamic changes in resource
%availabilities.

%\alnote{Not sure how many technical we need to provide...}  

%Traditionally, depending
%on the number of processes \texttt{N}, the manager creates \texttt{N/2} pairs
%of replicas.  Before launching a job, the manager ensures that all
%required input files are transferred to the respective resource. For
%this purpose, the SAGA File API and the GridFTP adaptor are used. The
%replica jobs are then submitted to the resource using the SAGA CPR
%API and the MIGOL/GRAM middleware.
For the vanilla implementation of RE (Case I), depending
on the number of processes \texttt{N}, the manager creates \texttt{N/2} pairs
of replicas. When the replicas reach a
pre-determined state (e.g. the NAMD job finishes after a fixed number
of steps), a decision as to whether to exchange temperatures between
previously paired replicas is determined using the Metropolis scheme.
The run of an ensemble of replicas in parallel and the subsequent
pairwise exchange attempt are referred to as generation. No two
replicas can belong to different generations. If the exchange attempt
is successful, parameters such as the temperature are swapped. Both
jobs are then relaunched. % \athotanote{I have tried to put here how
  %the adaptive repex was done, supposing that it was case 1. Or should
 % a general explanation of a replica exchange be here?} \jhanote{I
  %think this is ok}
 
% 1 para limitation on traditional replica exchange
A major limitation of this model is that the replicas are paired in fixed groups. 
Exchanges can only take place between these paired replicas.
This limits the number of replicas which are available for an exchange. 
Replicas commonly have to wait for their partners even if another replicas 
would be available for an exchange. %Moreover, the replicas are attached to their partners, 
%sometimes waiting for them to complete while there are possibly other replicas available which are paired to their partners.
This reduces the number of exchanges that can take place within a given time.
Replica pairing works well in an ideal scenario but with heterogeneous systems, 
where the resource availability fluctuates, it is far from ideal. It is 
important to have a scheme that does not depend on a static, well defined 
model of resource availability. This forms the motivation for coming up 
with a formulation that makes it possible to run RE simulations on a range of infrastructures.
 % \athotanote{is it better to have a wide group of replicas?
  %need some input here!}

%\jhanote{The point is really the following: Paired-replicas are Ok if
  %it can be guaranteed that equal resources will be available, or the
  %resource availabilty can be predicted in advance. However, in
  %distributed systems, whereby definition, resource availability
  %fluctates it is important to have a scheme/implementation that does
  %not depend on a static, well-defined model of resource availability
  %and execution. This forms the motivation for coming up with a
  %formulation of a well known algorithm that makes it suitable for a
  %range of infrastruture.}
  

  
\subsection{Asynchronous Replica Exchange}
%- Introduce asynchronous Replica Exchange --  1 para on case II and case III (algorithmically)

To overcome these limitations we propose an asynchronous RE algorithm similar to Parashar et al.~\cite{parashar_arepex}
where replicas can perform exchanges asynchronously with any other available replica. This eliminates the need to pair the replicas and limit exchanges to fixed pairs of replicas. We differ from the model described in Parashar et al. in some important ways. The asynchronous RE model we developed runs on production level grids such as the Teragrid and LONI~\cite{LONI_web}, unlike a specialized infrastructure such as CometG. %Also, we run all replicas as MPI jobs.

%\athotanote{how do the control flow diagrams
%  look? }
%\alnote{We need to highlight how we particularly differ from Parashar
  %et al: no comet, no MPI jobs, production Grids, understand
  %performance sentence...}
The asynchronous replica exchange framework builds upon the SAGA BigJob and RE frameworks discussed previously.
%The architecture is shown in Figure 1.
We present two variants of the Asynchronous RE algorithm. The first is a centralized 
mechanism where all the replicas are managed by a master. The master closely monitors the replicas and makes the exchanges when appropriate. 
The second is a decentralized mechanism where each replica is managed individually and independently. An agent is launched in place of the replica and will perform the the required actions on behalf of the replica.
%Describe how we implement Case II and Case III (you can use figures)
%using SAGA and the advantages


\subsubsection{Centralized Asynchronous RE}

%%%%% FIGURE %%%%%
% \begin{figure}
% \centering
% \includegraphics[scale=0.6]{figures/Bigjob_arch.pdf}
% \caption{\small SAGA/BigJob Architecture}
% \label{fig:centralized}
% %\vspace{-1em}
% \end{figure}


In the centralized version (Figure~\ref{fig:async}(a)) of the
asynchronous replica exchange (Case II), one or more BigJobs are
launched and the replicas are submitted to the BigJobs as and when
they become active. The master, which also launches the BigJob, now
monitors the replicas. When a replica is in done state, the master
will start a search for an appropriate partner from all the available
replicas. The decision as to make the exchange or not is made using
the Metropolis scheme.  Whether or not a successful exchange takes
place, the master again monitors all the replicas and repeats the
steps mentioned.  After each successful exchange the replicas are
resubmitted to the BigJob(s) and restarted.

\subsubsection{Decentralized Asynchronous RE}


%%%%% FIGURE %%%%%
\begin{figure}
\centering
\subfigure[Control Flow: Centralized Replica Exchange]{
\includegraphics[width=0.42\textwidth]{figures/centralized.pdf}
%\label{fig:async:a}
}
\subfigure[Control Flow: Decentralized Replica Exchange]{
\includegraphics[width=0.42\textwidth]{figures/asyncre.pdf}
%\label{fig:async:b}
}
% \includegraphics[scale=0.50]{figures/decentralized_architecture.pdf}
\caption{\small In the centralized version(Figure 1(a)), all the replicas are managed by the master, where as in the decentralized version(Figure 1(b), for each replica there is a replica agent which individually and independently manages the replica.}
\label{fig:async}
%\vspace{-1em}
\end{figure}
%%%%% FIGURE %%%%%

%
%%%%% FIGURE %%%%%
\begin{figure}
\centering
\includegraphics[scale=0.28]{figures/combined_graph.pdf}
\caption{\small The graph shows the completion times of synchronous and asynchronous RE simulations across 1, 2 and 4 machines, respectively. In each case, four 64 core BigJobs were launched, distributed across 1, 2 or 4 machines and were assigned 16 replicas. The size of each replica is 16 cores. At the most, each experiment has been repeated 2 times. The vast difference between the completion times of synchronous and asynchronous RE can be observed. This is due to the fact that asynchronous RE needs to run much fewer iterations to conduct the required number of exchanges. }
\label{fig:graph}
\vspace{-1em}
\end{figure}

 

In the decentralized version (Case III) version
(Figure~\ref{fig:async}(b)), one or more BigJobs are launched
but instead of submitting the replicas as sub-jobs, an agent is
launched in place of the replica. The agent is nothing but a wrapper
script for the replica. The script then runs the replica and monitors
the replica and looks for partners to exchange as and when the replica
is ready. In this case the various functions needed to make the
exchange are carried out by the wrapper script. The temperatures,
energies and states of a replica are reported to and retrieved from
the SAGA advert service. 

Although both Case II and Case III implement asynchronous 
RE algorithm, they differ subtly, in that the replicas
are either managed by a master (Case II) or each replica
is managed individually (Case III).
% We have to bear in mind that while Case II and Case III both implement the same asynchronous RE algorithm, they do it differently.
% At first glance it appears to be a question of philosophy, whether to
% let the replicas be managed by a master or to let each replica be
% managed individually.
%There could be implications effecting the performance of the
%algorithm. Where as in Case II, the master has to manage all the
%replicas and since it can only manage one replica at a time, although negligible, it is a cause for concern with large number of replicas. %The effect could be negligible and might now effect the overall performance.
%But the decentralized version (Case III) has no
%such issues as each replica is managed individually. % \jhanote{The distinction between Case 3 and 2 needs to
%  be made more clear. The following is ``implementation detail''. What
%  is the conceptual difference between Case 3 and Case 2?}

\section{Analysis}

To evaluate the performance of the various models of RE we have discussed in the abstract, we have conducted several experiments on Teragrid and LONI resources. In the following sentences we will compare the performance of synchronous RE(Case I) with centralized asynchronous RE(Case II). 

We configured both the cases to run a parallel NAMD simulation with 16 replicas sampling a temperature between 300 and 450 K. Replica exchanges are carried out between pairs of replicas. Each test run comprises 64 attempted exchanges; each replica uses 16 MPI processes and runs 500 time steps between exchange attempts. The experiments are conducted on a variable number of machines, so as to analyze any advantages of doing so. The metric used is the time to completion for 64 attempted exchanges. Both cases have been repeated across 1, 2 and 4 machines, where BigJobs are distributed across the resources. The experiments could be potentially run across an infinite number of dissimilar machines. At the most, each experiment has been repeated 2 times. 
The initial results suggest that the performance has improved at two levels: (i) the time to completion of Case II is reduced by over 200\% compared to Case I and (ii) there is considerable reduction in the time to completion when running across 3 machines, by as much as 45\%, instead of only 1 machine. 

The time to completion includes queue wait time. To understand the performance gains(Figure~\ref{fig:graph}) we need to analyze Case I and Case II in detail. In Case I, the pair-wise replica exchange can occur only between replicas of the same generation. Therefore, each exchange step is attempted only after all the replicas have finished running. After the exchange, all the replicas are restarted together. Each exchange step is counted as an exchange.
In Case II, the pair-wise replica exchange can take place between any two replicas in the ensemble. The exchanges are attempted asynchronously and the replicas are restarted after the exchange. 
Without including the queue wait times, the time to complete a synchronous replica exchange(Case I) experiment in order to complete 64 exchanges with the configuration described above is nearly 2 hours. The time to complete 64 exchanges(with the same configuration) using the asynchronous replica exchange model(Case II) is approximately 30 minutes. That in itself is a huge improvement of over 200\%.
Further, we show performance gains by running across more than 1 machine. By running across more than one machine, we provide the ability to distribute smaller jobs across a number of machines, there by reducing the risk of long queue wait times on an over-crowded resource. In Figure~\ref{fig:graph}, it can be seen that for the synchronous RE the time to completion decreases slightly over 2 machines, but again increases over 4 machines. This is due to the fact that the experiments have been run only a handful of times but, over time, it can be assumed that it will result in reduced queue wait times.

\section{Conclusion}



%\athotanote{is this right? }
% We are also going to have a wider group of replicas to look at for
% each replica as we are not pairing the replicas.

% Also, we have the usual advantages of using a pilot-job,
% such as reduced queue wait times by not having to submit to the queue
% at every step.  We also provide major advantages when compared to
% Parashar et al.

%  to run the asynchronous RE simulations,
% including the ability to run MPI
% jobs.
% ??We need to evaluate the performance of our models and compare with other models for conducting replica exchange simulations.


%%%%% FIGURE %%%%%
%\begin{figure}
%\centering
%\subfigure[Time to complete 64 exchanges on QB with two 64 core BigJobs and on both QB/Louie jointly with a 64 core BigJob on each machine.]{
%\includegraphics[width=0.40\textwidth]{figures/graph1.pdf}
%\label{fig:subfig3}
%}
%\hspace{0.5cm}
%\subfigure[Time to complete different number of exchanges on QB/Louie with a 64 core BigJob on each machine.]{
%\includegraphics[width=0.40\textwidth]{figures/graph2.pdf}
%\label{fig:subfig4}
%}
%\caption{\small In Figure 2(a), we can see the improvement in performance when run on more than one machine. It is due to the fact that usually the first queued job becomes active before the second on a machine and running jobs on more than one machine solves this problem. In Figure 2(b), we can see consistent performance over prolonged runs, making 32, 64 and 128 exchanges.}
%\label{fig:graphs}
%\vspace{-1em}
%\end{figure}
%%%%% FIGURE %%%%%

With an asynchronous replica exchange mechanism we can improve the
number of exchanges per unit time, a key parameter in judging the
performance of a replica-exchange mechanism.  An important motivation
for this work is to implement a scheme that does not depend on a
static, well defined model of resource availability. %We test and scale
%our implementation on production level grids such as Teragrid and
%LONI~\cite{LONI_web}.
Preliminary results, shown in Figure~\ref{fig:graph}, indicate the two most important advantages of asynchronous RE and SAGA/BigJob over traditional RE: (a) the overwhelming reduction in the the time to completion compared to synchronous RE and (b) the reduced time to completion when running on more than one machine, respectively.
% It performs well even after doubling and quadrupling the number of
% exchanges required to complete the simulation. The time to
% completion only increases by 35\% after doubling and 117\% after
% quadrupling the number of exchanges.
%\athotanote{should the results
%  be included in the conclusion or in a separate results section? Do
%  you agree with the \# of exchanges scheme to show the data?}
% Unfortunately we have results only for Case II currently, but 

%In summary, we have established the ability to scale-out across different
%infrastructure and compared the performance of the asynchronous
%RE with the synchronous RE at large scales. 
Further, we will
compare and analyze the centralized and decentralized models of the asynchronous
replica exchange.


%With this asynchronous replica exchange mechanism we can improve the
%number of exchanges per unit time, a key parameter in judging the
%performance of a replica-exchange mechanism. \athotanote{is this
 % right? }  We are also going to have a wider group of replicas to
%look at for each replica as we are not pairing the replicas. Also, we
%have the usual advantages of using a pilot-job, such as reduced queue
%wait times by not having to submit to the queue.  Unfortunately we
%dont have results \jhanote{What results can we present -- any? some?},
%so we will say, (i) we establish the ability to scale-out (distributed
%and exa-scale) across different infrastructure (ii) compare the Async
%versus sync formulation at unprecedented scales \jhanote{At least
%  outline what infrastructure we / you are planning to use?} (iii)
%compare different implementations of the Async version
 
 \bibliographystyle{IEEEtran} 
 \bibliography{literature,saga}


\end{document}

