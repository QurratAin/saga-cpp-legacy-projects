\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage{fullpage}

\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{subfigure}  
\usepackage[usenames,dvipsnames]{color}
\usepackage{srcltx}
\usepackage{url}
\usepackage{ifpdf}
\usepackage{xspace}
\usepackage[small,it]{caption}

\ifpdf
 \usepackage{hyperref}
%\usepackage[hpdftex]{hyperref}
\else
 \usepackage[hypertex]{hyperref}
\fi

\newenvironment{shortlist}{
  \vspace*{-0.5em}
  \begin{itemize}
  \setlength{\itemsep}{-0.3em}
}{
  \end{itemize}
  \vspace*{-0.5em}
}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\smilie}{\small;-)~\xspace}

\newcommand{\nind}{\noindent}
\newcommand{\todo}[1]{{\textcolor{red}{\B{TODO:} #1 }}}

\newif\ifdraft
\drafttrue
\ifdraft
 \newcommand{\jhanote}[1]{{\textcolor{red}{     \B{Shantenu:} #1 }}}
 \newcommand{\amnote}[1]{{\textcolor{green}{   \B{AndreM:  } #1 }}}
 \newcommand{\alnote}[1]{{\textcolor{blue}{    \B{AndreL:  } #1 }}}
 \newcommand{\ownote}[1]{{\textcolor{Brown}{   \B{Ole:     } #1 }}}
 \newcommand{\smnote}[1]{{\textcolor{Mulberry}{\B{Sharath: } #1 }}}
 \newcommand{\msnote}[1]{{\textcolor{magenta}{ \B{Mark:    } #1 }}}
 \newcommand{\hknote}[1]{{\textcolor{red}{  \B{Hartmut: } #1 }}}
\else
 \newcommand{\jhanote}[1]{}
 \newcommand{\amnote}[1]{}
 \newcommand{\alnote}[1]{}
 \newcommand{\ownote}[1]{}
 \newcommand{\smnote}[1]{}
 \newcommand{\msnote}[1]{}
 \newcommand{\hknote}[1]{}
\fi


\usepackage{ifpdf}
\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\up}{\vspace*{-1em}}

\begin{document}

\begin{center}
  {\Large Understanding Distributed Applications: A SAGA Perspective}
\end{center}

{
 {
  \centering
  Shantenu Jha$^{1235}$,
  Hartmut Kaiser$^{25}$
  Andre Luckow$^{2}$,\\
  Sharath Maddineni$^{2}$,
  Andre Merzky$^{2}$,
  Mark Santcroos$^{42}$,
  Ole Weidner$^{23}$
  \\[0.4em]
  }
 \noindent
%  \tiny
%  $^1$ Rutgers University\\[-1.0em]
%  $^2$ Center for Computation and Technology, Louisiana State University\\[-1.0em]
%  $^3$ School of Informatics, University of Edinburgh \\[-1.0em]
%  $^4$ Bioinformatics Laboratory, Academic Medical Center, University of Amsterdam\\[-1.0em]
%  $^5$ Department of Computer Science, Louisiana State
%  University\\[-1.0em]
 $^1$ Rutgers University\\
 $^2$ Center for Computation and Technology, Louisiana State University\\
 $^3$ School of Informatics, University of Edinburgh \\
 $^4$ Bioinformatics Laboratory, Academic Medical Center, Univ. of Amsterdam\\
 $^5$ Department of Computer Science, Louisiana State University\\
}

\begin{abstract}
  The SAGA Project has grown over time and evolved with the
  infrastructure, trends and the successes and failures of the
  distributed computing and e-Science community as a whole. We take
  this opportunity to provide a retrospective -- an analysis of where
  the SAGA project is and why, as well as a prognosis on its likely
  evolution and growth trajectory. The evolution of SAGA is strongly
  tied to the evolution of distributed applications and systems and
  can in turn be used to understand their evolution. The purpose of
  this paper is to explore SAGA as a metaphor for distributed
  applications, introspect and analyze the evolution of SAGA, and
  predict the road ahead.
\end{abstract}
%\begin{center}
  %\footnotesize{\bf{\it ``If you don't know where you are coming from,
  %    you cannot know where you are going. \\ And if you don't know
  %    where you are going, any road will take you there.''  \\
  %    -- Private communication, anonymous and with one of the
  %   authors}}
%\end{center}

\alnote{Spelling: grid vs. Grid, PilotJob vs. Pilot-Job vs. pilot-job}

\section{Introduction \& Scope }
\label{sec:intro}

Over the past decade, we have been engaged in the intellectually
challenging, yet novel and rich pursuit of enabling scientific
applications to utilize distributed cyberinfrastructure. The Simple
API for Grid Applications (SAGA) -- the common uniting approach and
underlying theme of our efforts -- was conceived in the gap arising
from missing distributed programming abstractions. SAGA represents the
a comprehensive community effort led by the authors to bridge this
gap.

The aim of this paper is two-fold: it aims to (i) to understand the
evolution of SAGA as a function of technology, community and
infrastructure trends and evolution, and (ii) to understand the
evolution of distributed applications through the prism of SAGA.

For this discussion, the \I{SAGA Project} is loosely defined as a set
of efforts and people who, (i) work on/with the SAGA API
specifications\cite{saga-core}, who (ii) provide implementations of
the SAGA API~\cite{saga-c++,jsaga,javasaga}, and (iii) who provide
higher-level programming abstractions and application frameworks based
on the SAGA API\cite{bigjob_cloudcom10}.

In the following, we will shortly recap and analyze the history and
current state of these three efforts (sec.~\ref{sec:retro}). We will
discuss the external factors that influenced the evolution of our
project, such as the evolution of distributed systems and applications
(sec.~\ref{sec:state}). Furthermore, we will discuss the future
potential of the SAGA project along three axes: standardization,
implementation, and integration. Finally in sec.~\ref{sec:road} we
draw up a draft for a possible evolution of SAGA and the field of
distributed applications in general.

 
% have been enrichening and support activities in the area of
% e-Science and distributed computing (DC) for the past decade, most
% notably by defining and implementing the Simple API for Grid
% Applications (SAGA), which spawned an interesting and agile ecosystem
% of distributed programming abstractions.
% \footnote{Note that SAGA
% itself is about 6 years old -- however, we have been working on the
% same problem space for much longer -- in particular we should mention
% the Grid Application Toolkit (GAT) which we consider to be
% a predecessor for SAGA.  In this context, we use the sole term SAGA as
% simplification, as a representation of an idea.}

% At the same time, the hurdles for application and framework developers
% to efficiently utilize DC infrastructures (DCI) are still significant,
% and many of the complaints voiced by those communities do not differ
% very much from what we heard a decade ago, when they initially
% prompted our Grid Application Toolkit activities in the GridLab
% project.  That naturally prompts serious questions on both what we
% managed to accomplish so far, but also, possibly more importantly, one
% what we will attempt to accomplish in the future -- as only by now we
% seem to really begin to understand what we are actually trying to
% achieve.  
 
% We (as in the authors of this paper and colleagues) have been trying
% to enrich and support activities in the area of e-Science and
% distributed computing (DC) for the past decade, most notably by
% defining and implementing the Simple API for Grid Applications (SAGA),
% which spawned an interesting and agile ecosystem of distributed
% programming abstractions.
% \footnote{Note that SAGA
% itself is about 6 years old -- however, we have been working on the
% same problem space for much longer -- in particular we should mention
% the Grid Application Toolkit (GAT) which we consider to be
% a predecessor for SAGA.  In this context, we use the sole term SAGA as
% simplification, as a representation of an idea.}

% At the same time, the hurdles for application and framework developers
% to efficiently utilize DC infrastructures (DCI) are still significant,
% and many of the complaints voiced by those communities do not differ
% very much from what we heard a decade ago, when they initially
% prompted our Grid Application Toolkit activities in the GridLab
% project.  That naturally prompts serious questions on both what we
% managed to accomplish so far, but also, possibly more importantly, one
% what we will attempt to accomplish in the future -- as only by now we
% seem to really begin to understand what we are actually trying to
% achieve.  

 % Define what we mean by the SAGA Project (i) SAGA - the standard,
 % incl. relation to other specs, (ii) SAGA the implementation --
 % engine, bindings, adaptors, packaging, testing and deployment, (iii)
 % SAGA the distributed programming and development paradigm (bigjob,
 % DAG-based, DARE)


\section{Retrospective}
\label{sec:retro}
\alnote{Looking at the space, maybe it would make sense to merge Retrospective and Current State. This also avoids repetitions.}

This section will capture the history of SAGA, discuss some of the
extrinsic influences on the SAGA API evolution.  \jhanote{We do not
  present lessons' learned} and present some lessons we learned over
that period.  

%  Ten years are almost an eternity in academic software development,
%  and (almost) only successful software projects can look at that long
%  of a history.  Or very stubborn ones~\smilie 

\subsection{Distributed Applications Landscape}

The effort to provide a Simple API to develop Distributed Applications
(which in the early days mostly meant grid applications, hence
SA\BI{G}A) was mostly driven by the perceived need for such an API for
programmers of scientific applications: those applications were
expected to evolve into genuine first principle distributed
applications~\ref{gat-motivation}.

The evolution of grid applications was heavily influenced if not
guided (or constrained) by the evolution of the grid infrastructure;
there was a bifurcation into narrow grids (such as iVDGL and Grid3,
precursors to the OSG) and general purpose grids (such as Distributed
Terascale Facility, UK NGS).

Historically the first Grid Applications on 'general-purpose' grids
were distributed analogues of legacy high-performance computing (HPC)
applications~\cite{dpagrid2009}. In contrast, applications on the
narrow grids predating the OSG had a less ``static'' resource
utilization model; there existed a decoupling between application
workloads and specific resources.

The evolution and trajectory of SAGA was influenced by participation
OGF (OSG for example did not and does not philosophically
adhere to community standards). Had applications developers/users from
the OSG been encouraged to engage with the OGF and thereby SAGA the
outcome and design decisions would no doubt have been different.

It has been observed that over the past decade very few, if any
scalable applications that were designed with distribution as
first-class design objectives option have emerged.

Interestingly, over the last years, SAGA has been used more to develop
(program) tools and frameworks rather than the end-user scientific
program, i.e., SAGA has been used much more often to develop
abstractions such as PilotJob, MasterWorker frameworks, and other
application frameworks (gateways, simple pipelines and workflows etc).

However the number of applications that use distributed infrastructure
have made modest gains; this in turn could be related to the fact that
some of the distributed infrastructure itself has taken on
functionality which previously was thought to be exclusive to the
applications (see PaaS and SaaS, but also Grid services,
portals/gateways and runtime frameworks). \alnote{shall we define or
  reference a definition of PaaS/SaaS?}\jhanote{Yes}

This is consistent with the notion that for distributed/grid systems
``programming the infrastructure'' has been as important as
programming the application.

% or make use of distributed lower level infrastructures
% in some other way, has been increasing steadily.  

% During that time, the original target scope for SAGA almost
% disappeared -- we have not seen as many first principle distributed
% environments, or make use of distributed lower level infrastructures
% in some other way, has been increasing steadily.  In relation to that,
% the distributed infrastructure itself has taken some of the
% functionality which previously was thought to be exclusive to the
% applications (see PaaS and SaaS, but also higher level Grid services,
% portals, gateways and runtime frameworks).

% seen not as much adoption of SAGA as
% an application programming tool, but much more often as a vehicle to
% provide programming abstractions (MapReduce, PilotJob, MasterWorker
% etc) and application frameworks (portals, gateways,
% workflows etc).\\

\jhanote{Why is this in the section on Distributed Applications}
Although the GAT and other similar high level APIs were available very
early, they were not of a software quality and could not offer the
level of support to instigate wider adoption in the community.

Also, the definition and implementation of the SAGA API took much
longer than anticipated -- and the application and DCI landscape
continued to evolve, towards virtualized infrastructures, higher level
services, novel coordination patterns, etc.  \jhanote{This is
  suspect. IMO Virtualization did not reach critical mass till after
  SAGA was in effect stable} \jhanote{But why is this in the section
  on Distributed Applications}

\BI{Lesson i:} \I{Infrastructure evolves in unexpected directions  on
  all levels.}  \jhanote{a right ``lesson'' but in the wrong place and
  thus ascribed to the wrong reasons} \jhanote{Please move 2.4. This
  fits there, not here}

 \subsection{API Scope}

  SAGA's scope has partially been driven by a number of proprietary
  Grid APIs which all seemed to provide very similar semantics in many
  different and sometimes unfriendly ways: submitting and managing
  jobs, moving and reading remote data files, etc.  SAGA has been
  successful where we managed to capture those aspects for the
  majority of the use cases -- OTOH, it has not seen significant
  uptake for many functional aspects which we assumed important, but
  obviously where not (data streaming, RPC, checkpoint management).
  Some of those aspects were rooted in legacy models of distributed
  computing, some were possibly not rendered simply enough, or not
  explicit enough -- we do not know the exact reasons.  At the bottom
  line we had to learn how hard it is to anticipate end user adoption
  based on a finite set of use cases -- one has to live with that, and
  be able to cope with evolving application requirements.

  Some aspects of the API have been used very widely, and have been
  proven to be conceptually useful even if not explicitly required
  initially -- in particular the advert API as means to coordinate
  distributed application components has been serving a real need.

  In summary we think that the current scope of the API may be too
  wide in some aspects, but may also be too static and too slowly
  evolving in other aspects -- which is somewhat contradictory (but
  real), and also has consequences for the generally slow
  standardization process of the API.\\
  %
  \BI{Lesson ii:} \I{Use cases appear and disappear with high frequency;
  use cases are never complete.  Abstractions thus need to be agile.}


 \subsection{SAGA Standardization}
  \alnote{maybe this should be placed before API scope since it gives a 
  general overview.}
  The Grid Application Toolkit was one of the prominent software
  deliverables of the GridLab project~\ref{gridlab}, and was designed
  to support the development of novel distributed application use
  cases for grid environments.  Together with other similar efforts in
  the Grid application community, it prompted the attempt to create
  a standardized, uniform and stable application programming interface
  for developing distributed (Grid) applications -- the OGF SAGA
  working and research group has been the focal point of that effort,
  and numerous projects and groups participated in the early
  evolution of the SAGA API.  

  It is hard to judge how much of the success of SAGA can be
  contributed to the fact that it is a standard -- but without doubt
  that has been a compelling argument for DCI providers to consider
  support for SAGA.  It is thus unexpected and unsatisfying that this
  support has not been able to trickle down to the actual
  infrastructure software layers, which are best positioned to
  actually support SAGA implementations.  A lesson to be learned from
  DRMAA, for example, is that an early participation of the middleware
  providers may have helped -- but that runs diametrically to the
  application driven approach of SAGA.  It is not clear to us if and
  how how that contradiction can be solved.

  The API standard itself has seen multiple implementations, and solid
  (but not overwhelming) support from different implementer groups all
  over the world.  While the agility aspect of the standardization
  process likely needs reconsideration, the stability aspect and the
  support for acceptance should not be\\
  %
  \BI{Lesson iii:} \I{It is very hard to balance agility and stability
  of abstractions.}

\alnote{Do we also have a Retrospective on the
  implementation?}\jhanote{No. But don't think it is required either}

\subsection{Production Distributed Cyber Infrastructures}

We have seen that application frameworks on the one (upper) end, and
application oriented DCI capabilities on the other (lower) end, have
increasingly and successfully been used by our target community over
the past years -- several semantic aspects which the SAGA API was to
provide towards application programmers are nowadays provided by other
layers, often in a way which is fairly accessible to applications.
Where those higher level concepts provided by DCIs are not easily
accessible to applications, SAGA had a hard time to follow the DCI
evolution and to build upon those capabilities, or to incorporate them
into its scope.  Much of that lagging-behind is though simply caused
by a lack of resources -- for an academia driven project it is very
hard to come up with resources to address the continuous evolution of
a software product (to sustain it).  But also, hindsight is 20:20 --
it is of course not always possible to anticipate which of the many
evolutionary strands will prove to be
useful and thus worth adopting.\\
  %
\BI{Lesson iv:} \I{It is costly to be agile. It is also costly not to
  have 20:20 foresight.} \jhanote{This is a weak if not ambigious
  lesson. To be replaced by current lession 1. OK?}



%\subsection{Middleware, Tools and Development Frameworks}
%
% \todo{complete or remove}


\section{Current State of Affairs}
\label{sec:state}


 While the SAGA project has been evolving in the background of
 applications and production infrastructures (as discussed above), it
 has also been evolving in its internal structure, due to intrinsic
 aspects of the project.  This section describes the current structure
 of the project, and its intrinsic setup and boundary conditions.

 \todo{we do not yet talk about the project setup and boundary
 conditions.}


\subsection{SAGA Standard}
  \alnote{Where do we describe what's part of the specification? 2.2 is very 
  high-level in this respect. The reader might not be that familiar with SAGA,
  e.g. he might not now what packages SAGA has, etc.}
  Over the last decade, the state of the SAGA API specifications
  (plural, as we refer to the SAGA Core API specification and multiple
  extensions) have matured sufficiently enough that we are confident
  that they are not a limiting factor of our current evolution.  OTOH,
  multiple extensions have been specified due to real or perceived
  needs and requirements, but have not yet been implemented nor shown
  to effectively address the current DCI challenges.  Unless there is
  a more globally coordinated approach to future API specification
  work, there seems not too much value in expanding the set of SAGA
  specification documents -- apart from tangential benefits such as
  gaining public feedback, or formalizing concepts which are yet
  unclear or nebulous.

  The SAGA language binding specifications are a somewhat different
  story: there exists no C++ language binding document, but also only
  one C++ implementation, so the value of a document is not
  immediately clear.  There exist no Java language specification
  document either, but two implementations which use the same API, so 
  again work on a Java binding document seems not to be very urgent.  
  The situation is very different for Python (which has seen the widest 
  uptake), where multiple incompatible implementations exist, and the 
  work to get them converge has been slow and tedious, despite being 
  (partially) done in the standardization space.  In all cases, however, 
  it is hard to distinguish if the lack of implementations causes the 
  lack of binding documents, or vice versa.
  
  It must be noted, however, that over the last 10 years, the work on
  the SAGA standard has been beneficial for the project for a
  multitude of reasons, not the least because it allowed to rally
  input, support and feedback from the community at-large, and because
  it served as a natural synchronization point and venue for the
  different organizations, consumers and contributors of the SAGA
  Project.

  \todo{shorten}

% \alnote{We need a redefinition of application. The "traditional"
% application that ran on people's desktop is still very present.
% Because of scale the usage mode of these applications did change,
% but it didn't change the application themselves.  They are in most
% cases still black boxes that take input and create input.
% Explicitly not distributed as a primary primitive.}


\subsection{Implementation}

  The SAGA-C++ reference implementation has been developed alongside
  GFD.90 from the time the first implementable version of the standard
  became available in 2005. Although SAGA C++ has been developed from
  scratch, it has strong conceptual ties to its predecessor, the GAT
  C libraries -- partly because of an overlap of developers, but also
  because the general GAT architecture seems to make perfect sense for
  SAGA like abstraction layers.
  % Loadable middleware \textit{adaptors}, chained error handling and
  % an \textit{advert service} API (which is not covered by GFD.90)
  % are just a few of the striking similarities.

  SAGA C++ aims to cover the whole spectrum of the standard and
  implements all API packages defined in GFD.90 and extensions
  (although some core features are still not fully implemented).
  However, practice has shown that the job, advert and the filesystem
  APIs are by far the most relevant packages in the broader user
  community.  This is why development efforts have mostly been
  focusing on these functionalities in respect to middleware adaptor
  development.  The broad deployment of SAGA C++ across national and
  international cyber-infrastructure and rising uptake by the user
  community, are mostly attributable to this. \msnote{Is internationally
  really true for the C++ implementation?}\amnote{Yes.} \ownote{How does this sentence even relate to the previous one???.} The remaining
  functionality of SAGA C++ has mostly been ignored in a general
  application context.  Generally, the existing C++ implementation has
  shown to be very robust and performant -- existing performance
  bottlenecks are either caused by middleware adaptors, or by the lack
  of support for asynchronous API modes.  
  
  The Python API layer which is implemented on top of the C++ core
  allows for quick prototyping and enables users who are not familiar
  with C++ to integrate the existing SAGA functionality into their
  applications.  The Python layer provides the users with the best of
  both worlds: speed and robustness of the underlying C++ core and
  flexibility of the Python layer -- for the price of portability, as
  the python layer here faces the same limitations as the C++
  implementation (see below).

  Both existing Java implementations (jSAGA and JavaSAGA) follow the
  same architecture as GAT/SAGA-C++, which works here just as well.
  Both Java implementations focus more on the mentioned main packages
  (advert, job, files), and do not implement the remaining packages
  (stream, replica and rpc) has not been a major criticism so far.
  There exists a Python layer on top of the Java implementations --
  its uptake has been minimal so far, and is mostly limited by the
  uptake of the Java implementations -- unfortunately, the Java
  implementations have not yet seen wide uptake, mostly due to support
  and sustainability limitations of the respective development groups.
  
  Despite of its noticeable uptake, we have registered a number of
  reoccurring points of criticism towards our C++ implementation.
  Current and potential users seem to be concerned with the following
  facts. 
  %
  (1) C++ which doesn't seem to be the predominant language of choice
  in the majority of distributed computing projects.
  % and rather inappropriate for quick prototyping.  \amnote{I am not
  % convinced that the above is a very valid point.}
  %
  (2) Due to it's strong dependencies on Boost and other C/C++
  libraries (depending on the adaptors used) and the complexity of its
  build system, SAGA is difficult to deploy, especially in user-space.
  %
  (3) Due to the complex structure of the C++ implementation and the
  extensive use of macros in the code, to the non-expert users, it
  seems to be impossible to debug or just understand certain errors
  when they occur.  \msnote{I would replace non-expert user by
  "original developer"} \amnote{That is a synonym? ;-)}
  %
  (4) The optional Python API layer on top of the C++ libraries partly
  addresses the first point, but inherits the complete installation
  and runtime complexity of the C++ implementation, which makes it
  somewhat clunky to use.

  \todo{shorten}


 \subsection{Higher Level Abstractions}

 % \ownote{Content suggestion: what has changed in respect to the
 % "retrospective". what has turned out to different than expected.}

 % \jhanote{This section name is rather broad.. but currently focusses
 % only on Community.. no point of having 1 subsubsection}

 % \subsubsection{The SAGA User Community (\todo{SJ})}

  Growth of users and data volumes is coming from communities that
  didn't even exists 10 years ago.\todo{elaborate or remove!}
 
  Several of the abstraction levels as developed by SAGA ended up not
  being used by the envisioned users.  Most importantly, the shift
  from job centric to data centric e-science is not well represented
  in SAGA (or in any distributed infrastructure in general).  Various
  higher level programming abstractions and application frameworks
  have thus been built on top of the SAGA API\footnote{note that the
  fact that underlying standards exist is still very valuable to
  create good higher level abstractions.}.  As a prominent example,
  the BigJob framework~\cite{saga_bigjob_condor_cloud}  provides a
  SAGA-based Pilot-Job implementation. The Pilot-Job abstraction has
  been shown to be effective in addressing many requirements of
  scientific applications.  Specifically, Pilot-Jobs support the
  decoupling of workload submission from resource assignment; this
  results in a flexible execution model, which in turn enables the
  distributed scale-out of applications on multiple and possibly
  heterogeneous resources. In contrast to SAGA BigJob, most other
  Pilot-Job implementations are tied to a specific infrastructure.
  BigJob has been successfully deployed in various scientific
  applications, e.\,g.\ in replica-exchange simulations, multi-physics
  simulations and genome sequencing.
\alnote{Should we relate this somehow back to applications that use these
higher-level abstractions?	}

\section{SAGA: The Road Ahead}
\label{sec:road}

 Panta Rhei ("Everything flows") -- that phrase is ever so true for
 human technology.\alnote{Is human technology a word we want to use here?}  
 The last decade has seen that confirmed for
 distributed computing as for any other field of computing or
 technology in general.  While it is notoriously hard and error prone
 to predict the future, we dare a biased and limited (aka focused)
 glimpse into the expected evolution of our specific area of interest:
 programming abstractions for distributed scientific computing. 


\subsection{Distributed Infrastructure, Levels of Abstraction} 

 % Before we can prophesize what the road ahead is...

 We regard the current move of DCI toward virtualized infrastructures
 with mixed feelings. \ownote{Whoever wrote this: This does NOT reflect 
 the opinion of all group members. PLEASE REMOVE.} Virtualization is obviously a promising
 approach to address the ever increasing heterogeneity (on all levels),
 and allows for dynamic system reconfiguration which has been dreamed
 of for many years.  But also, that evolution is coupled to a
 separation of concerns which we do not see fully positive: at least
 in the academic arena resource providers seem to refocus on lower
 levels of abstractions, and leave the configuration of the system,
 middleware and domain layers to the various user communities.  That
 reminds us of the times where the individual communities ran their
 own compute clusters, storage backends and application frameworks,
 often redundant but incompatible to the stacks of other communities.
 Perhaps some of the lessons of the past can be avoided, but it is
 also possible that some have to be relearned.

 Extremely interesting and compelling to us is the current evolution
 of more business oriented DCIs,  such as AWS, Azure and others, to
 provide programming abstractions and application patterns on
 middleware level.  For example, Amazon's AWS provides very
 accessible message queuing, which is otherwise very difficult to
 provide on an application level.  The higher level SaaS and PaaS
 approaches take that to a whole new level, but come with obvious
 interoperability problems.  We are very curious how the seemingly
 contradicting tendencies on academic and business DCIs will evolve in
 the next decade, as both seem very promising and sensible. \alnote{What would
 be an example of such a contradiction? Why should academic and business DCIs 
 not converge? AWS is in many things superior to FG.}


 % \todo{what is our opinion on DCI evolution, application evolution,
 %   etc?  Otherwise the discussion below does not have much context...}

 % Akin to SAGA being a metaphor for the evolution of Grids, it is fair
 % to say that SAGA will also be a representative of the evolution of
 % the future of Distributed Systems.


 % In that context it is important, however, to find the subtle yet
 % difficult trade-off between Re-active and Pro-Active SAGA
 % evolution, ``on-demand'' or ``in-response''. 
 %
 The SAGA project historically tried to find a balance between a
 reactive and proactive approach: while the initial GAT and SAGA API
 efforts have clearly been a reaction to end user demands, the SAGA
 evolution has also significantly been driven by the attempt to
 predict DCI evolution and cater to expected upcoming application
 programming paradigms.  
 %
 % For example, the SAGA Job API is reactively defined, and provides a
 % rendering of concepts which are well known in distributed
 % computing.  On the other hand, the SAGA Advert API is not directly
 % mappable to previously established concepts, but is rather an
 % expression of functionality which the SAGA project group
 % \I{expected} to be useful for its target application and user
 % community.
 %
 Within the above context, it is ever more important to try to find
 that balance.  We seem to have no choice but to follow the most
 prominent use cases -- but need to keep in mind the lessens learnt
 (see~\ref{sec:retro}).
 %
 % We expect that the SAGA project will continue to try to find that
 % balance, in the hope that the reactive components are sure to cater
 % to \I{real} (vs. expected or hyped) technology development, and
 % that the proactive components allow to stay close to the state of
 % the art, and to avoid to become fossilized.  It must be noted,
 % however, that in particular on implementation level, the proactive
 % component is often very hard to justify, and chronically suffers
 % from a lack of resources.
 

 On all trajectories, data-intensive applications are a major driver
 of future developments -- the volumes of data produced by scientific
 applications are increasing rapidly driven by advancing technologies
 (e. g. increasing computational capacities and higher resolution
 sensors) and decreasing costs for computation, data acquisition and
 storage.

 Extreme scales of data require novel abstractions. We will evolve
 SAGA and SAGA-based abstractions toward data-intensive applications
 supporting extreme data.  In~\cite{troy-2011}, we propose Pilot-Data
 (PD) as a first class abstraction to support big and dynamic data. PD
 is an extension of the well-known pilot-job abstraction very popular
 in both HPC and HTC environment to data-intensive computing.  Among
 many things PD facilitates the late binding of data and physical
 storage using so called pilot-stores.


 \subsection{SAGA Standard}

  SAGA seems to have a solid specification foundation, whose
  maintenance will focus on synchronization with other
  standardization efforts.  At the same time, we expect the
  standardization process to be useful for gathering community
  feedback, and to synchronize with some of the DCI communities and
  providers.  Beyond that, it is not obvious that continued production
  of standardized SAGA extensions will be useful before those
  extensions have been shown promise of implementation uptake and user
  adoption.  Along that lines, it is to be expected that the SAGA
  specification will be less limiting with its compliance
  implementations in the future, to allow for more agile partial
  implementations of the specifications, in many languages.


 \subsection{Implementations}

  The main characteristics of the existing C++ SAGA implementation is
  rooted in its extensibility - extensibility in breadth and width.
  Its modular design enables the creation of new functionality block
  while enabling a common user interface style.  At the same time it
  can be extended to support more middleware by implementing
  appropriate plugins - adaptors. These are the glue between the SAGA
  API and the underlying middleware. The existing C++ implementation
  provides a solid and performant foundation for a Python based SAGA
  API, which is widely used by application toolkits to build higher
  level abstractions.

  \begin{itemize}
   \item focus on usability rather than new features
   \item focus on Python-bindings + small set of heavily-used adaptors
   \item spawning of a new light-weight research prototype (outside 
         saga-C++/Python) that allows to quickly evaluate new ideas 
         and support for concepts outside the standard-scope (i.e., 
         support for data-intensive eScience)
  \end{itemize}

  % \hknote{I wouldn't completely dismiss the current C++
  % implementation just because we struggle with build-system and or
  % deployment problems. It seems to be a red herring to believe that
  % any other language might simplify any of those tasks. Let's rather
  % write about those problems and try to find ways to solve them.}

  \amnote{the above text is neither coherent, nor do I agree fully with
  it...}

  \alnote{bliss?}

% \subsection{SAGA: Abstractions for Distributed Programming and
% Development}

\section{Conclusions}

\msnote{IMHO, the real potential lies in the definition of SAGA as the
  SAGA community as a whole, across infrastructure, language,
  implementation, etc.  It could even be argued to bring Sylvain on
  board to stress this.}

\jhanote{Mark: Good point. We should include his work for sure, even
  if for practical (viz. time) reasons we can't have him onboard, but
  I'd be open to having him be an author too if he can make
  contribution on the timescales required}


\label{sec:sum}






\newpage

\section{\B{from earlier notes:}}


 \subsection{ SAGA Project Roadmap:}

 % instead of prediction, discuss actual trends or
 % options/parameters (role of standards, role of virtualization,
 % role of access layers) 
 % 
 % how should SAGA respond to change in data paradigm

 \subsection{ evolution of DCI $>>>$ influence on SAGA project}
 \subsubsection{ evolution of Grids, Clouds (\todo{SJ, AM})}
 \subsubsection{ evolution of middlewares (\todo{AM})}
 \subsubsection{ evolution of national / international infrastructures (\todo{SJ})}

 "Three Worlds", the US, Europe and "the rest".  In Europe, in the
 last decade the model has changed from a centrally managed Grid to a
 real on national borders distributed Grid.\\

 
 \nind
 \subsection{ evolution of communities  $>>>$ influence on SAGA project}
 \subsubsection{ evolution of applications (\todo{AL, SM, MS})}
 
 Basically no real evolution at all. Although much research has gone
 into programming paradigms for distributed computing, little of that
 runs in production.
 
 \subsubsection{ evolution of app domains (\todo{AL, SJ, MS})}
 
 New science domains, which different kind of characteristic.
 Combination of simulations and data analysis. A lot of progress in
 science fields that create high volumes of data.  Data, data, data.
 More tight coupling to systems from the science domain.
 
 \subsubsection{ evolution of usage modes (\todo{AL, SJ})}
 
 Research moved to desks. Data analysis has became even more than 10
 years ago a primary task of researchers.  Data analysis in more
 phases of research cycle, see e-science paradigm.  Semantics.
 Provenance and reproducible science.
  
 \subsubsection{ evolution of project contributions (\todo{SM, OW})}
 
 \subsubsection{ evolution of programming abstractions (level) (\todo{SJ, AL, MS})}
 
 No real uptake of distributed applications, but much progress on glue
 layers to link legacy applications together.  Implicit
 parallelization on data input.


\newpage

\todo{DCI: Compute Infrastructure vs. Cyber Infrastructures}

\footnotesize
\bibliographystyle{unsrt}
%plain}
\bibliography{saga,saga-related}

\end{document}

