\documentclass{article}

\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{subfigure}  
\usepackage[usenames,dvipsnames]{color}
\usepackage{srcltx}
\usepackage{url}
\usepackage{ifpdf}
\usepackage{xspace}
\usepackage[small,it]{caption}

\ifpdf
 \usepackage{hyperref}
%\usepackage[hpdftex]{hyperref}
\else
 \usepackage[hypertex]{hyperref}
\fi

\newenvironment{shortlist}{
  \vspace*{-0.5em}
  \begin{itemize}
  \setlength{\itemsep}{-0.3em}
}{
  \end{itemize}
  \vspace*{-0.5em}
}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\smilie}{\small;-)~\xspace}

\newcommand{\nind}{\noindent}
\newcommand{\todo}[1]{{\textcolor{red}{\B{TODO:} #1 }}}

\newif\ifdraft
\drafttrue
\ifdraft
 \newcommand{\jhanote}[1]{{\textcolor{red}{     \B{Shantenu:} #1 }}}
 \newcommand{\amnote}[1]{{\textcolor{green}{   \B{AndreM:  } #1 }}}
 \newcommand{\alnote}[1]{{\textcolor{blue}{    \B{AndreL:  } #1 }}}
 \newcommand{\ownote}[1]{{\textcolor{Brown}{   \B{Ole:     } #1 }}}
 \newcommand{\smnote}[1]{{\textcolor{Mulberry}{\B{Sharath: } #1 }}}
 \newcommand{\msnote}[1]{{\textcolor{magenta}{ \B{Mark:    } #1 }}}
 \newcommand{\hknote}[1]{{\textcolor{red}{  \B{Hartmut: } #1 }}}
\else
 \newcommand{\jhanote}[1]{}
 \newcommand{\amnote}[1]{}
 \newcommand{\alnote}[1]{}
 \newcommand{\ownote}[1]{}
 \newcommand{\smnote}[1]{}
 \newcommand{\msnote}[1]{}
 \newcommand{\hknote}[1]{}
\fi


\usepackage{ifpdf}
\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\up}{\vspace*{-1em}}

\begin{document}

\begin{center}
 {\Large SAGA -- The Next Decade}
\end{center}

{
 {
  \centering
  Shantenu Jha$^{12}$,
  Hartmut Kaiser$^{25}$
  Andre Luckow$^{2}$,\\
  Sharath Maddineni$^{2}$,
  Andre Merzky$^{2}$,
  Mark Santcroos$^{4}$,
  Ole Weidner$^{23}$
  \\[0.4em]
  }
 \noindent
 \tiny
 $^1$ Rutgers University\\[-1.0em]
 $^2$ Center for Computation and Technology, Louisiana State University\\[-1.0em]
 $^3$ School of Informatics, University of Edinburgh \\[-1.0em]
 $^4$ Bioinformatics Laboratory, Academic Medical Center, University of Amsterdam\\[-1.0em]
 $^5$ Department of Computer Science, Louisiana State University\\[-1.0em]
}

\begin{abstract}

  % "Never let the future disturb you. You will meet it, if you have to,
  % with the same weapons of reason which today arm you against the
  % present."  -- Marcus Aurelius Antoninus, 'Meditations' 
  
  The SAGA Project (as described below) has grown over time and
  evolved with \I{`the infrastructure'}. In this paper, we provide
  a retrospective (an analysis of where we are, and why), as well as
  a forward looking evolution and growth trajectory for our project.
  The purpose of this paper is to place SAGA in the past and future
  evolution of computing infrastructures, but also, to help us to
  consolidate the SAGA Project.

\end{abstract}


\section{Introduction \& Scope }
\label{sec:intro}

We (as in the authors of this paper and colleagues) have been trying
to enrich and support activities in the area or distributed computing
(DC) for the past decade, most notably by defining and implementing
the Simple API for Grid Applications (SAGA)\footnote{Note that SAGA
itself is about 6 years old -- however, we have been working on the
same problem space for much longer -- in particular we should mention
the Grid Application Toolkit (GAT) which we consider to be
a predecessor for SAGA.  In this context, we use the sole term SAGA as
simplification, as a representation of an idea.}, which spawned an
interesting and agile ecosystem of distributed programming
abstractions.
 
At the same time, the hurdles for application and framework developers
to efficiently utilize DC infrastructures (DCI) are still significant,
and many of the complaints voiced by those communities do not differ
very much from what we heard a decade ago, when they initially
prompted our Grid Application Toolkit activities in the GridLab
project.  That naturally prompts serious questions on both what we
managed to accomplish so far, but also, possibly more importantly, one
what we will attempt to accomplish in the future -- as only by now we
seem to really begin to understand what we are actually trying to
achieve.  
 
For this discussion, we loosely define \I{The SAGA Project} as a set
of efforts and people who (i) work on and with the SAGA API
specifications\ref{saga-core,ogf-specs}, to (ii) provide
implementation of that API\ref{saga-c++,jsaga,javasaga}, and to (iii)
provide higher level programming abstractions and application
development frameworks, based on those API
implementations\ref{bigjob,saga-www-projects}.  

In the following, we will shortly recapture and analyze the history
and current state of those three efforts (sec.~\ref{sec:retro}).  We
will further discuss the extrinsic influences for our project
evolution, such as the evolution of distributed systems and
applications (sec.~\ref{sec:state}).  We will also discuss the future
potential of the SAGA project along three axes: standardization,
implementation, and integration.  Finally in sec.~\ref{sec:road} we
attempt to draft our way over the decade to come, which we hope will
allow us to move forward with a clearer aim than we managed so far.

 % Define what we mean by the SAGA Project (i) SAGA - the standard,
 % incl. relation to other specs, (ii) SAGA the implementation --
 % engine, bindings, adaptors, packaging, testing and deployment, (iii)
 % SAGA the distributed programming and development paradigm (bigjob,
 % DAG-based, DARE)


\section{Retrospective}
\label{sec:retro}

 Ten years are almost an eternity in academic software development,
 and (almost) only successful software projects can look at that long
 of a history.  Or very stubborn ones~\smilie  This section will
 recapture the history of SAGA, discuss some of the extrinsic
 influences on the SAGA API evolution, and present some lessons we
 learned over that period.

 \subsection{SAGA Standardization}

  The Grid Application Toolkit was one of the prominent software
  deliverables of the GridLab project~\ref{gridlab}, and was designed
  to support the development of novel distributed application use
  cases for grid environments.  Together with other similar efforts in
  the Grid application community, it prompted the attempt to create
  a standardized, uniform and stable application programming interface
  for developing distributed (Grid) applications -- the OGF SAGA
  working and research group has been the focal point of that effort,
  and numerous projects and groups participated in the early
  evolution of the SAGA API.  

  It is hard to judge how much of the success of SAGA can be
  contributed to the fact that it is an standard -- but without doubt
  that has been a compelling argument for DCI providers to consider
  support for SAGA.  It is thus unexpected and unsatisfying that this
  support has not been able to trickle down to the actual
  infrastructure software layers, which are best positioned to
  actually support SAGA implementations.  A lesson to be learned from
  DRMAA, for example, is that an early participation of the middleware
  providers may have helped -- but that runs diametrically to the
  application driven approach of SAGA.  It is not clear to us if and
  how how that contradiction can be solved.

  The API standard itself has seen multiple implementations, and solid
  (but not overwhelming) support from different implementer groups all
  over the world.  While the agility aspect of the standardization
  process likely needs reconsideration, the stability aspect and the
  support for acceptance should not be underestimated.


 \subsection{Distributed Applications Landscape}

  The effort to provide a Simple API for Distributed Applications
  (which 10 years ago mostly meant grid applications, hence SA\BI{G}A)
  was mostly driven by the perceived need for such an API for
  programmers of scientific applications: those applications were
  expected to evolve into genuine 1st principle distributed
  applications~\ref{gat-motivation}.  Although the GAT and other
  similar high level APIs were available very early, they were not of
  a software quality and could not offer the level of support to
  instigate wider adoption in the community.  Also, the definition and
  implementation of the SAGA API took much longer than anticipated --
  and the application and DCI landscape continued to evolve, towards
  virtualized infrastructures, higher level services, novel
  coordination patterns, etc.
  
  During that time, the original target scope for SAGA almost
  disappeared -- we have not seen as many 1st principle distributed
  environments, or make use of distributed lover level infrastructures
  in some other way, has been increasing steadily.  In relation to
  that, the distributed infrastructure itself has taken some of the
  functionality which previously was thought to be exclusive to the
  applications (see PaaS and SaaS, but also higher level Grid
  services, portals, gateways and runtime frameworks).

  Over the last years, we have thus seen not as much adoption of SAGA
  as an application programming tool, but much more often as a vehicle
  to provide programming abstractions (MapReduce, PilotJob,
  MasterWorker etc) and application frameworks (portals, gateways,
  workflows etc).


 \subsection{API Scope}

  SAGA's scope has partially been driven by a number of proprietary
  Grid APIs which all seemed to provide very similar semantics in many
  different and sometimes unfriendly ways: submitting and managing
  jobs, moving and reading remote data files, etc.  SAGA has been
  successful where we managed to capture those aspects for the
  majority of the use cases -- OTOH, it has not seen significant
  uptake for many functional aspects which we assumed important, but
  obviously where not (data streaming, RPC, checkpoint management).
  Some of those aspects were rooted in legacy models of distributed
  computing, some were possibly not rendered simply enough, or not
  explicit enough -- we do not know the exact reasons.  On a bottom
  line we had to learn how hard it is to anticipate end user adoption
  based on a finite set of use cases -- one has to live with that, and
  be able to cope with evolving application requirements.

  Some aspects of the API have been used very widely, and have been
  proven to be conceptually useful even if not explicitly required
  initially -- in particular the advert API as means to coordinate
  distributed application components has been serving a real need.

  In summary we think that the current scope of the API may be too
  wide in some aspects, but may also be too static and too slowly
  evolving in other aspects -- which is to somewhat contradictory (but
  real), and also has consequences for the generally slow
  standardization process of the API.


 \subsection{Production Distributed Cyber Infrastructures}

  We have seen that application frameworks on the one (upper) end, and
  application oriented DCI capabilities on the (lower) end, have
  increasingly and successfully been used by our target community over
  the past years -- several semantic aspects which the SAGA API was to
  provide towards application programmers are nowadays provided by
  other layers, often in a way which is fairly accessible to
  applications.  Where those higher level concepts provided by DCIs
  are not easily accessible to applications, SAGA had a hard time to
  follow the DCI evolution and to build upon those capabilities, or to
  incorporate them into its scope.  Much of that lagging-behind is
  though simply caused by a lack of resources -- for an academia
  driven project it is very hard to come up with resources to address
  the continuous evolution of a software product (to sustain it).  But
  also, hindsight is 20:20 -- it is of course not always possible to
  anticipate which of the many evolutionary strands will prove to be
  useful and thus worth adopting.


%\subsection{Middleware, Tools and Development Frameworks}
%
% \todo{complete or remove}


\section{State of Affairs}
\label{sec:state}

 While the SAGA project has been evolving in the background of
 applications and production infrastructures (as discussed above), it
 has also been evolving in its internal structure, due to intrinsic
 aspects of the project.  This section describes the current structure
 of the project, and its intrinsic setup and boundary conditions.

 \subsection{SAGA Standard}

  Over the last decade, the state of the SAGA API specifications
  (plural, as we refer to the SAGA Core API specification and multiple
  extensions) have matured sufficiently enough that we are confident
  that they are not a limiting factor of our current evolution.  OTOH,
  multiple extensions have been specified due to real or perceived
  needs and requirements, but have not yet been implemented nor shown
  to effectively address the current DCI challenges.  Unless there is
  a more globally coordinated approach to future API specification
  work, there seems not too much value in expanding the set of SAGA
  specification documents -- apart from tangential benefits such as
  gaining public feedback, or formalizing concepts which are yet
  unclear or nebulous.

  The SAGA language binding specifications are a somewhat different
  story: there exists no C++ language binding document, but also only
  one C++ implementation, so the value of a document is not
  immediately clear.  There exist no Java language specification, but
  two implementations which use the same API, so again work on a Java
  binding document seems not to be very urgent.  The situation is
  different for Projectython (which has seen the widest uptake), were
  multiple incompatible implementations exist, and the work to get
  them converge has been slow and tedious, despite being (partially)
  done in the standardization space.  In all cases, however, it is
  hard to distinguish if the lack of implementations causes the lack
  of binding documents, or vice versa.
  
  It must be said that over the last 10 years, the work on the SAGA
  standard has been beneficial for the project for a multitude of
  reasons, not the least because it allowed to rally input, support
  and feedback from the community at-large, and because it served as a
  natural synchronization point and venue for the different
  organizations, consumers and contributors of the SAGA Project.

  \todo{shorten}

% \alnote{We need a redefinition of application. The "traditional"
% application that ran on people's desktop is still very present.
% Because of scale the usage mode of these applications did change,
% but it didn't change the application themselves.  They are in most
% cases still black boxes that take input and create input.
% Explicitly not distributed as a primary primitive.}

 \subsection{Applications, Community and Infrastructure}

  \ownote{Content suggestion: what has changed in respect to the
  "retrospective". what has turned out to different than expected.}

 \subsubsection{The SAGA User Community (\todo{SJ})}

  Growth of users and data volumes is coming from communities that
  didn't even exists 10 years ago.
 
 
  Several of the abstraction levels as developed by SAGA ended up not
  being used by the envisioned users.  Higher level of abstractions
  were ultimately developed to address that\footnote{note that the
  fact that underlying standards exist is still very valuable to
  create good higher level abstractions.}.  Most importantly, the
  shift from job centric to data centric e-science is not well
  represented in SAGA (or in any distributed infrastructure in
  general).


 \subsection{Implementation}

  The SAGA-C++ reference implementation has been developed alongside
  GFD.90 from the time the first implementable version of the standard
  became available in 2005. Although SAGA C++ has been developed from
  scratch, it has strong conceptual ties to its predecessor, the GAT
  C libraries -- partly because of an overlap of developers, but also
  because the general GAT architecture seems to make perfect sense for
  SAGA like abstraction layers.
  % Loadable middleware \textit{adaptors}, chained error handling and
  % an \textit{advert service} API (which is not covered by GFD.90)
  % are just a few of the striking similarities.

  SAGA C++ aims to cover the whole spectrum of the standard and
  implements all API packages defined in GFD.90 and extensions.
  However, practice has shown that the job, advert and the filesystem
  APIs are by far the most relevant packages in the broader user
  community.  This is why development efforts have mostly been
  focusing on these functionalities in respect to middleware adaptor
  development.  The broad deployment of SAGA C++ across national and
  international cyber-infrastructure and rising uptake by the user
  community, are mostly attributable to this. The remaining
  functionality of SAGA C++ has mostly been ignored in a general
  application context.  Generally, the existing C++ implementation has
  shown to be very robust and performant -- existing performance
  bottlenecks are either caused by middleware adaptors, or by the lack
  of support for asynchronous API modes.  
  
  The Python API layer which is implemented on top of the C++ core
  allows for quick prototyping and enables users who are not familiar
  with C++ to integrate the existing SAGA functionality into their
  applications.  The Python layer provides the users with the best of
  both worlds: speed and robustness of the underlying C++ core and
  flexibility of the Python layer -- for the price of portability, as
  the python layer here faces the same limitations as the C++
  implementation (see below).

  Despite of SAGA's noticeable uptake, we have registered a number of
  reoccurring points of criticism towards the C++ implementation.
  Current and potential users seem to be concerned with the following
  facts. 
  %
  (1) SAGA is written in C++ which doesn't seem to be the predominant
  language of choice in the majority of distributed computing projects
  and rather inappropriate for quick prototyping.  \amnote{I am not
  convinced that the above is a very valid point.}
  %
  (2) Due to it's strong dependencies on Boost and other C/C++
  libraries (depending on the adaptors used) and the complexity of its
  build system, SAGA is difficult to deploy, especially in user-space.
  %
  (3) Due to the complex structure of the C++ implementation and the
  extensive use of macros in the code, to the non-expert users, it
  seems to be impossible to debug or just understand certain errors
  when they occur.
  %
  (4) The optional Python API layer on top of the C++ libraries partly
  addresses the first point, but inherits the complete installation
  and runtime complexity of the C++ implementation, which makes it
  somewhat clunky to use.

  \todo{shorten}


 \subsubsection{Higher Level Abstractions}

  Various programming abstractions and application frameworks have
  been built on top of the SAGA API.  As a prominent example, the
  BigJob framework~\cite{saga_bigjob_condor_cloud}  provides
  a SAGA-based Pilot-Job implementation. The Pilot-Job abstraction has
  been shown to be an effective abstraction to address many
  requirements of scientific applications.  Specifically, Pilot-Jobs
  support the decoupling of workload submission from resource
  assignment; this results in a flexible execution model, which in
  turn enables the distributed scale-out of applications on multiple
  and possibly heterogeneous resources. In contrast to SAGA BigJob,
  most other Pilot-Job implementations however, are tied to a specific
  infrastructure. BigJob has been successfully deployed in various
  scientific applications, e.\,g.\ in replica-exchange simulations,
  multi-physics simulations and genome sequencing.


\section{The Road Ahead}
\label{sec:road}

 "Panta Rhei" -- that phrase is ever so true for human technology.
 The last decade has seen that confirmed for distributed computing as
 for any other field of computing or technology in general.  While it
 is notoriously hard and error prone to predict the future, we dare
 a biased and limited (aka focused) glimpse into the expected
 evolution of our specific area of interest: programming abstractions
 for distributed scientific computing. 

 \todo{what is our opinion on DCI evolution, application evolution,
 etc?  Otherwise the discussion below does not have much context...}

 % Akin to SAGA being a metaphor for the evolution of Grids, it is fair
 % to say that SAGA will also be a representative of the evolution of
 % the future of Distributed Systems.


 \todo{re-include a shortened version of the trade-off between
 Re-active and Pro-Active evolution.}

%Subtle yet difficult trade-off between Re-active and Pro-Active
%evolution, ``on-demand'' or ``in-response''.

% \subsection{Re-Active versus Pro-Active Evolution \todo{AM}}
% \jhanote{this needs to be reduced to one or two sentence at most}
% \todo{AM}

% The SAGA project historically tried to find a balance between a
% reactive and proactive approach: while the initial GAT and SAGA API
% efforts have clearly been a reaction to end user demands, the SAGA
% evolution has also significantly been driven by the attempt to predict
% DCI evolution and cater to expected upcoming application programming
% paradigms.  For example, the SAGA Job API is reactively defined, and
% provides a rendering of concepts which are well known in distributed
% computing.  On the other hand, the SAGA Advert API is not directly
% mappable to previously established concepts, but is rather an
% expression of functionality which the SAGA project group \I{expected}
% to be useful for its target application and user community.

%   \todo{How to reconcile pro-active APIs with reality later on?  See
%   advert API $->$ redis/nosql; message API $->$ amqp, amazon queues
%   etc.}
  
%   We expect that the SAGA project will continue to try to find that
%   balance, in the hope that the reactive components are sure to cater
%   to \I{real} (vs. expected or hyped) technology development, and that
%   the proactive components allow to stay close to the state of the
%   art, and to avoid to become fossilized.  It must be noted, however,
%   that in particular on implementation level, the proactive component
%   is often very hard to justify, and chronically suffers from a lack
%   of resources.


 \subsection{SAGA Standard}

  SAGA seems to have a solid specification foundation, whose
  maintenance will focus on synchronization with other
  standardization efforts.  At the same time, we expect the
  standardization process to be useful for gathering community
  feedback, and to synchronize with some of the DCI communities and
  providers.  Beyond that, it is not obvious that continued production
  of standardized SAGA extensions will be useful before those
  extensions have been shown promise of implementation uptake and user
  adoption.  Along that lines, it is to be expected that the SAGA
  specification will be less stringent with its compliance
  implementations in the future.


 \subsection{Implementation}

  The main characteristics of the existing C++ SAGA implementation is
  rooted in its extensibility - extensibility in breadth and width.
  Its modular design enables the creation of new functionality block
  while enabling a common user interface style.  At the same time it
  can be extended to support more middleware by implementing
  appropriate plugins - adaptors. These are the glue between the SAGA
  API and the underlying middleware. The existing C++ implementation
  provides a solid and performant foundation for a Python based SAGA
  API, which is widely used by application toolkits to build higher
  level abstractions.

  \begin{itemize}
   \item focus on usability rather than new features
   \item focus on Python-bindings + small set of heavily-used adaptors
   \item spawning of a new light-weight research prototype (outside 
         saga-C++/Python) that allows to quickly evaluate new ideas 
         and support for concepts outside the standard-scope (i.e., 
         support for data-intensive eScience)
  \end{itemize}

  % \hknote{I wouldn't completely dismiss the current C++
  % implementation just because we struggle with build-system and or
  % deployment problems. It seems to be a red herring to believe that
  % any other language might simplify any of those tasks. Let's rather
  % write about those problems and try to find ways to solve them.}

  \amnote{the above text is neither coherent, nor do I agree fully with
  it...}


 \subsection{SAGA: Abstractions for Distributed Programming and
 Development}

A major driver of future developments are data-intensive applications.The
volumes of data produced by scientific applications are increasing
rapidly driven by advancing technologies (e. g. increasing computational
capacities and higher resolution sensors) and decreasing costs for
computation, data acquisition and storage.

Extreme scales of data require novel abstractions. We will evolve SAGA
and SAGA-based abstractions, such as TROY, toward data-intensive
applications supporting extreme data. In~\cite{troy-2011}, we propose
Pilot-Data (PD) as a first class abstraction to support big and dynamic
data. PD is an extension of the well-known pilot-job abstraction very
popular in both HPC and HTC environment to data-intensive computing.
Among many things PD facilitates the late binding of data and physical
storage using so called pilot-stores.



\section{Conclusions -- Distributed Programming in the Next Decade}
\label{sec:sum}


\newpage

\section{\B{from earlier notes:}}


 \subsection{ SAGA Project Roadmap:}

 % instead of prediction, discuss actual trends or
 % options/parameters (role of standards, role of virtualization,
 % role of access layers) 
 % 
 % how should SAGA respond to change in data paradigm

 \subsection{ evolution of DCI $>>>$ influence on SAGA project}
 \subsubsection{ evolution of Grids, Clouds (\todo{SJ, AM})}
 \subsubsection{ evolution of middlewares (\todo{AM})}
 \subsubsection{ evolution of national / international infrastructures (\todo{SJ})}

 "Three Worlds", the US, Europe and "the rest".  In Europe, in the
 last decade the model has changed from a centrally managed Grid to a
 real on national borders distributed Grid.\\

 
 \nind
 \subsection{ evolution of communities  $>>>$ influence on SAGA project}
 \subsubsection{ evolution of applications (\todo{AL, SM, MS})}
 
 Basically no real evolution at all. Although much research has gone
 into programming paradigms for distributed computing, little of that
 runs in production.
 
 \subsubsection{ evolution of app domains (\todo{AL, SJ, MS})}
 
 New science domains, which different kind of characteristic.
 Combination of simulations and data analysis. A lot of progress in
 science fields that create high volumes of data.  Data, data, data.
 More tight coupling to systems from the science domain.
 
 \subsubsection{ evolution of usage modes (\todo{AL, SJ})}
 
 Research moved to desks. Data analysis has became even more than 10
 years ago a primary task of researchers.  Data analysis in more
 phases of research cycle, see e-science paradigm.  Semantics.
 Provenance and reproducible science.
  
 \subsubsection{ evolution of project contributions (\todo{SM, OW})}
 
 \subsubsection{ evolution of programming abstractions (level) (\todo{SJ, AL, MS})}
 
 No real uptake of distributed applications, but much progress on glue
 layers to link legacy applications together.  Implicit
 parallelization on data input.


\newpage

\todo{DCI: Compute Infrastructure vs. Cyber Infrastructures}

\footnotesize
\bibliographystyle{plain}
\bibliography{saga,saga-related}

\end{document}

