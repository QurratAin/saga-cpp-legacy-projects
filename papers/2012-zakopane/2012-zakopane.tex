\documentclass{article}

\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{subfigure}  
\usepackage[usenames,dvipsnames]{color}
\usepackage{srcltx}
\usepackage{url}
\usepackage{ifpdf}
\usepackage[small,it]{caption}

\ifpdf
 \usepackage{hyperref}
%\usepackage[hpdftex]{hyperref}
\else
 \usepackage[hypertex]{hyperref}
\fi

\newenvironment{shortlist}{
  \vspace*{-0.5em}
  \begin{itemize}
  \setlength{\itemsep}{-0.3em}
}{
  \end{itemize}
  \vspace*{-0.5em}
}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}

\newcommand{\nind}{\noindent}
\newcommand{\todo}[1]{{\textcolor{red}{\B{TODO:} #1 }}}

\newif\ifdraft
\drafttrue
\ifdraft
 \newcommand{\jhanote}[1]{{\textcolor{red}{     \B{Shantenu:} #1 }}}
 \newcommand{\amnote}[1]{{\textcolor{green}{   \B{AndreM:  } #1 }}}
 \newcommand{\alnote}[1]{{\textcolor{blue}{    \B{AndreL:  } #1 }}}
 \newcommand{\ownote}[1]{{\textcolor{Brown}{   \B{Ole:     } #1 }}}
 \newcommand{\smnote}[1]{{\textcolor{Mulberry}{\B{Sharath: } #1 }}}
 \newcommand{\msnote}[1]{{\textcolor{magenta}{ \B{Mark:    } #1 }}}
 \newcommand{\hknote}[1]{{\textcolor{red}{  \B{Hartmut: } #1 }}}
\else
 \newcommand{\jhanote}[1]{}
 \newcommand{\amnote}[1]{}
 \newcommand{\alnote}[1]{}
 \newcommand{\ownote}[1]{}
 \newcommand{\smnote}[1]{}
 \newcommand{\msnote}[1]{}
 \newcommand{\hknote}[1]{}
\fi


\usepackage{ifpdf}
\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\up}{\vspace*{-1em}}

\begin{document}

\begin{center}
 {\Large SAGA -- The Next Decade}
\end{center}

{
 {
  \centering
  Shantenu Jha$^{12}$,
  Hartmut Kaiser$^{25}$
  Andre Luckow$^{2}$,\\
  Sharath Maddineni$^{2}$,
  Andre Merzky$^{2}$,
  Mark Santcroos$^{4}$,
  Ole Weidner$^{23}$
  \\[0.4em]
  }
 \noindent
 \tiny
 $^1$ Rutgers University\\[-1.0em]
 $^2$ Center for Computation and Technology, Louisiana State University\\[-1.0em]
 $^3$ School of Informatics, University of Edinburgh \\[-1.0em]
 $^4$ Bioinformatics Laboratory, Academic Medical Center, University of Amsterdam\\[-1.0em]
 $^5$ Department of Computer Science, Louisiana State University\\[-1.0em]
}

\begin{abstract}

  % "Never let the future disturb you. You will meet it, if you have to,
  % with the same weapons of reason which today arm you against the
  % present."  -- Marcus Aurelius Antoninus, 'Meditations' 
  
  The SAGA Project (as described below) has grown over time and
  evolved with the ``infrastructure''. In this paper, we provide a
  retrospective -- an analysis of how where we are with respect to how
  and where would be, as well as a forward looking evolution and
  growth trajectory.  This paper is a summary of that process, and of
  our consolidation as a project.



\end{abstract}


\section{Introduction / Scope \todo{AM,SJ}}
\label{sec:intro}

%  as by now we really begin to understand what we
%  actually try to achieve.  
 
The SAGA Project --- is loosely defined as a set of
efforts and people who (i) work on and with the SAGA API
specifications, to (ii) provide implementation of that API, and to
(iii) provide higher level programming abstractions and application
development frameworks, based on those API implementations.  


In the following, we will shortly recapture the history and current
state of those three efforts (sec.~\ref{sec:retro}).  We will further
discuss our external boundary conditions for our project evolution,
such as the evolution of distributed systems and applications
(sec.~\ref{sec:state}).  Finally in sec.~\ref{sec:road} to draft our
way over the decade to come, which we hope will allow us to move
forward with a clearer aim than we managed so far.

 % Define what we mean by the SAGA Project (i) SAGA - the standard,
 % incl. relation to other specs, (ii) SAGA the implementation --
 % engine, bindings, adaptors, packaging, testing and deployment, (iii)
 % SAGA the distributed programming and development paradigm (bigjob,
 % DAG-based, DARE)




\section{Retrospective}
\label{sec:retro}

 \subsection{Distributed Applications}

  The original target scope for SAGA, however, almost disappeared --
  we have not seen as many 1st principle distributed applications as
  expected, by far.


 \subsection{Production Distributed CI}

  Instead, we have seen that application frameworks on the one (upper)
  end, and application oriented DCI capabilities on the (lower) end,
  have increasingly and successfully been used by our target community
  over the past years.


 \subsection{Middleware, Tools and Development Frameworks}


\alnote{Advert API: - How to reconcile an existing approach as advert
  api with the changing landscape?  Change of landscape in the last
  6-7 years - changed capabilities provided by companies (e.g. AWS,
  Google, Redis, ZeroMQ) - SAGA relationship in comparison to this
  commercial developments - trends in academia and commercial
  environments - original space: - developer of first principal
  applications - vs. framework developers - vs. usage in access layers
  (science gateways) - original space is occupied by infrastructure
  provider - nowadays with MR, Globus Online the level of abstraction
  much higher - infrastructure provider (such XSEDE) should run advert
  service Should one do a message api in place of the availability of
  a commercial solution?  - only very bad apis around current state of
  SAGA - whether Software is funded or not introduction \& scope -
  what is our saga project: api, implementation, framework talking
  about trends?  - trend toward standardization or opposite -
  unambiguous - role of virtualization in production distributed
  infrastructure - for what infrastructure should we harden our
  binding?  - if standards track is not attractive anymore, this has
  consequences to access layer - change in the role of data!  -
  consequence of of data - how should SAGA respond to the
  data-paradigm: - programming abstraction: pilot data - dynamic,
  distributed data }

SAGA as a metaphor for the evolution of Grids over the past 10 years.

We have been trying to enrich and support activities in that area for
the past decade, most notably by defining and implementing the Simple
API for Grid Applications (SAGA), which spawned an interesting and
agile ecosystem of distributed programming abstractions.

At the same time, the hurdles for application *users* and framework
coders are still significant, and many of the complaints voiced by
those communities do not differ very much from what we heard a decade
ago, when they initially prompted our Grid Application Toolkit
activities in the GridLab project.

With that background, we will try to discuss the roadmap for our SAGA
based activities, in respect to standardization, implementation, and
integration.  We will focus our discussion on three different aspects
of the SAGA landscape: the SAGA standardization

Subtle yet difficult trade-off between Re-active and Pro-Active
evolution, ``on-demand'' or ``in-response''.

% \subsection{Re-Active versus Pro-Active Evolution \todo{AM}}
% \jhanote{this needs to be reduced to one or two sentence at most}
% \todo{AM}

% The SAGA project historically tried to find a balance between a
% reactive and proactive approach: while the initial GAT and SAGA API
% efforts have clearly been a reaction to end user demands, the SAGA
% evolution has also significantly been driven by the attempt to predict
% DCI evolution and cater to expected upcoming application programming
% paradigms.  For example, the SAGA Job API is reactively defined, and
% provides a rendering of concepts which are well known in distributed
% computing.  On the other hand, the SAGA Advert API is not directly
% mappable to previously established concepts, but is rather an
% expression of functionality which the SAGA project group \I{expected}
% to be useful for its target application and user community.

%   \todo{How to reconcile pro-active APIs with reality later on?  See
%   advert API $->$ redis/nosql; message API $->$ amqp, amazon queues
%   etc.}
  
%   We expect that the SAGA project will continue to try to find that
%   balance, in the hope that the reactive components are sure to cater
%   to \I{real} (vs. expected or hyped) technology development, and that
%   the proactive components allow to stay close to the state of the
%   art, and to avoid to become fossilized.  It must be noted, however,
%   that in particular on implementation level, the proactive component
%   is often very hard to justify, and chronically suffers from a lack
%   of resources.


\section{State of the SAGA Project}
\label{sec:state}


\subsection{SAGA Standard}
%\subsection{SAGA: Abstractions for Distributed Programming and
  % Development}
 
  % state of the specification
  Over the last decade, the state of the SAGA API specifications
  (plural, as we refer to the SAGA Core API specification and multiple
  extensions) have matured sufficiently enough that we are confident
  that their evolution is not a limiting factor of our current
  evolution.  In fact, multiple extensions have been specified due
  real or perceived need and requirements, but have not yet been
  implemented nor shown to effectively address the current DCI
  challenges.  Unless there is a more globally coordinated approach to
  future API specification work, there seems not too much value in
  expanding the set of SAGA specification documents -- apart from
  tangential benefits such as gaining public feedback, or formalizing
  concepts which are yet unclear or nebulous.

  The SAGA language binding specifications are a somewhat different
  story: there exists no C++ language binding document, but also only
  one C++ implementation, so the value of a document is not
  immediately clear.  There exist no Java language specification, but
  to implementations which use the same API, so again work on a java
  binding document seems not to be very urgent.  The story is
  different for python, were multiple incompatible implementations
  exist, and the work to get them converge has been slow and tedious,
  despite being (partially) done in the standardization space.  In all
  cases, however, it is hard to distinguish if the lack of
  implementations cause the lack of binding documents, or vice
  versa...

  \jhanote{I??? This is bad style. Why are we reverting to first
    person?} I must be said that over the last 10 years, the work on
  the SAGA standard has been beneficial for the project for a
  multitude of reasons, not the least because it allowed to rally
  input, support and feedback from the community at-large, and because
  it served as a natural synchronization point and venue for the
  different organizations, consumers and contributors of The SAGA
  Project.


\subsection{}
 previous decade: what is state right now? (extrinsics)\\
 
state of DCI (software + hardware + provisioning + ...) (\todo{AM, SJ})\\
 
\jhanote{Whoever put the following comment below, please use the right
  approach. Its a note, not text, please use appropriate xnote macro} We need a
redefinition of application. The "traditional" application that ran on
people's desktop is still very present.  Because of scale the usage
mode of these applications did change, but it didn't change the
application themselves.  They are in most cases still black boxes that
take input and create input.  Explicitly not distributed as a primary
primitive.

 --- state / overview of user community (\todo{SJ})\\
 
 Growth of users and data volumes is coming from communities that
 didn't even exists 10 years ago.
 
 
 --- state of SAGA project in relation to/as caused by above (\todo{AM})

 The abstraction level as developed by GAT / SAGA ended up not being
 used by the envisioned users.  Higher level of abstractions were
 developed to cater for that. Note that the fact that underlying
 standards exist is still very valuable to create good higher level
 abstractions.

 More importantly, the shift from job centric to data centric
 e-science is not well represented in SAGA (or in any distributed
 infrastructure in general).

\subsection{Implementation}

The SAGA C++ reference implementation has been developed alongside GFD.90 from the time the first implementable version of the standard became available in 2005. Although SAGA C++ has been developed from scratch, it has strong conceptual ties to its predecessor, the Grid Application Toolkit (GAT) C libraries -- partly because of a strong overlap of developers. Loadable middleware \textit{adaptors}, chained error handling and an \textit{advert service} API (which is not covered by GFD.90) are just a few of the striking similarities. 
SAGA C++ aims to cover the whole spectrum of the standard and implements all API packages defined in GFD.90. However, practice has shown that the job, advert and the filesystem APIs are by far most relevant packages in broader user community. This is why development efforts have mostly been focusing on these functionalities in the form of new middleware adaptor development. The broad deployment of SAGA C++ across national and international cyber-infrastructure and rising uptake by the user community, are mostly attributable to this. Most of the remaining functionality of SAGA C++ has mostly been ignored in a general application context.
Despite of SAGA's noticeable uptake, we have registered a number of strong, reoccurring  points of criticism towards the C++ implementation. Current and potential users seem to be concerned with the following facts. (1) SAGA is written in C++ which doesn't seem to be the predominant language of choice in the majority of distributed computing projects and rather inappropriate for quick prototyping. (2) Due to it's strong dependencies on Boost and other C/C++ libraries and the complexity of its build system, SAGA is difficult to deploy, especially in user-space. (3) Due to the complexity of the C++ implementation and the many layers of indirection in the code, to the novice users, it seems to be impossible to debug or just understand certain errors when they occur. (4) The optional Python API layer on top of the C++ libraries partly addresses the first point, but inherits the complete installation and runtime complexity of the C++ implementation, which makes it clunky to use.

\subsection{SAGA: Abstractions for Distributed Programming and
  Development}

\subsubsection{Frameworks}

Various frameworks have been built on top of the SAGA API, e.\,g.\ the BigJob
framework~\cite{saga_bigjob_condor_cloud}, which provides a SAGA-based
Pilot-Job implementation. The Pilot-Job abstraction has been shown to be an
effective abstraction to address many requirements of scientific applications.
Specifically, Pilot-Jobs support the decoupling of workload submission from
resource assignment; this results in a flexible execution model, which in turn
enables the distributed scale-out of applications on multiple and possibly
heterogeneous resources. In contrast to SAGA BigJob, most other Pilot-Job
implementations however, are tied to a specific infrastructure. BigJob has 
been successfully deployed in various scientific applications, e.\,g.\ in 
replica-exchange simulations, multi-physics simulations and genome sequencing.


\section{SAGA: The Road Ahead}
\label{sec:road}

  "Panta Rhei" -- that phrase is ever so true for human technology.
  The last decade has seen that confirmed for distributed computing as
  for any other field of computing or technology in general.  While it
  is notoriously hard and error prone to predict the future, we dare a
  biased and limited (aka focused) glimpse into the expected evolution
  of our specific area of interest: programming abstractions for
  distributed scientific computing. 

  Akin to SAGA being a metaphor for the evolution of Grids, it is fair
  to say that SAGA will also be a representative of the evolution of
  the future of Distributed Systems.

\subsection{SAGA Standard}
\subsection{Implementation}

The main characteristics of the existing C++ SAGA implementation is rooted in its
extensibility - extensibility in breadth and width. Its modular design enables the
creation of new functionality block while enabling a common user interface style.
At the same time it can be extended to support more middleware by implementing
appropriate plugins - adaptors. These are the glue between the SAGA API and 
the underlying miiddleware. The existing C++ implementation provides a solid 
and performant foundation for a Python based SAGA API, which is widely used 
by application toolkits to build higher level abstractions.


 - focus on usability rather than new features\\
 - focus on Python-bindings + small set of heavily-used adaptors\\
 - spawning of a new light-weight research prototype (outside saga-C++/Python) that allows to quickly evaluate new ideas and support for concepts outside the standard-scope (i.e., support for data-intensive eScience)\\

\hknote{I wouldn't completely dismiss the current C++ implementation just because
  we struggle with build-system and or deployment problems. It seems to be a 
  red herring to believe that any othe rlanguage might simplify any of those 
  tasks. Let's rather write about those problems and try to find ways to solve them.}


 \nind
 - SAGA Project Roadmap:\\

 %   foreach (extrinsics)
 %   {
 %     vision of extrinsic evolution $>>>$ influence on our SAGA project
 %   }
 
 \nind

 "The only thing we know about the future is that it is going to be
 different." -- Peter Drucker, 'Management: Tasks,
 Responsibilities, Practices' (1973), Part 1, Chapter 4\\ 

 % instead of prediction, discuss actual trends or
 % options/parameters (role of standards, role of virtualization,
 % role of access layers) 
 % 
 % how should SAGA respond to change in data paradigm

 - evolution of DCI $>>>$ influence on SAGA project\\
 --- evolution of Grids, Clouds (\todo{SJ, AM})\\
 --- evolution of middlewares (\todo{AM})\\
 --- evolution of national / international infrastructures (\todo{SJ})\\

"Three Worlds", the US, Europe and "the rest".
In Europe, in the last decade the model has changed from a centrally managed Grid to a real on national borders distributed Grid.

 
 \nind
 - evolution of communities  $>>>$ influence on SAGA project\\
 --- evolution of applications (\todo{AL, SM, MS})\\
 
Basically no real evolution at all. Although much research has gone into programming paradigms for distributed computing, little of that runs in production.
 
 --- evolution of app domains (\todo{AL, SJ, MS})\\
 
 New science domains, which different kind of characteristic.
 Combination of simulations and data analysis. A lot of progress in science fields that create high volumes of data.
Data, data, data.
More tight coupling to systems from the science domain.
 
 --- evolution of usage modes (\todo{AL, SJ})\\
 
 Research moved to desks. Data analysis has became even more than 10 years ago a primary task of researchers.
 Data analysis in more phases of research cycle, see e-science paradigm.
Semantics.
Provenance and reproducible science.
  
 --- evolution of project contributions (\todo{SM, OW})\\
 
 --- evolution of programming abstractions (level) (\todo{SJ, AL, MS})\\
 
No real uptake of distributed applications, but much progress on glue layers to link legacy applications together.
Implicit parallellisation on data input.


\subsection{SAGA: Abstractions for Distributed Programming and
  Development}

Growing role of the importance of Data


\subsubsection{P* Abstractions}

\subsubsection{Abstractions for Data-intensive Applications}


\section{Conclusions -- distributed programming in the next decade}
\label{sec:sum}







\footnotesize
\bibliographystyle{plain}
\bibliography{saga,saga-related}

\end{document}

