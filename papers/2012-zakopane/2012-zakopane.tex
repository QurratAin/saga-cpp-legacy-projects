\documentclass{article}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{srcltx}
\usepackage{url}
\usepackage{ifpdf}
\usepackage{xspace}
\usepackage[usenames,dvipsnames]{color}

% \ifpdf
%  \usepackage[hpdftex]{hyperref}
% \else
%  \usepackage[hypertex]{hyperref}
% \fi

\newenvironment{shortlist}{
  \vspace*{-0.5em}
  \begin{itemize}
  \setlength{\itemsep}{-0.3em}
}{
  \end{itemize}
  \vspace*{-0.5em}
}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}


\newif\ifdraft
\drafttrue
\ifdraft
 \newcommand{\todo}[1]{{\textcolor{red}{\B{TODO:} #1 }}}
 \newcommand{\jhanote}[1]{{\textcolor{red}{     \B{Shantenu:} #1 }}}
 \newcommand{\amnote}[1]{{\textcolor{green}{   \B{AndreM:  } #1 }}}
 \newcommand{\alnote}[1]{{\textcolor{blue}{    \B{AndreL:  } #1 }}}
 \newcommand{\ownote}[1]{{\textcolor{Brown}{   \B{Ole:     } #1 }}}
 \newcommand{\smnote}[1]{{\textcolor{Mulberry}{\B{Sharath: } #1 }}}
 \newcommand{\msnote}[1]{{\textcolor{magenta}{ \B{Mark:    } #1 }}}
 \newcommand{\hknote}[1]{{\textcolor{red}{  \B{Hartmut: } #1 }}}
\else
 \newcommand{\todo}[1]{}
 \newcommand{\jhanote}[1]{}
 \newcommand{\amnote}[1]{}
 \newcommand{\alnote}[1]{}
 \newcommand{\ownote}[1]{}
 \newcommand{\smnote}[1]{}
 \newcommand{\msnote}[1]{}
 \newcommand{\hknote}[1]{}
\fi


\usepackage{ifpdf}
\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\dn}{ \vspace*{+1.0em}}
\newcommand{\dnn}{\vspace*{+0.5em}}
\newcommand{\up}{ \vspace*{-1.0em}}
\newcommand{\upp}{\vspace*{-0.5em}}
\newcommand{\shift}{\hspace*{1em}}
\newcommand{\sshift}{\hspace*{0.11em}}

\begin{document}

\begin{center}
 {\Large 
   Understanding Distributed Applications: A SAGA Perspective
 }\\[1em]
 {\footnotesize
   Shantenu Jha\footnotemark[1]$^{235}$,
   Hartmut Kaiser$              ^{25 }$
   Andre Luckow$                ^{2  }$,\\
   Sharath Maddineni$           ^{2  }$,
   Andre Merzky$                ^{2  }$,
   Mark Santcroos$              ^{42 }$,
   Ole Weidner$                 ^{23 }$
   \footnotetext[1]{
        Rutgers University,~~
    $^2$CCT, Louisiana State Univ.,~~
    $^3$School of Informatics, Univ. of Edinburgh,~~\\
    \sshift\shift
    $^4$Bioinformatics Lab., AMC, Univ. of Amsterdam,~~
    $^5$Dep. of Computer Science, Louisiana State Univ.\\
    }
  }
\end{center}
   

\up

\begin{abstract}

 The SAGA Project has grown over time and evolved with the infrastructure,
 trends and the successes and failures of the distributed computing and
 e-Science community as a whole. We take this opportunity to provide
 a retrospective -- an analysis of where the SAGA project is and why, as well as
 a prognosis on its likely evolution and growth trajectory. The evolution of
 SAGA is strongly tied to the evolution of distributed applications and systems
 and can in turn be used to understand their evolution. The purpose of this
 paper is to 
 % AM: we are not talking about it - elaborate that point in the saga paper:
 % explore SAGA as a metaphor for distributed applications, 
 introspect and analyze the evolution of SAGA, and predict its road ahead.

\end{abstract}

%\begin{center}
  %\footnotesize{\bf{\it ``If you don't know where you are coming from,
  %    you cannot know where you are going. \\ And if you don't know
  %    where you are going, any road will take you there.''  \\
  %    -- Private communication, anonymous and with one of the
  %   authors}}
%\end{center}

%\ifdraft
%\tableofcontents
%\fi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction \& Scope }
\label{sec:intro}

 Over the past decade, we have been engaged in the intellectually
 challenging, yet novel and rich pursuit of enabling scientific
 applications to utilize distributed cyberinfrastructure. The Simple API
 for Grid Applications (SAGA) -- the common uniting approach and
 underlying theme of our efforts -- was conceived in the gap arising
 from missing distributed programming abstractions.  SAGA represents
 a comprehensive community effort led by the authors to bridge this gap.

 The aim of this paper is two-fold: it aims (i) to understand the
 evolution of SAGA as a function of technology, community and
 infrastructure trends and evolution, and (ii) to understand the
 evolution of distributed applications through the prism of SAGA.  For
 this discussion, we loosely define `the \I{SAGA Project}' as the set of
 efforts and people who, (i) work on/with the SAGA API
 specifications\cite{ogf-gfd-90}, who (ii) provide implementations of
 the SAGA API~\cite{Kaiser:2006qp,jsaga,javasaga}, and (iii) who provide
 higher-level programming abstractions and application frameworks based
 on the SAGA API\cite{bigjob_cloudcom10,fresh-dag-escience,Sehgal2011590}.

 In the following, we will shortly recap and analyze the history and
 current state of these three efforts (sec.~\ref{sec:retro}
 and~\ref{sec:state}). In that context, we will also discuss the
 external factors that influenced the evolution of our project, such as
 the evolution of distributed systems and applications.  In
 sec.~\ref{sec:road} we draw up a draft for a possible evolution of SAGA
 and the field of distributed applications in general, where we will
 explore the future potential of the SAGA project along three axes:
 standardization, implementation, and integration.
 
 % have been enrichening and support activities in the area of e-Science
 % and distributed computing (DC) for the past decade, most notably by
 % defining and implementing the Simple API for Grid Applications
 % (SAGA), which spawned an interesting and agile ecosystem of
 % distributed programming abstractions.  \footnote{Note that SAGA
 % itself is about 6 years old -- however, we have been working on the
 % same problem space for much longer -- in particular we should mention
 % the Grid Application Toolkit (GAT) which we consider to be
 % a predecessor for SAGA.  In this context, we use the sole term SAGA
 % as simplification, as a representation of an idea.}

 % At the same time, the hurdles for application and framework
 % developers to efficiently utilize DC infrastructures (DCI) are still
 % significant, and many of the complaints voiced by those communities
 % do not differ very much from what we heard a decade ago, when they
 % initially prompted our Grid Application Toolkit activities in the
 % GridLab project.  That naturally prompts serious questions on both
 % what we managed to accomplish so far, but also, possibly more
 % importantly, one what we will attempt to accomplish in the future --
 % as only by now we seem to really begin to understand what we are
 % actually trying to achieve.  
 
 % We (as in the authors of this paper and colleagues) have been trying
 % to enrich and support activities in the area of e-Science and
 % distributed computing (DC) for the past decade, most notably by
 % defining and implementing the Simple API for Grid Applications
 % (SAGA), which spawned an interesting and agile ecosystem of
 % distributed programming abstractions.  \footnote{Note that SAGA
 % itself is about 6 years old -- however, we have been working on the
 % same problem space for much longer -- in particular we should mention
 % the Grid Application Toolkit (GAT) which we consider to be
 % a predecessor for SAGA.  In this context, we use the sole term SAGA
 % as simplification, as a representation of an idea.}

 % At the same time, the hurdles for application and framework
 % developers to efficiently utilize DC infrastructures (DCI) are still
 % significant, and many of the complaints voiced by those communities
 % do not differ very much from what we heard a decade ago, when they
 % initially prompted our Grid Application Toolkit activities in the
 % GridLab project.  That naturally prompts serious questions on both
 % what we managed to accomplish so far, but also, possibly more
 % importantly, one what we will attempt to accomplish in the future --
 % as only by now we seem to really begin to understand what we are
 % actually trying to achieve.  

 % Define what we mean by the SAGA Project (i) SAGA - the standard,
 % incl. relation to other specs, (ii) SAGA the implementation --
 % engine, bindings, adaptors, packaging, testing and deployment, (iii)
 % SAGA the distributed programming and development paradigm (bigjob,
 % DAG-based, DARE)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Retrospective}
\label{sec:retro}

 This section captures the history of SAGA, discusses some of the
 extrinsic influences on the SAGA API evolution, and presents some
 lessons we learned over that period.  

 % Ten years are almost an eternity in academic software development,
 % and (almost) only successful software projects can look at that long
 % of a history.  Or very stubborn ones.

 \subsection{Production Distributed Cyber Infrastructures}

  The effort to provide a Simple API to develop Distributed Applications
  (which a decade ago mostly meant grid applications, hence SA\BI{G}A)
  was mostly driven by the perceived need for such an API for
  programmers of scientific applications: those applications were
  expected to evolve into genuine first principle distributed
  applications~\cite{gat}.  That evolution of grid applications was
  heavily influenced if not guided (or constrained) by the evolution of
  the grid infrastructure; there was a bifurcation into narrow grids
  (such as iVDGL and Grid3, precursors to the OSG) and general purpose
  grids (such as Distributed Terascale Facility, UK NGS).

  Historically the first grid applications on 'general-purpose' grids
  were distributed analogues of legacy high-performance computing (HPC)
  applications~\cite{dpagrid2009}. In contrast, applications on the
  narrow grids predating the OSG had a less ``static'' resource
  utilization model; there existed a decoupling between application
  workloads and specific resources\cite{boinc}.

  It has been observed that over the past decade very few
  scalable applications have emerged that were designed with 
  distribution as first-class design objective. Interestingly,
  over the last years, SAGA has been used more to develop
  tools and frameworks rather than the end-user scientific program,
  i.e., SAGA has been used much more often to develop abstractions such
  as PilotJob, MasterWorker frameworks, and other application frameworks
  (gateways, simple pipelines and workflows etc).

  However the number of applications that use distributed infrastructure
  have made modest gains; this in turn could be related to the fact that
  some of the distributed infrastructure itself has taken on
  functionality which previously was thought to be exclusive to the
  applications (see PaaS and SaaS, but also grid services,
  portals/gateways and runtime frameworks). \todo{}\alnote{shall we
  define or reference a definition of PaaS/SaaS?}\jhanote{Yes} This is
  consistent with the notion that for distributed/grid systems
  ``programming the infrastructure'' has been as important as
  programming the application.

  \BI{Lesson i:} \I{Infrastructure evolves in unexpected directions  on all
  levels.}

  \amnote{possibly address evolution of DCIs towards large
  national/international infrastructures - relevant?}


 \subsection{Distributed Applications and Programming Abstractions}

  We have seen that application frameworks on the one (upper) end, and
  application oriented DCI capabilities on the other (lower) end, have
  increasingly and successfully been used by our target community over
  the past years -- several semantic aspects which the SAGA API was to
  provide towards application programmers are nowadays provided by other
  layers, often in a way which is fairly accessible to applications.
  For example, several DCIs strive to provide asynchronous and persisten
  message queues, which are an excellent tool for coordinating
  distributed application components.  Where such higher level concepts
  were not provided by DCIs, or were not easily accessible to
  applications, SAGA had a hard time to follow the DCI evolution and to
  build upon those capabilities, or to incorporate them into its scope.
  Much of that lagging-behind is though simply caused by a lack of
  resources -- for an academia driven project it is very hard to come up
  with resources to address the continuous evolution of a software
  product (to sustain it).  But also, hindsight is 20:20 -- it is of
  course not always possible to anticipate which of the many
  evolutionary strands will prove to be useful and thus worth
  adopting.\\
  %
  \BI{Lesson iv:} 

  % \I{It is costly to be agile. It is also costly not to have 20:20
  %   foresight.} \jhanote{This is a weak if not ambigious lesson.}

  \jhanote{A DCI is known by the hardware/software environment, the
  tools \& services it provides and finally the policies. All these go
  to determine the set of applications and usage-modes supported by
  a DCI. Let us therefore base our discussion around: (i) Middleware
  stack has been poorly delivered/managed, e.g., different layers not
  deeply or vertically integrated, (ii) grid concept/visions were
  peddled but the policies were never delivered, e.g., co-scheduling,
  (iii) middleware and policies been inconsistent across different DCI
  (iv) inability to provide a complete or end-to-end usage...}
  
  \jhanote{Important to distinguish between 2.1 and 2.2 on one hand and
  2.3/2.4 on the other, in that I don't think we need to explicitly talk
  about SAGA too much in 2.1/2.2, for it is a retrospective on the
  landscape in which SAGA evolved.. not on SAGA itself}


 \subsection{SAGA Standardization}

  The Grid Application Toolkit was one of the prominent software
  deliverables of the GridLab project~\cite{gridlab}, and was designed
  to support the development of novel distributed application use cases
  for grid environments.  Together with other similar efforts in the
  grid application community, it prompted the attempt to create
  a standardized, uniform and stable application programming interface
  for developing distributed (grid) applications -- the OGF SAGA working
  and research group has been the focal point of that effort, and
  numerous projects and groups participated in the early evolution of
  the SAGA API.  

  The evolution and trajectory of SAGA was thus influenced by
  participation in GGF/OGF~\cite{ogf_web}.  OSG for example did not and
  does not philosophically adhere to community standards, which amongst
  others shows in the HPC focus of the SAGA API scope. Had applications
  developers/users from the OSG been encouraged to engage with the OGF
  and thereby SAGA the outcome and design decisions would no doubt have
  been different.

  It is hard to judge how much of the success of SAGA can be contributed
  to the fact that it is a standard -- but without doubt that has been
  a compelling argument for DCI providers to consider support for SAGA.
  It is thus unexpected and unsatisfying that this support has not been
  able to trickle down to the actual infrastructure software providers,
  which are best positioned to actually support SAGA implementations.
  A lesson to be learned from DRMAA~\cite{drmaa}, for example, is that
  an early participation of the middleware providers may have helped --
  but that runs diametrically to the \I{application} driven approach of
  SAGA.  It is not clear if and how how that contradiction can be
  solved.

  The API standard itself has seen multiple implementations, and solid
  (but not overwhelming) support from different implementer groups.
  While the agility aspect of the standardization \I{process} likely
  needs some reconsideration, the SAGA approach to provide a base
  (\I{`core`}, and to allow for variable focused API extensions, seems
  to address the flexibility concerns of the API semantics resonably
  well.  The API stability the SAGA standardization enforces and its
  support for SAGA's acceptance by DCIs should not be underestimated.\\
  %
  \BI{Lesson iii:} \I{It is very hard to balance agility and stability
  of abstractions.}


 \subsection{The SAGA API Scope, Implementation, Community}

  SAGA's scope has partially been driven by a number of proprietary grid APIs
  which all seemed to provide very similar semantics in many different and
  sometimes unfriendly ways: submitting and managing jobs, moving and reading
  remote data files, etc.  SAGA has been successful where it managed to capture
  those aspects for the majority of the use cases -- but also, SAGA has not seen
  significant uptake for many functional aspects which were assumed important,
  but obviously where not (data streaming, RPC, checkpoint management).  Some of
  those aspects were rooted in legacy models of distributed computing, some were
  possibly not rendered simply enough, or not explicit enough -- the exact
  reasons are not obvious -- it simply is hard to anticipate end user adoption
  based on a finite set of use cases, one has to be able to cope with evolving
  application requirements.

  Interstingly, some aspects of the API \I{not} explicitly requested initially
  have been used very widely, and have been proven to be conceptually useful.
  In particular the advert API, used to coordinate distributed application
  components. seems to serve a real need.

  Summarily, the current scope of the API may be too wide in some aspects, but
  may also be too static and too slowly evolving in other aspects -- which is
  somewhat contradictory, and is also conflicting with the generally slow
  standardization process of the API.\\
  %
  \BI{Lesson ii:} \I{Use cases appear and disappear with high frequency; use
  cases are never complete.  Abstractions thus need to be agile.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Current State of Affairs}
\label{sec:state}

 \ownote{Content suggestion: what has changed in respect to the
 "retrospective". what has turned out to different than expected.}

While the SAGA project has been evolving in the background of
applications and production infrastructures (as discussed above), it
has also been evolving in its internal structure, due to intrinsic
aspects of the project.  This section discusses the current structure
of the project, and its intrinsic setup and boundary conditions.

\todo{we do not yet talk about the project setup and boundary
  conditions.}


 \subsection{Production Distributed Cyber Infrastructures}
  
   \begin{itemize}
   \item Experiences from LEAD project: Infrastructure not ready for
     production usage
    \item There is a trend for distributed CI to support
      virtualization, for better or worse. We believe some aspects --
      such as better control over software environment will be
      beneficial. 
    \item For the first time (as far as we are aware) the possibility
      of using commercial clouds as production CI exists. This is
      indication of the fact (i) that they have made significant
      progress in the provisioning of resources, (ii) there exists a
      class of problems that are amenable to Clouds as provisioned,
      (iii) deficiencies of some kind with academic infrastructure.
      (iv) There is a need for base abstractions for distributed
      applications e.g., messaging service, distributed tables for
      coordination etc Reference~\cite{1542058}

    \end{itemize}

   Reference~\cite{dpa-pdci-tr}

\subsection{Distributed Applications and Programming Abstractions}

 \begin{itemize}
 \item Applications and Application developers not willing to
   undertake heroics of yore. Simplicity is key. Realization that the
   end-to-end integration is critical.
 \item no first-principle distributed programming
 \item Talk about Gateways as an increasingly important mode of
   access. 
 \item Workflow interoperability not a reality still. Why?
 \end{itemize}

 \subsection{SAGA Standardization}

  Over the last decade, the state of the SAGA API specifications
  (plural, as we refer to the SAGA Core API specification and multiple
  extensions) have matured sufficiently enough that we are confident
  that they are not a limiting factor of the current evolution.  But
  also, multiple extensions have been specified due to real or perceived
  needs and requirements, but have not yet been implemented, nor shown
  to effectively address the current DCI challenges.  Unless there is
  a more globally coordinated approach to future API specification work,
  there seems not too much value in expanding the set of SAGA
  specification documents -- apart from tangential benefits such as
  gaining public feedback, or formalizing concepts which are yet unclear
  or nebulous.

  The SAGA language bindings are somewhat different: there exists no C++
  language binding document -- but also only one C++ implementation, so
  the value of a document is not immediately clear.  There exist no Java
  language specification document either, but two implementations which
  use the same API, so again work on a Java binding document seems not
  to be urgent.  The situation is very different for Python (which has
  seen the widest uptake), where multiple (3) incompatible
  implementations exist, and the work to get them to converge has been
  slow and tedious.  In all cases, however, it is hard to distinguish if
  the lack of implementations causes the lack of binding documents, or
  vice versa.
  
  It must be noted that over the last 10 years, the work on the SAGA
  standard has been beneficial for the project for a variety of reasons,
  not the least because it allowed to rally input, support and feedback
  from the community at-large, and because that process served as
  a natural synchronization point and venue for the different
  organizations, consumers and contributors of the SAGA Project.


 \subsection{The SAGA API Scope, Implementation, Community}

  \todo{What is state of SAGA community?}

  Growth of users and data volumes is coming from communities that
  didn't even exists 10 years ago.\todo{elaborate or remove!}
 
  Several of the abstraction levels as developed by SAGA ended up not
  being used by the envisioned users.  Most importantly, the shift from
  job centric to data centric e-science is not well represented in SAGA
  (or in any distributed infrastructure in general).  Various higher
  level programming abstractions and application frameworks have thus
  been built on top of the SAGA API\footnote{note that the fact that
  underlying standards exist is still very valuable to create good
  higher level abstractions.}.  As a prominent example, the BigJob
  framework~\cite{saga_bigjob_condor_cloud}  provides a SAGA-based
  PilotJob implementation. The PilotJob abstraction has been shown to be
  effective in addressing many requirements of scientific applications.
  Specifically, PilotJobs support the decoupling of workload submission
  from resource assignment; this results in a flexible execution model,
  which in turn enables the distributed scale-out of applications on
  multiple and possibly heterogeneous resources. In contrast to SAGA
  BigJob, most other PilotJob implementations are tied to a specific
  infrastructure.  BigJob has been successfully deployed in various
  scientific applications, e.\,g.\ in replica-exchange simulations,
  multi-physics simulations and genome sequencing.

  The stability of the SAGA API, the increasing maturity of its
  implementation, and the (slowly) increasing community of contributors
  and users is just now prompting various large DCIs (TG/XSEDE, EGI) to
  become interested in SAGA as a stable and uniform access layer.  The
  current efforts of the SAGA Project focus toward that goal, which
  provides significant challenges to our community, in respect to
  deployment, documentation, user support, training, packaging
  etc. 

  \subsubsection{Implementation}

   The SAGA-C++ reference implementation has been developed alongside
   GFD.90 from the time the first implementable version of the standard
   became available in 2005. Although SAGA C++ has been developed from
   scratch, it has strong conceptual ties to its predecessor, the GAT
   C libraries -- undeniably partly because of an overlap of developers
   between both projects.

   SAGA-C++ aims to cover the whole spectrum of the standard and
   implements all API packages defined in GFD.90 and extensions.
   However, practice has shown that the job, advert and the filesystem
   APIs are by far the most used packages.  
   This is why development efforts have mostly been focusing
   on these functionalities in respect to middleware adaptor
   development. The remaining functionality of SAGA C++ has mostly 
   been ignored in a general application context.
     
   The Python API layer which is implemented on top of the C++ core
   allows for quick prototyping and enables users who are not familiar
   with C++ to integrate the existing SAGA functionality into their
   applications. While the Python layer provides speed and robustness 
   of the underlying C++ implementation, it also shares its limitations
   (see below). Alternative Python implementations of SAGA exist in 
   the form of a Python layer on top of jSAGA (Java) and a native Python
   implementation of SAGA called Bliss\cite{bliss_web}.

   %Both existing Java implementations (jSAGA and JavaSAGA) follow the
   %same architecture as GAT/SAGA-C++, which works here just as well.
   %Both Java implementations focus more on the mentioned main packages
   %(advert, job, files), and do not implement the remaining packages
   %(stream, replica and rpc) has not been a major criticism so far.
   
   %There exists a Python layer on top of the Java implementations -- its
   %ptake has been minimal so far, and is mostly limited by the uptake
   %f the Java implementations -- unfortunately, the Java
   %implementations have not yet seen wide uptake, mostly due to support
   %and sustainability limitations of the respective development groups.
  
   Despite of its noticeable uptake, we have registered a number of
   reoccurring points of criticism towards our C++ implementation:
   %
   (1) C++ doesn't seem to be the predominant language of choice
   in the majority of distributed computing projects.
   % and rather inappropriate for quick prototyping.  \amnote{I am not
   % convinced that the above is a very valid point.}
   %
   (2) Due to it's strong dependencies on Boost and other C/C++
   libraries (depending on the adaptors used) and the complexity of its
   build system, SAGA is difficult to deploy, especially in user-space.
   %
   (3) Due to the complex structure of the C++ implementation and the
   extensive use of macros in the code, code debugging and extension
   is exceptionally hard for the non-expert user.
   %
   (4) The Python API layer on top of the C++ libraries partly
   addresses the first point, but inherits the complete installation and
   runtime complexity of the C++ implementation, which makes it somewhat
   clunky to use.

% \alnote{We need a redefinition of application. The "traditional"
% application that ran on people's desktop is still very present.
% Because of scale the usage mode of these applications did change,
% but it didn't change the application themselves.  They are in most
% cases still black boxes that take input and create input.
% Explicitly not distributed as a primary primitive.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SAGA: The Road Ahead}
\label{sec:road}

 Panta Rhei ("Everything flows") -- that phrase is ever so true for
 human technology.\alnote{Is human technology a word we want to use here?}  
 The last decade has seen that confirmed for
 distributed computing as for any other field of computing or
 technology in general.  While it is notoriously hard and error prone
 to predict the future, we dare a biased and limited (aka focused)
 glimpse into the expected evolution of our specific area of interest:
 programming abstractions for distributed scientific computing. 


 \subsection{Production Distributed Cyber Infrastructures}

  % We regard the current move of DCI toward virtualized infrastructures with
  % mixed feelings. \ownote{Whoever wrote this: This does NOT reflect the opinion
  % of all group members. PLEASE REMOVE.} Virtualization is obviously a promising
  % approach to address the ever increasing heterogeneity (on all levels), and
  % allows for dynamic system reconfiguration which has been dreamed of for many
  % years.  But also, that evolution is coupled to a separation of concerns which
  % we do not see fully positive: at least in the academic arena resource
  % providers seem to refocus on lower levels of abstractions, and leave the
  % configuration of the system, middleware and domain layers to the various user
  % communities.  That reminds us of the times where the individual communities
  % ran their own compute clusters, storage backends and application frameworks,
  % often redundant but incompatible to the stacks of other communities.  Perhaps
  % some of the lessons of the past can be avoided, but it is also possible that
  % some have to be relearned.

  % Extremely interesting and compelling to us is the current evolution of more
  % business oriented DCIs, such as AWS, Azure and others, to provide programming
  % abstractions and application patterns on middleware level.  For example,
  % Amazon's AWS provides very accessible message queuing, which is otherwise very
  % difficult to provide on an application level.  The higher level SaaS and PaaS
  % approaches take that to a whole new level, but come with obvious
  % interoperability problems.  We are very curious how the seemingly
  % contradicting tendencies on academic and business DCIs will evolve in the next
  % decade, as both seem very promising and sensible. \alnote{What would be an
  % example of such a contradiction? Why should academic and business DCIs not
  % converge?  AWS is in many things superior to FG.}

  \todo{what is our opinion on DCI evolution, application evolution, etc?
  Otherwise the discussion below does not have much context...}

  The SAGA project historically tried to find a balance between
  a reactive and proactive approach: while the initial GAT and SAGA API
  efforts have clearly been a reaction to end user demands, the SAGA
  evolution is now significantly driven by the attempt to predict DCI
  evolution and cater to expected upcoming application programming
  paradigms. 
  % Within the above context, it is ever more important to try
  % to find that balance.  We seem to have no choice but to follow the
  % most prominent use cases -- but need to keep in mind the lessens
  % learnt (see~\ref{sec:retro}).
  %
  % We expect that the SAGA project will continue to try to find that
  % balance, in the hope that the reactive components are sure to cater
  % to \I{real} (vs.  expected or hyped) technology development, and
  % that the proactive components allow to stay close to the state of
  % the art, and to avoid to become fossilized.  It must be noted,
  % however, that in particular on implementation level, the proactive
  % component is often very hard to justify, and chronically suffers
  % from a lack of resources.
 
  \jhanote{Comment about SAGA vis-a-vis virtualization: IaaS, PaaS..}

 \subsection{Distributed Applications Landscape}
 
  On all trajectories, data-intensive applications are a major driver of
  future developments -- the volumes of data produced by scientific
  applications are increasing rapidly driven by advancing technologies
  (e. g. increasing computational capacities and higher resolution
  sensors) and decreasing costs for computation, data acquisition and
  storage.

  Extreme scales of data require novel abstractions. We will evolve SAGA
  and SAGA-based abstractions toward data-intensive applications
  supporting extreme data.  In~\cite{troy-2011}, we propose PilotData
  (PD) as a first class abstraction to support big and dynamic data. PD
  is an extension of the well-known PilotJob abstraction very popular in
  both HPC and HTC environment to data-intensive computing.  Among many
  things PD facilitates the late binding of data and physical storage
  using so called PilotStores.

 \subsection{SAGA Standardization}

  SAGA seems to have a solid specification foundation, whose maintenance
  will mostly focus on synchronization with other standardization
  efforts.  At the same time, we expect the standardization community to
  continue to provide community feedback, and to facilitate the
  synchronization with DCI communities and providers.  Beyond that, it
  is not obvious that continued production of standardized SAGA
  extensions will be useful before those extensions have been shown
  promise of implementation uptake and user adoption.  

  
 \subsection{The SAGA API Scope, Implementations, Community}

 \subsubsection{Implementations}

  From the C++ perspective, the main implementation challenges are
  software dependencies, ease of deployment, and portability.  The
  future developments will focus on those aspects, while balancing those
  with the ever increasing demands on user support and documentation.
  Finally, the SAGA-C++ implementation needs to prove it's agility in
  supporting new and higher level programming abstractions. 

  \todo{python, java, adaptors, higher levels...}

  %   The main characteristics of the existing C++ SAGA implementation is rooted
  %   in its extensibility - extensibility in breadth and width.  Its modular
  %   design enables the creation of new functionality block while enabling
  %   a common user interface style.  At the same time it can be extended to
  %   support more middleware by implementing appropriate plugins - adaptors.
  %   These are the glue between the SAGA API and the underlying middleware. The
  %   existing C++ implementation provides a solid and performant foundation for
  %   a Python based SAGA API, which is widely used by application toolkits to
  %   build higher level abstractions.

  %   \begin{itemize} \item focus on usability rather than new features \item
  %   focus on Python-bindings + small set of heavily-used adaptors \item
  %   spawning of a new light-weight research prototype (outside
  %   saga-C++/Python) that allows to quickly evaluate new ideas and support for
  %   concepts outside the standard-scope (i.e., support for data-intensive
  %   eScience) \end{itemize}

  % \hknote{I wouldn't completely dismiss the current C++
  % implementation just because we struggle with build-system and or
  % deployment problems. It seems to be a red herring to believe that
  % any other language might simplify any of those tasks. Let's rather
  % write about those problems and try to find ways to solve them.}

  \amnote{the above text is neither coherent, nor do I agree fully with it...}
  \jhanote{Removed ``boiler plate text'' for what a SAGA implementation should
  be like in our hopes.}

  \jhanote{(o)The road ahead is informed by experiences: (i) Need lightweight
  implementation (ii) Deployment and dependencies are real concerns}
    
  \alnote{bliss?}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions}
\label{sec:conclusions}

 \msnote{IMHO, the real potential lies in the definition of SAGA as the SAGA
 community as a whole, across infrastructure, language, implementation, etc.  It
 could even be argued to bring Sylvain on board to stress this.}

 \jhanote{Mark: Good point. We should include his work for sure, even if for
 practical (viz. time) reasons we can't have him onboard, but I'd be open to
 having him be an author too if he can make contribution on the timescales
 required}


% \newpage
% 
% \section{\B{from earlier notes:}}
% 
% 
%  \subsection{ SAGA Project Roadmap:}
% 
%  % instead of prediction, discuss actual trends or
%  % options/parameters (role of standards, role of virtualization,
%  % role of access layers) 
%  % 
%  % how should SAGA respond to change in data paradigm
% 
%  \subsection{ evolution of DCI $>>>$ influence on SAGA project}
%  \subsubsection{ evolution of Grids, Clouds (\todo{SJ, AM})}
%  \subsubsection{ evolution of middlewares (\todo{AM})}
%  \subsubsection{ evolution of national / international infrastructures (\todo{SJ})}
% 
%  "Three Worlds", the US, Europe and "the rest".  In Europe, in the
%  last decade the model has changed from a centrally managed grid to a
%  real on national borders distributed grid.\\
% 
%  
%  \subsection{ evolution of communities  $>>>$ influence on SAGA project}
%  \subsubsection{ evolution of applications (\todo{AL, SM, MS})}
%  
%  Basically no real evolution at all. Although much research has gone
%  into programming paradigms for distributed computing, little of that
%  runs in production.
%  
%  \subsubsection{ evolution of app domains (\todo{AL, SJ, MS})}
%  
%  New science domains, which different kind of characteristic.
%  Combination of simulations and data analysis. A lot of progress in
%  science fields that create high volumes of data.  Data, data, data.
%  More tight coupling to systems from the science domain.
%  
%  \subsubsection{ evolution of usage modes (\todo{AL, SJ})}
%  
%  Research moved to desks. Data analysis has became even more than 10
%  years ago a primary task of researchers.  Data analysis in more
%  phases of research cycle, see e-science paradigm.  Semantics.
%  Provenance and reproducible science.
%   
%  \subsubsection{ evolution of project contributions (\todo{SM, OW})}
%  
%  \subsubsection{ evolution of programming abstractions (level) (\todo{SJ, AL, MS})}
%  
%  No real uptake of distributed applications, but much progress on glue
%  layers to link legacy applications together.  Implicit
%  parallelization on data input.
% 
% 
% \newpage
% 
% \todo{DCI: Compute Infrastructure vs. Cyber Infrastructures}

 \clearpage
 \footnotesize
 \bibliographystyle{unsrt}
 \bibliography{saga,saga-related}

\end{document}

