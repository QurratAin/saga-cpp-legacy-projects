% $Header: /projects/VU-SAGA/Papers/saga_engine_2006/intro.tex,v 1.8 2006/08/13 18:01:00 hkaiser Exp $

  % Grid computing is commonly defined as distributed computing with a
  % focus on highly dynamic environments~\cite{CS_Foster01a,
  % CS_Foster02a}: any application running in grids therefore must be
  % aware of the volatile and dynamic nature of the environment. 
  The Simple API for Grid Applications (SAGA) is one of the most
  prominent recent developments allowing to make it easier to write
  applications leveraging the possibilities of grids, even for
  scientists having no background in computer science, or grid computing.
  
  The presented C++ implementation of the SAGA API is supposed to be
  used as a reference implementation during the OGF standardization
  process. It has a number of key features, which are described later
  in the text in more detail:

  \begin{itemize}
     
    \item Synchronous, asynchronous and task oriented versions of every
    operation are transparently provided.

    \item Dynamically loaded adaptors bind the API to the respective
    grid middleware environment, on runtime, but static pre-binding at link
    time is also supported.
          
    \item Adaptors are selected on a call-by-call basis (late
    binding), allowing for incomplete adaptors, and inherent fail
    safety. A generic object state repository supports the late binding.
    
    \item Latency hiding schemes such as asynchronous operations and bulk
    optimizations are generically and transparently integrated, even
    if not explicitly supported by the adaptors or the respective middleware.

		\item A modular API architecture allows to minimize the runtime 
		memory footprint.
		
    \item API extensions are greatly simplified by the encapsulation of a
    generic call routing mechanism, and by macros resembling the 
    Scientific Interface Description Language (SIDL) used in the 
    SAGA specification. 
    
    \item Strict adherence to Standard-C++ and the utilization of 
    Boost~\cite{boost_website} allows for excellent portability 
    and platform independence.

  \end{itemize}

  The remainder of the paper is structured as follows: the next
  section lists the main design objectives for our implementation.
  The realization of these objectives is then described in the
  following sections, including a more detailed description of the key
  features listed above.  We conclude with some observations we hope
  are useful for other API implementers, and shortly describe our
  future plans.
 


