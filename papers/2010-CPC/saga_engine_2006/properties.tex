% $Header: /projects/VU-SAGA/Papers/saga_engine_2006/properties.tex,v 1.14 2006/10/11 02:57:17 gallen Exp $

This section 
summarizes the properties of our SAGA implementation from an
end user perspective, gives an overview about the lessons learnt, and 
motivates further developments and extensions.


\subsection{Uniformity over Programming Languages}
\label{ssec:lang}

 The SAGA API specification is language independent. 
 One of the consequences of this is that it does not use templates,  which were thought too
 difficult to express uniformly over many languages.  Also, the
 specification tries to be concise about object state management, and
 hence also expresses semantics for shallow and deep copies.
 Our implementation follows the SAGA API specification closely. It is also
 designed to accommodate wrappers in other languages.
 A Python wrapper for our library is in
 alpha status, and we plan to add wrappers to provide
 bindings to C, FORTRAN, Perl, and possibly others. In the past we found it
 very useful to be able to write Python adaptors for the 
 GAT~\cite{gat}, a predecessor of SAGA,
 and we will provide similar support here as well.

\subsection{Genericity in Respect to Middleware, and
            Adaptability to Dynamic Environments}

 The dynamic nature of grid middleware 
 is addressed in our implementation 
 by the described adaptor mechanism which binds to diverse middleware.  
 Late binding, fall back mechanisms, and
 flexible adaptor selection allow for additional resilience against
 an dynamic and evolving run time environment.  
 Adaptors need to deploy mechanisms like resource
 discovery, and need to implement fully asynchronous operations, if
 the complete software stack is to be able to cope with dynamic grids.


\subsection{Modularity ensures Extensibility}

 Section~\ref{ssec:macros} described how  the SAGA
 implementation will be able to cope with the expected evolution and
 extension of the SAGA API.  The adaptor mechanism
 allows for easy extensions of the library, providing additional
 middleware bindings.  
 The task of adaptor writing
 requires massively more effort than the implementation of the
 presented library.
 Ideally, middleware vendors will 
 \I{implement} adaptors for SAGA, and deliver them
 as part of their client side software stack.
 This would be a major step towards wide spread grid applications.


\subsection{Portability and Scalability}

 Heterogeneous distributed systems naturally require por\-table code
 bases.  Our library implementation is very
 portable, as we strictly adhere to the C++ standard and portable 
 libraries.  We currently develop the library on Windows, Linux and MacOS 
 concurrently, covering three 
 major target platforms without any problems.
 However, the portability of our SAGA implementation
 depends on the portability of the adaptors, and hence on the portability 
 of the grid middleware client interfaces, being the much greater problem 
 if compared to the library code itself.

 Distributed applications are often sensitive to sca\-lability
 issues, in particular in respect to remote communications.  This equally 
 applies to SAGA, so that scalability concerns
 are naturally raised in respect to SAGA implementations as well.
 Even if the SAGA API is not targeting
 high performance communication schemes, but tries to stick to
 simple communication paradigms,
 our design allows for zero-copy implementations of the
 SAGA communication APIs, and for fast asynchronous
 notification on events -- both are deemed critical for implementing
 scalable distributed applications.  
 
\subsection{Simplicity for the End User}

 SAGA is \I{designed} to be simple.  However, simplicity 
 of an API is not only determined by its API specification, but also
 by its implementation: simple deployment and configuration,
 resilience against lower level failures, adaptability to diverse
 environments, stability, correctness, and peaceful coexistence with
 other programming paradigms, tools and libraries are some of the
 characteristics which need attention while implementing the SAGA API.  
 
 A modular implementation helps to keep a library implementation itself
 simple.
 Features as the generic call routing, or the adaptor selection are hidden 
 in the engine module.
 Modeling these central properties
 as modules increases the readability and maintainability of the code
 significantly.  

 Due to its notion of tasks the SAGA API implicitly introduces a concurrent 
 programming model.
 Our C++ language binding of the API, allows to combine
 that model with arbitrary mechanisms for managing concurrent program
 elements (thread safety, object state consistency, etc.).


