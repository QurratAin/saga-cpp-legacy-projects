It was very encouraging to note that (all five) reviewers universally
acknowledged the practical importance and relevance of the P* Model
and the Pilot-API.  These ranged from greater usability of tools,
impact on advanced scheduling and possible role in standardization.

In spite of the constructive suggestions and observations of the
reviewers, we strongly believe the following statements are factually
inaccurate in the reviews:

1. "It would however be a substantial improvement for the introduction
   to clearly define pilot jobs..."

The term Pilot-Job and concepts underlying Pilot-Jobs is introduced in
section 1. A formal definition is given in "terms and usage" in
section 2.

2. - "...though the goal of a unified system to integrate all pilot
     systems is a rather elusive problem...""

   - "In the end, the paper seems like a pilot job system for pilot job
   systems.""

   - "While the work seemed sound, I was unconvinced by the paper that
   another layer of indirection and abstraction was the right solution
   for connecting together pilot job systems.""

The aim of the Pilot-API is not to add another layer, but to help
validate the P* model and show that the elements and characteristics
of different PJ frameworks can be exposed via a unified API.  Also,
concurrent interoperability across PJ is a consequence of the
Pilot-API and not a primary aim. The paper would have been weaker had
we not shown the obvious (i.e. concurrent interoperability); however,
we reiterate the aim was to provide a *common* model to reason about
PJs, to provide an API that can be used to expose this model and map
it to different existing PJs, and not to "connect PJ" at an
implementation level.

3. "the Pilot-Data API, which more or less mimics the PilotJob API is
  not very convincing in the sense that the interaction between the
  2 APIs are not discussed at all." 

With the exception of the quoted reviewer, other reviewers agree that
extensions to Pilot-Data "is one of the more interesting features of
P*". The aim of this paper was to first establish and validate P*
along a dimension that is relatively well known: jobs. The above in
conjunction with space limitations are the reasons for limited
treatment of Pilot-Data (and its interaction with Pilot-Job API).  

4. "Perhaps another element which could strengthen the paper is a
   description, based on the authors analysis of pilot job systems,
   why pilot job systems cannot be unified in other ways."

Various approaches for interoperability exist, e.g. horizontal
vs. vertical interoperability and federation.  We briefly discuss
these approaches in section 4.1. A more detailed discussion has be
left out due to space constraints.

5. Performance-related remarks: 

	- "Unfortunately, the experimental results are not very
	    convincing.  Firstly, the overhead caused by
	    interoperability (P*) is not provided. And the introduced
	    overheads are critical in understanding if it is a
	    worthwhile approach."
	
	- "More metrics like traffic, slowdown, and job speedup are
	  needed to be measured to be convincing."
	
As stated, the aim of the experiments is to demonstrate the validity
of the P* model and not interoperability. We don't provide any numbers
on the API-layer overhead, because the call stack latency is typically
O(nano-seconds), whilst remote latency are order micro-seconds!  PJ
overhead experiments focus on analyzing the potential slowdown due to
coordination with increasing CUs (over 3 orders-of-magnitude), which
also capture agent overhead..

6. "Secondly, the demonstration of interoperability is overly
  simplified. For example, so of these pilot job systems were never
  meant to operate decoupled from their computational frameworks...
  "For example, Swift and Swift-Coasters were meant to work together."

Whereas we are in agreement with the reviewer, we go further and
believe this is a major limitation that lead to dozens of point
solutions in the past that lack extensibility and flexibility.  (As
stated in the paper: "Tools and implementations are often highly
dependent on and tuned to a specific execution environment, further
impacting portability, reusability and extensibility. Semantic and
interface incompatibility are certainly barriers, but so is the lack
of a common architecture and conceptual framework upon which to
develop similar tools a barrier.")

We acknowledge that the following is not a traditional response, but
we believe still an interesting and relevant one: As part of the
NSF-funded ExTENCI project there is a proposal and hopefully efforts
underway from the Swift team to integrate Swift with an implementation
of P*!!

