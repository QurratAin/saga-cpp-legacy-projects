I. Overview/Opening saying what we think is/are the unique
contribution(s) of the paper. [SJ]

II. Acknowledge short comings, and address how we will fix them. Does
not have been specific but could be high-level.  Important to point
out how in-spite of shortcomings main contributions as in I are not
undermined, i.e., shortcomings can be/will be fixed. (ie.  urge
shepherding). [SJ/AL]

- motivation for P* model: We will improve the motivation for section II.

- respectfully claim that TROY overhead have been addressed

- only covers Pilot-Jobs => future work: pilot-data, scheduling,
  etc. Application to data has never been done before

- no related work: we have references (<30% self-refs); section 4 is a
discussion of related work

- experiments Pilot-Data => future work

III. Address Specific comments, and either dispute or
acknowledge. Either way focus on how we will improve the individual
sections.

In turn, each section in III has two tracks: (i) why we agree/disagree
with specific comments, (ii) How we will improve individual sections,
either taking into account the referee remarks or of our own volition
(again making the case for shepherding).

Section 1: SJ
Section 2: AL
- provide a better motivation for P* model: It is important to understand 
properties and characteristics in order to map application requirements,
available infrastructure and PJ framework. Provide a simple API for the 
core functionality, hide the complexity of different PJ implementations.
- Describe the benefits of interoperability using a real-life scenario, 
e.g. XSEDE - EGI interoperability.
- highlight the sub-set of functionality of PJ frameworks that is exposed via 
TROY and give an example on what kind of functionality is hidden (different, 
complex resource specifications, specific initialization and termination
commands,...).

Section 3: MS 

Improve descriptions of TROY and PJ framework relationship and on how
TROY implements the P* characteristics.

TROY is an implementation of the P*-model, and therefore also "minimal
but complete" by design.  Reviewer C questions the incentive to
"implement everything over TROY" related to performance.  As TROY
builds on top of other systems, in the single backend scenario, one
should not expect a performance increase. We show that the performance
overhead is negligble though.  The real advantage in using TROY is the
concurrent execution of jobs on multiple pilot-job implementation
backends. We would like to explicitly mention that this also enables
the concurrent execution of jobs on (totally) different
infrastructures.  TROY will not "implement the characteristics" of the
various Pilot-Jobs, it rather exposes these characteristics in a
unified way, without the need to change an application when switching
infrastructure.

We take the comments from the reviewers as a sign that we need to
explain these benefits more clearly.

Section 4: OL

Section 5: AL (with MS and AM)
- extended evaluation of TROY overhead and break down to sub-components 
(startup time, coordination, ...)
- present experiments of PD

Section 6: AL
- present use cases (coupling data-compute, discovery, in-situ access, 
streaming) of PD (see D3MA)
- present API of PD
- present experiments of PD


Section 7: SJ

