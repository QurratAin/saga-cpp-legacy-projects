\subsection{Performance}\label{performance}

Although the performance and efficiency of a distributed application mostly depends on the employed programming models and patterns and their suitability for the underlying distributed infrastructure (a choice that can only be made by the developer), SAGA exposes certain performance characteristics and pitfalls that should be taken into consideration when developing distributed applications. Besides a negligible overhead generated by the Engine and its dynamic adaptor loading and selection mechanism (\ref{perf_engine}) SAGA's performance is governed by two major factors: The performance of the middleware adaptor implementations (\ref{perf_adaptors}) and the usage of SAGA's asynchronous interface and task-based operations (\ref{perf_async}). We carried out several benchmarks to pinpoint SAGA’s performance in a production-level environment.   We used an unmodified version of the current SAGA release (1.2.1) on various TeraGrid resources over an extended period of time (to filter out system noise) and where appropriate compared the results to the native middleware tools. In the following, we present our results and discuss their implications for application developers. 

\begin{figure}[!ht]
  \begin{center}
      \includegraphics[width=1\textwidth]{../figures/perf_overhead.pdf}
  \end{center}
 \up\up\up\up\up
  \caption{\small SAGA file operations. The first API invocation triggers the initialization and adaptor loading process. The three subsequent calls have virtually no overhead thanks to adaptor priorization. Call 5 to 7 iterate between two different adaptors to execute local (loc) and remote (rem) file copy which causes some adaptor selection overhead.}
 \label{perf_overhead}
\end{figure}

\subsubsection{Engine Performance}\label{perf_engine}
The selection of suitable adaptors to execute an API call at runtime is one of the key features of our C++ SAGA implementation. Naturally, it comes with a certain overhead since it involves several logical steps as depicted in Figure (1). On startup, the Engine parses its configuration file (saga.ini), loads all configured middleware adaptors (dynamic libraries) and registers their capabilities in an internal data structure. The overhead generated by this step varies with the number of configured adaptors but lies generally in the range of 30 milliseconds on an average system. 
If an API method is to be executed, the Adaptor Selector searches the internal adaptor registry for all Adaptors that could potentially execute the API call and tests them one by one.

Our experience with SAGA-based application shows that there’s a high probability that the same adaptor will be selected for many subsequent API calls. In fact, most applications use only one specific middleware Adaptor throughout their entire lifetime. The Engine addresses this by putting the adaptor that executed the last API call in the first position of the registry. This completely eliminates potential adaptor selection overhead for subsequent calls as depicted in Figure \ref{perf_overhead}. 




\subsubsection{Adaptor Performance}\label{perf_adaptors}

\subsubsection{Asynchronous Performance}\label{perf_async}
