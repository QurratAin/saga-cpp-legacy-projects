\documentclass{article}
\usepackage[left=3cm,top=2cm,right=3cm,nohead,nofoot]{geometry} 
\usepackage{setspace}

\title{Project 1:  OSP Scheduler}

\author{Michael Miceli}

\begin{document}
\maketitle
\doublespacing
%\begin{abstract}{\end{abstract}

\section{Overview}

I have implemented a scheduling algorithm for OSP.  My algorithm is priority-based using the length of the process as the main priority.  This is known as Shortest Job Next or Shortest Job First.  Another factor that goes into my priority is age.  As a process ages I increase its priority until it is run.  This ensures that a process does not starve for more than 7000 seconds.  Implementation-wise, the main data structure in my algorithm is a sorted queue.  Then, I use this sorted queue to keep track of the highest priority.  When OSP dispatches a new process, my algorithm adds the process back to the ready queue, and removes the head of the queue.

\section{Implementation}

\indent The sorted queue is the most fundamental part of my scheduler.  Every time an element is inserted into the queue, it is inserted in the correct order.  First, I assign the incoming PCB's priority to its size.  Then, I would traverse the queue using the PCB's prev and next variables and insert it into the correct position.  In my implementation a higher priority has higher precedence.  There is also a remove by pid function.  This is essential for removing a random process from a queue (cf. removing from the head).  If a process has aged sufficiently, then its priority must be changed in order to ensure it will be run soon.  Instead of moving pointers around, my algorithm simply reinserts the process; however, it must be removed first.

\section{Test}

\indent For testing purposes I reran my tests many times with different “magic numbers” in my code to maximize the scheduler.  Also, I made sure to only have one variable at a time.  However, this assumes that maximizing each variable independently will maximize the result, which I assume.  Mainly, I modified two different variables:  the aging and priority.  For aging, I ran tests evaluating how long the process' last dispatch time is be before increasing the process's priority.  The table for this variable is below.


\section{Graphs}

\begin{table}[ht]
\caption{Comparisons of last dispatch times}
\centering
\begin{tabular}{c c}
\hline\hline
Clock cycles waiting & Grade \\ [0.5ex]
\hline
1000 &  99.6100\% \\ 
2000 & -46.4800\% \\
3000 &  95.0400\% \\
4000 & -24.0500\% \\
5000 & 102.1900\% \\
6000 &  96.4100\% \\ [1ex]
\hline
\end{tabular}
\end{table}

\begin{table}[ht]
\caption{Comparisons of priority increase}
\centering
\begin{tabular}{c c}
\hline\hline
Priority increase & Grade \\ [0.5ex]
\hline
1000 &  102.1900\% \\ 
2000 & -152.1300\% \\
3000 &   95.8700\% \\
4000 &   84.8900\% \\
5000 &  102.3800\% \\
6000 &   97.4600\% \\ [1ex]
7000 &   94.8100\% \\ [1ex]
8000 &   98.6300\% \\ [1ex]
\hline
\end{tabular}
\end{table}

\section{Conclusion}

I believe that some of the anomalies in the tables (negative numbers) can be explained through an overall increase in priorities over all processes, which in turn removes the idea of aging completely.  No aging would have yielded 96.9100\%, but with many starving processes.  Consequently, this solution is unacceptable with a multiuser environment.  My best implementation was a priority increase of 5000 for the oldest process when its last dispatch time was greater than 5000 clock cycles.


\end{document}

