\section{The SAGA Library}

  This section describes the design and implementation of a dynamic library 
  that implements the SAGA interface described in the previous section.
  \thesagaimpl is a production-grade system that combines the concepts of SAGA
  with a versatile library and plug-in mechanism in order to provide a
  practical foundation for the development of distributed applications.

  \forhartmut{services vs. 'simple' library}

  \jhanote{a few opening words about the distinction between OS and
    RS.. and a few things about ``our'' RS}

  %%-------------------------------------------------------------------------%%
  \subsection{Design Assumptions} 
  \forole{What are the underlying assumptions that we made when we started to
  implement saga? Lay out landscape of production cyber-infrastructure! }

  

  %%-------------------------------------------------------------------------%%
  \subsection{Design Objectives}
  \forole{ Capabilities that must be supported - in terms of performance,
  capabilities, scalability, interoperability, ...}

  %%-------------------------------------------------------------------------%%
  \subsection{Design Approach and Architecture}

  \forhartmut{ PIMPL, etc., How it is Split up Late Binding, Why Boost?}
  \forhartmut{what's the philosophy from going from objective to implementatoin}

%  \begin{itemize}
 %\item  shallow copies --> pimpl
 %\item  lightweight copy
 %\item  remote state representation

 %\item  extensibility --> plugin
  %     \item reflecting API on adaptor level
  %    \item external separate libraries as adaptors
% \end{itemize}

% Design pattern: plugin, pimpl

  %%-------------------------------------------------------------------------%%
  
  \forole{This is were the BIG PICTURE goes and where we introduce concepts and
  terminologies, like "adaptor" "core", etc..}


  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{User Interface Layer (API)}
  \foroleandhartmut{What is this and how does it work?}
 
 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptor Interface (CPI)}
  \foroleandhartmut{Needs rewrite!}\\
  \forhartmut{instancedata, adaptordata, ... also good for cpidoc.saga.. ;-)}\\
  
  % what's an adaptor
  % why do we have adaptors?
  % mapping semantics CPI - backend API, often not one on one mapping
  % file copy: map SAGA semantics to Globus file copy operation semantics
  % adding latencies

  The CPI acts as both,
  a logical and a physical barrier between the SAGA Core and the Adaptors:
  logical because of a well defined programming interface and physical because
  it enforces the encapsulation of adaptor code in separate shared libraries.
  The CPI reflects the same class hierarchy and method names as the API. This
  is intuitive, since the adaptors are supposed to translate API calls
  one-to-one, to the underlying middleware systems. However, at the CPI level,
  the interface has been enriched with additional data structures that are not
  visible at the API level, as well as with a set of convenience functions and
  macros that can help the adaptor developer reduce the implementation overhead
  for parsing configuration files, logging, error handling and other repetitive
  and redundant tasks. Figure~\ref{fig:cpi-detail} provides deeper insight into
  SAGA's architecture at the CPI level and how adaptors interface with it. Even
  though this specific example focuses on the \texttt{job} package, it is
  representative for any other functional package in SAGA.
 
  % adaptor is dynamically linked and loaded module and its use is restricted by the OS defined limitations

  % adaptor is implementation of CPI interfaces for specific middleware
  % CPIs implemented depend on Middleware and reflect the semantics exposed by middleware

  % Combining CPIs in one adaptor allows for optimizations like state sharing, caching
 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{\thesagaimplrt Library}
  \foroleandhartmut{Adaptor selection, logging, mechanisms, error handling,... }


  %%%%---------------------------------------------------------------------%%%%
  \subsection{Python API Wrapper}
  \forole{What is this and how does it work?}\\
  \forhartmut{How and why do we use boost::python?}
  

  %%-------------------------------------------------------------------------%%
  \subsection{\thesagaimpladap (Plug-Ins)}
  \forole{Needs rewrite!}\\
   One of the most important design porperties in SAGA is its vertical
   extensibility at the so-called CPI (Capability Provider Interface) level.
   The CPI defines the boundary between the end-user \jhanote{at some point in
   the paper, relatively upstream, we'll have to define who in our model of an
   end-user is?} API and runtime (\textit{SAGA Core}) and the middleware
   bindings (\textit{SAGA Adaptors)}.  It allows system integrators to develop
   SAGA bindings for any underlying system without having to touch the SAGA
   Core implementation.  This concept fosters community involvement by
   providing a plug-in mechanism at the \jhanote{slightly awkward construct the
   next one:} system-integrator-level, but it also greatly contributes to the
   overall stability and robustness of the SAGA Core implementation by
   completely decoupling API and runtime layer from platform-specific
   implementation details. The effectiveness of the adaptor plug-in concept is
   certainly reflected in the growing list of middleware adaptors that have
   been developed to support a broad spectrum of distributed technologies. The
   following sections will introduce some of the concepts and details of the
   CPI as well as try to give a short, yet comprehensive overview of
   distributed computing technologies and systems supported by SAGA through
   middleware adaptors.

 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptors for Job Execution and Management} 
  \forole{intro + explicit example}


  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptors for Data Access and Management} 
  \forole{intro + explicit example}

  %%%%---------------------------------------------------------------------%%%%
   \subsubsection{More Adaptors}
   \forole{Whatever else is worth mentioning: streams, sd, ...}


  %%-------------------------------------------------------------------------%%
  \subsection{Measurements and Performance}
  
  In the previous sections we have extensively described the properties of
  \thesagaimpl and its three layer architecture: the interface (API) itself,
  the \thesagaimplrt and the \thesagaimpladap. It should be obvious to the
  reader that the implementation complexity of this architecture stack goes
  well beyond that of an API. An API in the classical sense is often tied to a
  specific underlying software system and its only purpose is to
  \textit{expose} a certain context-relevant portion of the underlying system
  to the user. This concept of exposure-only usually doesn't introduce any
  additional overhead to the overal performance characteristics of the system,
  since it doesn't entail any processing logic. In \thesagaimpl's case,
  performance implications are not as obvious because behind the API fa√ßade,
  \thesagaimpl employs dynamic concepts like late-binding and runtime adaptor
  selection. Furthermore, it enforces a predefined interface on CPI level which
  doesn't necessarily have to harmonize with the semantics exposed by the
  underlying middleware systems.

  In this chapter, we present a detailed description and analysis of a set of
  relevant performance measurements carried out with \thesagaimpl through its
  native C++ interface as well as the Python API wrapper. We conclude that the
  minimal overhead that is observable in \thesagaimpl can mostly  be neglected
  in a distributed systems context where long latencies are usually dominating
  the response time of a distributed applications.

  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Runtime-Selection and Late-Binding}

  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Python API Wrapper}
