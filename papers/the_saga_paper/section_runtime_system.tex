\section{The SAGA Library}

  This section describes the design and implementation of a dynamic library 
  that implements the SAGA interface described in the previous section.
  \thesagaimpl is a production-grade system that combines the concepts of SAGA
  with a versatile library and plug-in mechanism in order to provide a
  practical foundation for the development of distributed applications.

  \forhartmut{services vs. 'simple' library}

  \jhanote{a few opening words about the distinction between OS and
    RS.. and a few things about ``our'' RS}

  %%-------------------------------------------------------------------------%%
  \subsection{Design Assumptions} 
  \forole{What are the underlying assumptions that we made when we started to
  implement saga? Lay out landscape of production cyber-infrastructure! }

  

  %%-------------------------------------------------------------------------%%
  \subsection{Design Objectives}
  \forole{ Capabilities that must be supported - in terms of performance,
  capabilities, scalability, interoperability, ...}

  %%-------------------------------------------------------------------------%%
  \subsection{Design Approach and Architecture}

  \forhartmut{ PIMPL, etc., How it is Split up Late Binding, Why Boost?}
  \forhartmut{what's the philosophy from going from objective to implementatoin}

%  \begin{itemize}
 %\item  shallow copies --> pimpl
 %\item  lightweight copy
 %\item  remote state representation

 %\item  extensibility --> plugin
  %     \item reflecting API on adaptor level
  %    \item external separate libraries as adaptors
% \end{itemize}

% Design pattern: plugin, pimpl

  %%-------------------------------------------------------------------------%%
  
  \forole{This is were the BIG PICTURE goes and where we introduce concepts and
  terminologies, like "adaptor" "core", etc..}


  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{User Interface Layer (API)}
  \foroleandhartmut{What is this and how does it work?}
 
 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptor Interface (CPI)}
  \foroleandhartmut{Needs rewrite!}\\
  \forhartmut{instancedata, adaptordata, ... also good for cpidoc.saga.. ;-)}\\
  
  % what's an adaptor
  % why do we have adaptors?
  % mapping semantics CPI - backend API, often not one on one mapping
  % file copy: map SAGA semantics to Globus file copy operation semantics
  % adding latencies

  The CPI acts as both,
  a logical and a physical barrier between the SAGA Core and the Adaptors:
  logical because of a well defined programming interface and physical because
  it enforces the encapsulation of adaptor code in separate shared libraries.
  The CPI reflects the same class hierarchy and method names as the API. This
  is intuitive, since the adaptors are supposed to translate API calls
  one-to-one, to the underlying middleware systems. However, at the CPI level,
  the interface has been enriched with additional data structures that are not
  visible at the API level, as well as with a set of convenience functions and
  macros that can help the adaptor developer reduce the implementation overhead
  for parsing configuration files, logging, error handling and other repetitive
  and redundant tasks. Figure~\ref{fig:cpi-detail} provides deeper insight into
  SAGA's architecture at the CPI level and how adaptors interface with it. Even
  though this specific example focuses on the \texttt{job} package, it is
  representative for any other functional package in SAGA.
 
  % adaptor is dynamically linked and loaded module and its use is restricted by the OS defined limitations

  % adaptor is implementation of CPI interfaces for specific middleware
  % CPIs implemented depend on Middleware and reflect the semantics exposed by middleware

  % Combining CPIs in one adaptor allows for optimizations like state sharing, caching
 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Core Library}
  \foroleandhartmut{Adaptor selection, logging, mechanisms, error handling,... }


  %%%%---------------------------------------------------------------------%%%%
  \subsection{Python API Wrapper}
  \forole{What is this and how does it work?}\\
  \forhartmut{How and why do we use boost::python?}
  

  %%-------------------------------------------------------------------------%%
  \subsection{Middleware Adaptors (Plug-Ins)}
  \forole{Needs rewrite!}\\
   One of the most important design porperties in SAGA is its vertical
   extensibility at the so-called CPI (Capability Provider Interface) level.
   The CPI defines the boundary between the end-user \jhanote{at some point in
   the paper, relatively upstream, we'll have to define who in our model of an
   end-user is?} API and runtime (\textit{SAGA Core}) and the middleware
   bindings (\textit{SAGA Adaptors)}.  It allows system integrators to develop
   SAGA bindings for any underlying system without having to touch the SAGA
   Core implementation.  This concept fosters community involvement by
   providing a plug-in mechanism at the \jhanote{slightly awkward construct the
   next one:} system-integrator-level, but it also greatly contributes to the
   overall stability and robustness of the SAGA Core implementation by
   completely decoupling API and runtime layer from platform-specific
   implementation details. The effectiveness of the adaptor plug-in concept is
   certainly reflected in the growing list of middleware adaptors that have
   been developed to support a broad spectrum of distributed technologies. The
   following sections will introduce some of the concepts and details of the
   CPI as well as try to give a short, yet comprehensive overview of
   distributed computing technologies and systems supported by SAGA through
   middleware adaptors.

 
  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptors for Job Execution and Management} 
  \forole{intro + explicit example}


  %%%%---------------------------------------------------------------------%%%%
  \subsubsection{Adaptors for Data Access and Management} 
  \forole{intro + explicit example}

  %%%%---------------------------------------------------------------------%%%%
   \subsubsection{More Adaptors}
   \forole{Whatever else is worth mentioning: streams, sd, ...}


  %%-------------------------------------------------------------------------%%
  \subsection{Measurements and Performance}
  \forole{T.B.D. (Look at old Globus adaptor benchmarks, etc..)}
  
\begin{itemize}
\item API overhead
\item API overhead with Python
\end{itemize}