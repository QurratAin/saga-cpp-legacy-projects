
\section{The SAGA API} \textbf{A.M}

 The need for a community-backed interface standard,extensibility
 [...]

 \jhanote{(i) What are the requirements, (ii) How does the API meet
 them, (iii) Why this works (compare and contrast to other API types),
 and (iv) what has been done before?}

 The argument is not Open-source versus proprietary code but open
 standards. \jhanote{The Comingled Code: Open Source and Economic
 Development, by Josh Lerner and Mark Shankerman, MIT Press}

 \jhanote{SJ thinks we should have a schematic. Hartmut thinks of a
 picture which shows the API ``from the above''.. Andre to take first
 crack. AM to reorganize.}


 \subsection{Use Cases and Scope}

  We have been stressing the point that the SAGA API design is use
  case driven.  To thus understand and appreciate the API design
  decisions presented in this section, one needs to consider the set
  of end users and application use cases which are the original
  target of the API.  We say 'original' because the actual set of use
  cases and applications the SAGA API is used for is (a) significantly
  different and also somewhat larger than anticipated, and (b) is, to
  some extent, an evolving and moving landscape.  For a discussion of
  the current set of application use cases, see
  section~\ref{sec:apps}.

  The SAGA API has been contrived by an international group of mostly
  academic computer and computational scientists.  The design phase
  thus had two major inputs: experiences with previous diustributed
  programming APIs, and prevalent distributed application use cases.
  Those inputs were collected and iterated in the early
  200x\ref{saga-use-cases, saga-requirements}, and the considered
  API's thus reflected the then state-of-the-art.  In particular,
  application programmers have been frustrated with the various low
  level grid APIs which accompanied the different Grid middleware
  systems which were en vogue back in the day.  The application use
  cases centered around the typical early grid projects: collaborative
  visualization and application steering, scaling-up of simulation
  codes, frameworks and portals for running standard (legacy or new)
  parallel applications 'in the grid'.

  Common to all the participating user groups was that the basic
  experience of programatically accessing distributed the (then mostly
  grid based) infrastructures was rather painful and complex, as no
  simple portable access layer existed.  On the other hand, the actual
  functionality those groups expected from the SAGA API was relatively
  large, and could not easily be defined by the least common
  denominator of the known use cases.  In fact, out of the considered
  use cases, at most 50\% would agree on any specific feature the API
  was supposed to cover.  Interestingly, many of the features which
  were considered to represent core grid functionality at that time
  were under-represented in the use cases, e.g. replica management, or
  workflows; other features like communication streams or application
  level information services were novel, and not natively provided by
  the prevalent middlewares.

  A certain set of functionality did, however, dominate the
  requirement list, which included obvious things such as job
  submission and management, remote data access, and security, but
  also consistent and concise error handling, asyncronous operations,
  and monitoring / event management.

  \F{sprinkle explicit example generously throughout the above text.}

  % - apps\\
  % - access layer\\
  % - tools\\
  % - context to other APIs and standards (boundary conditions for scope)


 \subsection{Design Objectives (first class)}
  - top-down\\
  - simplicity / 80:20 rule\\
  - cross cutting look-and-feel\\
  - extensibility / capability packages\\

  - high level UML diagram\\


 \subsection{Capabilities, Extensibility and Evolution}
  - discuss extensions just shortly, leave discussion of actual extensions to
  3.5 etc.\\
  

 \subsection{Syntax and Semantics}


 \subsection{Architectural Constraints on Implementations}
   (glue to next section?)

 \jhanote{Explain why we have the classic 3-level architecture}

