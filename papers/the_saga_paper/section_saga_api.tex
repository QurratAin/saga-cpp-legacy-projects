
\section{The SAGA API} \textbf{A.M}

 The need for a community-backed interface standard,extensibility
 [...]

 \jhanote{(i) What are the requirements, (ii) How does the API meet
 them, (iii) Why this works (compare and contrast to other API types),
 and (iv) what has been done before?}

 The argument is not Open-source versus proprietary code but open
 standards. \jhanote{The Comingled Code: Open Source and Economic
 Development, by Josh Lerner and Mark Shankerman, MIT Press}

 \jhanote{SJ thinks we should have a schematic. Hartmut thinks of a
 picture which shows the API ``from the above''.. Andre to take first
 crack. AM to reorganize.}


 \subsection{Use Cases and Scope}

  We have been stressing the point that the SAGA API design is use
  case driven.  To thus understand and appreciate the API design
  decisions presented in this section, one needs to consider the set
  of end users and application use cases which are the original
  target of the API.  We say 'original' because the actual set of use
  cases and applications the SAGA API is used for is (a) significantly
  different and also somewhat larger than anticipated, and (b) is, to
  some extent, an evolving and moving landscape.  For a discussion of
  the current set of application use cases, see
  section~\ref{sec:apps}.

  The SAGA API has been contrived by an international group of mostly
  academic computer and computational scientists.  The design phase
  thus had two major inputs: experiences with previous diustributed
  programming APIs, and prevalent distributed application use cases.
  Those inputs were collected and iterated in the early
  200x\ref{saga-use-cases, saga-requirements}, and the considered
  API's thus reflected the then state-of-the-art$+\epsilon$.  In
  particular, application programmers had been frustrated with the
  various low level grid APIs which accompanied the different Grid
  middleware systems which were en vogue back in the days.  The
  application use cases centered around the typical early grid
  projects: collaborative visualization and application steering,
  scaling-up of simulation codes, frameworks and portals for running
  standard (legacy or new) parallel applications 'in the grid'.

  Common to all the participating user groups was that the basic
  experience of programatically accessing the (then mostly grid based)
  distributed infrastructures was rather painful and complex, as no
  simple portable access layer existed.  On the other hand, the actual
  functionality those groups expected from the SAGA API was relatively
  large, and could not easily be defined by the least common
  denominator of the known use cases.  In fact, out of the considered
  use cases, at most 50\% would agree on any specific feature the API
  was supposed to cover.  Interestingly, many of the features which
  were considered to represent core grid functionality at that time
  were under-represented in the use cases, e.g. replica management, or
  workflows; other features like communication streams or application
  level information services were novel, and not natively provided by
  the prevalent middlewares.

  A certain set of functionality did, however, dominate the
  requirement list, which included obvious things such as job
  submission and management, remote data access, and security, but
  also consistent and concise error handling, asyncronous operations,
  and monitoring / event management.

  \F{sprinkle explicit example generously throughout the above text.}



  % - apps\\
  % - access layer\\
  % - tools\\
  % - context to other APIs and standards (boundary conditions for scope)


 \subsection{Design Objectives (first class)}

  'Normal' Grid APIs, such as those natively provided by the different
  Grid middlewares, are mostly designed bottom up, with the goal to
  expose the complete set of the middleware semantics programatically.
  Relatively little concern was spent on API consitency, and ease of
  use.

  SAGA's design is a tpo-down approach, and focuses on the opposite
  side of the coin: simplicity, ease of use and consistency are the
  dominating design objectives, semantic completeness on the other
  hand is not.  With those objectives, SAGA is by definition not
  suitable for all types of distributed applications.  For example, it
  is notoriously difficult to write \I{services} with SAGA.  The
  target user community of SAGA is, however, very convinced that those
  objectives satisfy their requirements.

  API consistency is achieved by dividing the API (logical and
  technically) into two major segments: one is the API's \I{\lf},
  which overarches the second, the API's \I{functional packages}.
  Those packages encapsulate the actual semantics of remote
  operations, as required by SAGA's application use cases -- for
  example, \I{saga::job} is a prominet SAGA API package which
  (unsurprisingly) provides classes and methods for creating and
  managing distributed job instances.

  Applying SAGA's \lf classes to all API packages ensures consitency
  of many apects of the API, such as error handling, asychronous
  operations, monioring, notifications, security and credential
  management, etc.  The structuring of the SAGA API into relatively
  independent API packages on the other hand imports the simplicity of
  the API -- it is very easy to grasp the overall API scope, and it is
  very common that applications use a small subset of the available
  packages.  But the package approach also allows for an easy
  extensibility path, while maintaining API stability and backward
  compatibility: additional packages can be defined (and in fact have
  been defined), which cater to new emerging use cases or
  technologies, while maintaining the remaining API's stability, and
  still ensuring the API's overall consistency (the \lf also apply to
  new packages).

  - high level UML diagram\\


 \subsection{Capabilities, Extensibility and Evolution}
  - discuss extensions just shortly, leave discussion of actual extensions to
  3.5 etc.\\
  

 \subsection{Syntax and Semantics}


 \subsection{Architectural Constraints on Implementations}
   (glue to next section?)

 \jhanote{Explain why we have the classic 3-level architecture}

