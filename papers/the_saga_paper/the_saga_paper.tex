\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{times}
\usepackage{multirow}
\usepackage{listings}
\usepackage{times}
\usepackage{paralist}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{hyperref}
\usepackage{subfigure}
\usepackage{color}
\usepackage{xspace}

%\documentclass{rspublic}

\usepackage{ifpdf}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}

\newcommand{\sagaspec}{\textit{SAGA}\xspace}
\newcommand{\sagaimpl}{\textit{SAGA}\xspace}

\newcommand{\spec}{\sagaspec}
\newcommand{\impl}{\sagaimpl}

\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.5in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\setlength\parindent{0.1in}
\setlength\parskip{0.25em}


\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\note}[1]{ {\textcolor{red} { ***NOTE: #1 }}}

\newif\ifdraft
\drafttrue

\ifdraft
\newcommand{\amnote}[1]{   {\textcolor{magenta} { ***Andre:    #1 }}}
\newcommand{\jhanote}[1]{  {\textcolor{red}     { ***Shantenu: #1 }}}
\newcommand{\onote}[1]{  {\textcolor{blue}     { ***Ole: #1 }}}
\else
\newcommand{\amnote}[1]{}
\newcommand{\jhanote}[1]{}
\newcommand{\onote}[1]{}
\fi


\newcommand{\forhartmut}[1]{{\textcolor{magenta}{\textbf{For Hartmut:} #1 }}}
\newcommand{\forole}[1]{{\textcolor{green}{\textbf{For Ole:} #1 }}}
\newcommand{\foroleandhartmut}[1]{{\textcolor{blue}{\textbf{For Ole \& Hartmut:} #1 }}}

\newcommand{\thesagaimpl}{\textcolor{red}{SAGA-C++} }
\newcommand{\thesagaimplrt}{{Runtime Support System} }
\newcommand{\thesagaimpladap}{\textcolor{red}{Middleware Adaptors} }


\begin{document}

 \title{ \large \vspace{-3.5em} SAGA: Towards a Comprehensive
   Programming System for Distributed Scientific Applications }


 \author{\normalsize Ole Weidner$^{1,3}$, Andre Merzky$^{1}$, Hartmut Kaiser$^{1}$, Shantenu Jha$^{1,2}$\\
   \small{\emph{$^{1}$Center for Computation \& Technology, Louisiana State University, USA}}\\
   \small{\emph{$^{2}$Department of Computer Science, Louisiana State University, USA}}\\
   \small{\emph{$^{3}$School of Informatics, University of Edinburgh, UK}}\\
%   \small{\emph{$^{4}$e-Science Institute, University of Edinburgh, UK}}
 }
 \date{}
 \maketitle
 

% \jhanote{Remember in addition to serving as an abstract, this will
%   serve as a summary of what will go to the 3 editors of the journals
%   that we are considering publishing a full paper in. Thus some more
%   information/discussion on what the underlying problem and context
%   will be about.}


% \jhanote{Once we have defined / introduced SAGA, we should probably
%   have 3 subsections -- interface, library and adatptors/backends?}

 
 \jhanote{We should discuss the title. I'm not a 100\% comfortable}
 
 \onote{What about: \textit{SAGA: Towards a Practical Programming System...} (i.e. SAGA is not 
 comprehensive). Or what about: \textit{SAGA: An Applied Approach Towards a
   Programming System for Distributed Scientific Applications}}

\jhanote{consistency between distributed systems, distributed
  computing, distributed infrastructure and distributed
  cyberinfrastructure is required}

\jhanote{Ole: Admittedly we're just going to go for a paper now and
  not go to an editor for input -- we might still but we'll not put
  that on the critical path. However, please do comment on what
  makes/doesn't make sense, what you agree with and/or don't agree
  with.}


\jhanote{Overhead measurements for adator loading -- cold + hot
  start. Call Stack: Time Decomposition of the control from
  Application to return} \jhanote{Include Amsterdam and Globus Adaptor
  tests}

\jhanote{Performance Characterisation: Objective: Preempt questions of
  the type Steve Fisher asked.. ``Why is this so slow?''. Lay out what
  the different types of performance bottlenecks are: (i) overhead,
  (ii) starvation, (iii) contention, (iv) latency hiding -- at
  different levels}


\newpage 

\subsection*{Abstract}
%\vspace{-0.6em}

Large-scale distributed cyberinfrastructure plays an increasingly vital
role in research and development projects across many different
scientific and engineering domains. Yet, we experience a
non-equilibrium between the fast growth of distributed infrastructure
and the scientific applications that can exploit the full potential of
these systems. There are multiple reasons at many levels of the
distributed computing stack that make it challenging to develop
distributed applications that are interoperable, scalable, extensible,
adaptive and yet simple to deploy and execute, as well as design
distributed cyberinfrastructure that can support them.  The Simple API
for Grid Applications (SAGA) is a community effort that aims to
address this missing capability.  In this article we will (i) provide
an overview of SAGA the API -- its design, its functionality and the
different compute and data models it supports, (ii) provide a
comprehensive account of the SAGA C++ Reference implementation, (iii)
discuss software architecture and development process and how it is
designed to encourage and facilitate community contribution.  Finally
we document how SAGA is both a standard interface that can be used to
{\it harmonize} distributed cyberinfrastructure, as well as an
effective way to develop distributed scientific applications, tools
and frameworks.  We discuss how SAGA's standardized interface, modular
runtime architecture and growing list of supported distributed systems
middleware have been used to develop applications, tools and
environments that are capable of overcoming current infrastructure
barriers and that give us valuable insights on how to architect
next-generation distributed systems and applications.

%\jhanote{Ole: This would be sufficient if this were just an
%  abstract. Remember for the purposes at hand, an ``abstract'' is
%  really like an introduction to the paper, i.e. enough material so
%  the editors can provide useful comments/feedback so that we can make
%  an informed decision. What is missing in the ``abstract'' is any
%  level of detail of what this paper is going to contain? What level
%  are we going to discuss the architecture? What style are we going to
%  adopt, e.g., is a software engineering paper?  Outline/structure of
%  the paper not conveyed in the above abstract? What is it that we are
%  going to try to convey and therefore what is in scope? (remember the
%  big fallacy of most papers: ``we can write it so we are writing it''
%  and disregarding ``what is the contribution of this paper''.}


\section{Introduction}



\jhanote{What is the ``global vision'' of CI? Positioning and scoping
  of SAGA w.r.t related work and efforts}
\textbf{Emphasize on the landscape of distributed
  cyber-infrastructure.} \textbf{S.J, O.W.}

%\vspace{-0.6em}

% Originally rooted in the 1960s operating system research, distributed
% computing quickly became a popular and diverse area of research in
% both, theoretical and applied computer science. Based on the
% fundamental principle of communicating autonomous processes, the
% study of distributed systems and applications systematically explored
% and extended the fields of algorithms, programming models and
% languages and rapidly grew to a full stack of patterns, concepts and
% methodologies (see e.g. \cite{519301}) which fostered the development
% of more and more complex systems and applications. This development
% arguably climaxed in the conceptualization and implementation of the
% Internet and World Wide Web~\cite{Berners-lee92world-wideweb} in the
% early 1990s as the foundation and prototype for all modern
% large-scale, globally-distributed systems. Quickly adopted by the
% scientific community, large-scale distributed systems have been the
% primary workhorse for the computational sciences for more than two
% decades now with many of today's systems consisting of a vast sets of
% globally interconnected resources and services, forged to provide
% researchers with dedicated high-bandwidth communication channels,
% hundreds of thousands of CPU cores and petabytes of storage.
 
% Yet there is a noticeable non-equilibrium between the progress that
% is made in providing even larger distributed systems and the
% distributed applications that are capable of using the full potential
%of these systems. Although the fundamental concepts of how to compose
% portable, reliable, scalable distributed applications are very well
% understood and an important part of any modern computer science and
% informatics curriculum, the scientific community still struggles to
% develop and deploy large-scale distributed applications.  In order to
% better understand the current dilemma, it is important to highlight
% an emerging paradigm shift that affects they way large-scale
% distributed systems are being used: while in the the past systems
% were distributed, but mostly self-contained, like for example campus
% grids or \textit{@Home} infrastructures, todays system landscape
% emphasizes on global distributed \textit{meta-systems}.  National and
% international efforts and collaborations are trying to bring together
% these formerly self-contained distributed systems to provide a global
% scientific community with an unprecedented network of
% resources. Administrative and technical borders are torn down to
% allow applications to tap into this pool and application scientists
% are studying the characteristics of these new meta-systems with the
% goal to apply already known as well as to develop novel concepts and
% patterns that can support a new generation of
% \textit{embarrassingly-distributed} applications.
 
% But what appears to be simple or at least as a straight-forward
% research agenda at a first glance, quickly turns into a Herculean
% Challenge on the technical level. A look at the recent history of
% large-scale distributed computing and the status quo of the
%technologies provides one possible explanation: although the majority
% of the community has been agreeing on what a large-scale distributed
% system should be early on, the implementation landscape couldn't look
% more diverse. Traditionally driven by strong political and personal
% agendas, system implementations in the 1990s and 2000s quickly
% diverged into a plethora of massive, more and more sophisticated
% middleware stacks.  And although the ... which lead to zero
% cross-site-portability of application code.
 
 
% With the \textit{Simple API for Grid Applications} (SAGA) we present a programming interface and
% runtime system for large-scale distributed systems that has been evolved from a mature, community 
% driven standard. 

\subsection{Overview}


Even though individual computers are becoming more powerful, there
remains and will remain a need for aggregating {\em distributed}
computational resources for scientific computing. In the simplest
case, the demand for computing power at any time may exceed
the capacity of individual systems that are available, requiring the coupling
of physically distributed resources.  Alternatively, higher throughput
may be achieved by aggregating resources, or there may be a need to use
specialized hardware in conjunction with general purpose computing
units.  Similarly, application components require specific hardware,
may need to store large data-sets across multiple resources, or may need to
compute near data that is too large to be efficiently transferred.  Finally,
distributed computing may also be required to facilitate collaborations
between physically separated groups.

\subsection{Barriers to Distributed Applications and
  Cyberinfrastructure}

However, despite the need, there is a both a perceived and genuine
lack of distributed scientific computing applications that can
seamlessly utilize distributed infrastructures in an extensible and
scalable fashion.  The reasons for this exist at several levels.  We
believe that at the root of the problem is the fact that developing
large-scale distributed applications is fundamentally a difficult
process.  Commonly acceptable and widely used models and abstractions
remain elusive. Instead, many ad-hoc solutions are used by application
developers.  The range of proposed tools, programming systems and
environments is bewildering large, making integration, extensibility
and interoperability difficult.

Against this backdrop, the set of distributed infrastructure available
to scientists continues to evolve, both in terms of their scale and
capabilities as well as their complexity.  Support for, and
investments in, legacy applications need to be preserved, while at the
same time facilitating the development of novel and architecturally
different applications for new and evolving environments, such as
clouds. Whereas deployment and execution details should not complicate
development, they should not be disjoint from the development process
either, i.e., tools in support of deployment and execution of
applications should be cognizant of the approaches employed to develop
applications.

\jhanote{Other barriers: (i) the way DCI is provisioned and often
  federated -- most often not {\it a priori}. Thus middleware is
  critical and heterogeneity is inevitable, (ii) Insufficient
  abstractions are multiple levels (revisit this when talking about
  how SAGA provides abstractions at these multiple levels), (iii) }

\subsection{The need for proper abstractions for DCI: the scope and
  role of SAGA}

\jhanote{Add brief note about the standardization process and why we
  chose to make this a standard}

\jhanote{SAGA moving forward.. (try to avoid short term projects) but
  focus on longer-term wish-list}
 

\include{section_saga_api}
\include{section_runtime_system}



%\section{SAGA Adpaptors for Middleware}

\section{Using SAGA: Applications, Tools and Frameworks} \textbf{S.J.}

\subsection{Distributed Applications}

 The distributed science and engineering applications that we have
 traditionally been implemented or supported by SAGA are mostly
 derived from the e-Science or Grid community of applications, which
 in turn emphasize traditional high performance computing (HPC)
 application that have been modified to utilize distributed resources.
 The complexity of developing applications for such large-scale
 problems stems in part from combining the challenges inherent in HPC
 and large-scale distributed systems.  Additionally, as the scale of
 operation increases, the complexity of developing and executing
 distributed applications increases both quantitatively and in
 qualitatively newer ways.  The reasons for multiple and concurrent
 resource usage are varied and often application specific, but in
 general, the applications analyzed are resrrource intensive and thus
 not effectively or efficiently solvable on a single machine.

 Although many of the application characteristics will be reminiscent
 of transactional and enterprise applications, a common feature of the
 science and engineering applications that have been developed using
 SAGA is that they have been executed on general purpose and shared
 production grid-infrastructure, such as the US
 TeraGrid~\cite{teragrid} and European EGEE/EGI~\cite{egi}, and have
 not been tied to a specific execution environment. Striving for such
 extensibility and portability is an important functional requirement
 and thus a design constraint. Additionally, the science and
 engineering applications considered are typically used in single-user
 mode, i.e., concurrent usage of the same instance by multiple users
 is highly-constrained.

 It is also important to mention some application characteristics that
 do not typically influence the design and operating conditions: the
 need for anything beyond the most elementary security and privacy, as
 well as the requirement of reliability and QoS have not been
 first-order concerns and thus they have not been specific
 determinants of execution environments or imposed constraints in the
 deployment.

\jhanote{How will we organize this.. need some framework/structure}

\begin{itemize}
\item Any one resource out of possibly many
\item More than one resource concurrently
\item ...
\end{itemize}

\subsubsection{Specific Applications/Exemplars}

\begin{itemize}
\item KeK and CERN
\item ExTENCI
\item Replica-Exchange and Ensemble-based Application
\item Data-Intensive Applications, e.g. BFAST
\item .. 
\end{itemize}


 \subsection{Tools}
 \subsection{Frameworks}

  %%-------------------------------------------------------------------------%%
  \subsection{Software }
  \onote{The more I think about it the more I'm convinced that this should NOT
  go into the RUNTIME SYSTEM ARCHITECTURE section. It should be discussed if
  this should go into an architecture/systems paper at all}
  
  Software architecture and development process and how it is designed to
  encourage and facilitate community contribution
    
  \jhanote{Ideally this subsection will describe how SAGA does or does not
  address many/all elements of error handling in a distributed environment}

  \subsection{Regression Testing} \jhanote{We need a subsection on regression
  testing. Can't have a paper on production grade software without some
  description of testing process, and possibly also release/packaging (though
  far less important)}
  
  \subsection{Package and Delivery} (AM)



 \subsection{Community Uptake?}

   Implementations, etc... \textbf{O.W. / A.M.}

   \subsubsection{Standardization efforts etc}

    - standardization process\\
      - use cases\\
      - requirements\\
      - scope\\
      - high level architecture (how are req's met)\\
      - specs\\
      - verification (does it work?  why / why not?)\\
    - community efforts fostered by standardization\\


 \jhanote{Issues of Adoption and Deployment} \jhanote{How do we
   provide/address production CI -- portability, simplicity and
   extensibilty. Even outline the build and make system!}

 \jhanote{There should be enough information for Adaptor writers to
   understand what is going on and what they need to do! Also a SAGA
   user -- either for tools or application development should be able
   to know what is happening without querying under the hood.}
   


\section{Related Work}
 \textbf{S.J., O.W.}

\subsection{API for Distributed Functionality}

\subsection{Workflow Engines}

\section{Conclusion and Future Directions}

\section{Acknowledgements}
 
I'd like to thank Santa Claus for giving me my first computer. I'd
also like to thank Baton Rouge for being such a crappy place that
there is nothing other than work to do out here, hence contributing
immensely to the SAGA project :)


\bibliographystyle{IEEEtran} 
\bibliography{the_saga_paper,saga_ogf}


\end{document}

