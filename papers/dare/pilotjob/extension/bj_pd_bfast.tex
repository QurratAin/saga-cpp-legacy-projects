\documentclass[]{article}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% More symbols
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{latexsym}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

\usepackage{color}
\definecolor{listinggray}{gray}{0.95}
\definecolor{darkgray}{gray}{0.7}
\definecolor{commentgreen}{rgb}{0, 0.4, 0}
\definecolor{darkblue}{rgb}{0, 0, 0.4}
\definecolor{middleblue}{rgb}{0, 0, 0.7}
\definecolor{darkred}{rgb}{0.4, 0, 0}
\definecolor{brown}{rgb}{0.5, 0.5, 0}

\newif\ifdraft
\drafttrue
\ifdraft
\newcommand{\jhanote}[1]{ {\textcolor{red} { ***shantenu: #1 }}}
\newcommand{\alnote}[1]{ {\textcolor{blue} { ***andre: #1 }}}
\newcommand{\smnote}[1]{ {\textcolor{green} { ***sharath: #1 }}}
\else
\newcommand{\alnote}[1]{}
\newcommand{\athotanote}[1]{}
\newcommand{\smnote}[1]{}
\fi




\title{BigJob, ManyJob, Pilot-Store, ... -- Abstractions for dynamic ...}
\author{  }

\date{2011-04-02}





\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle


\section{Pilot-Jobs}

Vectors:
\begin{itemize}
	\item Task binding to a resource
	\item Number of concurrent sub-jobs per BigJob
	\item Number of resources per BigJob
	\item Sub-Job description pull vs. push
	\item Communication with BigJob agents or storing task info
	\item Decision making (central vs. decentral) - should we support a pull-based BJ (Diane?)
\end{itemize}

\begin{tabular}{|l|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
	\hline
	&Task Binding &\# of Concurrent Sub-Jobs &Pull/Push & Communica\-tion with BigJob agents &Dynamic VOs\\
	\hline
	SAGA BigJob & &&&&\\
	\hline
	\hspace{4mm} Globus/PBS adaptor  &At sub-job submission  &n &Push/Pull &SAGA Advert service  &no\\  
	\hline
	\hspace{4mm} Cloud adaptor (EC2) &At sub-job submission  &n \alnote{Are you sure? Without ManyJob this should be difficult to do?}   \smnote{I think it depends on size of  subjobs and size of VM we are using?}  &Push/Pull&SAGA Advert service  &no\\ 
	\hline
 	BigJob-Cloud &At sub-job submission &n &Push&Local Python Queue &no\\ 
	\hline
	BigJob-Azure & At sub-job submission
	             &n &Push/Pull &Azure Storage &no\\ 
	\hline
    BigJob-Diane &late &n &Pull &yes &CORBA\\ 
	\hline
    ManyJob &   while BigJob Agent search for the new subjobs \alnote{What do you mean with that?} \smnote{sorry it was in wrong place. With many job all the tasks will be stored in the advert service and the bigjob agent pulls the tasks right? which ever starts first. So I think this is a pull appraoch because binding occurs randomly which ever bigjob agent starts first}  &n &Push/Pull &SAGA Advert service&no\\
	\hline
 	ManyJob-Cloud &At sub-job submission &n &Push/Pull & &no\\
	\hline 
	ManyJob Affinity & At sub-job submission &n &Push &SAGA Advert service &no\\
	\hline
\end{tabular}
\vspace{10 mm}

\textbf{Backends}
\begin{itemize}
    \item SAGA/Grid: Globus, PBS, Local, 
    \item EC2-style Clouds (FutureGrid, EC2, Eucalyptus)
    \item Azure
    \item Condor
    \item Diane
\end{itemize}


\textbf{BigJob vs. Diane}

\begin{tabular}{|l|l|l|}
\hline
 &BigJob &Diane\\
\hline
MPI &yes &yes\\
\hline
Advanced Scheduling &no &yes\\
\hline
Dynamic VOs &no &yes\\
\hline
API for Agent Submission &yes &no\\
\hline
\end{tabular}





\textbf{Extensions}
\begin{itemize}
    \item Dynamic VOs: adding new BigJobs to a ManyJob at runtime
    \item new backends
\end{itemize}


\textbf{Difference between Bigjob and Bigjob Cloud:} 

\begin{itemize}
	\item ManyJob is required to manage the set of VMs. The BigJob-Cloud can manage a set of VMs without the need of ManyJob.
	\item Bigjob uses advert server for communication between BigJob-agent and BigJob whereas BigJob-Cloud does not use an advert server.
	\item Bigjob-cloud does not require SAGA-AWS adaptors as opposed to requirement in original Bigjob. 
\end{itemize}	




\textbf{SAGA-ManyJob}:
It uses SAGA BigJob approach to start multiple BigJobs agents whether on a single resource or on multiple resources. And these agents are responsible for pulling the tasks from advert service and run the possible subjobs concurrently or in generations.



\textbf{SAGA-ManyJob-Affinity}:
This implementation is similar to SAGA-ManyJob except that we define affinity for each resource and also define affinity for the tasks. Therefor binding between tasks and resource occur while submitting the jobs.

This approach is well suited when utilizing wide variety of infrastructure/resources where parameters for the application will change according to the file paths/environment variables etc.. for each resource



\section{Pilot Data / Store}
\noindent
Scenarios:
\begin{itemize}
	\item Acquire data sources (advanced reservation, place holder)
	\item Virtual destination: dynamically mapping of data to pilot stores
	\item Runtime environment for $\alpha$ based data
\end{itemize}
	
\noindent	
Dynamic data:
\begin{itemize}
	\item Data to be generated (temporal)
	\item Data that is in place (spatial)
	\item Data that is changing (temporal)
	\item Data characteristics, properties
\end{itemize}	

\noindent
Analogies with Pilot-Job:
\begin{itemize}
	\item Assign pilot job to resource: $f^{1}(PJ_i) \rightarrow R_i$
	\item Assign task to pilot-job: $f^{2}(T_i) \rightarrow PJ_i$ 

	\item $g^{1} (D_i) \rightarrow PS_i$
	\item $g^{2} (PS_i) \rightarrow R_i$
\end{itemize}

\subsection{BitDew}

Random Nodes
\begin{itemize}
	\item Focus on Desktop Grid
	\item Java-based implementation (ie difficult to interface with Python-based PS/SAGA)
	\item highly distributed: stable and volatile nodes
	\item pull model, i.e. a node pulls for new data
\end{itemize}


Mapping to BitDew:
\begin{itemize}
	\item Pilot Store in its current implementation covers Bitdew Data Catalog and Repository
	\item For data management and placement the Active Data API and the Bitdew data scheduler could be used
	\item Transfer Management is done via SAGA File API	
\end{itemize}

How to evolve pilot data/store?
\begin{itemize}
	\item Active management of data (e.g. replication, automatic affinity management) requires an active component:
	\begin{itemize}
		\item Manager/Agent model as in BigJob?
		\item Who runs active components? Started as part of batch job or separate install/start?
	\end{itemize}
\end{itemize}

questions:
\begin{itemize}
    \item How should
    we store data in order to effectively cope with non-uniform demand for
    data? 
    \item How many copies of popular data objects do we need? 
    \item Where should we store them for effective load balancing?
\end{itemize}

\section{Pilot-Jobs as Runtime Environment for MR}
...


\section{BFast Scenario for Dynamic Data}

\textbf{Types of Input Files:}
\begin{itemize}
	\item static data: 
	\begin{itemize}
		\item reference genome
		\item index files
	\end{itemize}
	\item dynamic data: short-read files (ad-hoc generated depending on runtime)
\end{itemize}

\noindent
\textbf{Dynamic Scenarios:}
\begin{itemize}
	\item moving generated short-read data to available resources
	
	\item support processing of n experiments 

	\item re-partition of tasks to a larger number of available cores (dynamic data that needs to re-generated as a consequence that there are new compute elements available)

\end{itemize}

\bibliographystyle{plain}
\bibliography{}
\end{document}
