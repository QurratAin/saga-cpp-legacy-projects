% We switch to portrait mode. This works as advertised.
\documentclass[a0b,portrait]{a0poster}
% You might find the 'draft' option to a0 poster useful if you have
% lots of graphics, because they can take some time to process and
% display. (\documentclass[a0,draft]{a0poster})
\usepackage{graphicx}
% Switch off page numbers on a poster, obviously, and section numbers too.
\pagestyle{empty}
\setcounter{secnumdepth}{0}

% The textpos package is necessary to position textblocks at arbitary 
% places on the page.
\usepackage[absolute]{textpos}

% Graphics to include graphics. Times is nice on posters, but you
% might want to switch it off and go for CMR fonts.
\usepackage{graphicx,wrapfig,times}
\graphicspath{{images/}{../images}}

% These colours are tried and tested for titles and headers. Don't
% over use color!
\usepackage{xspace}
\usepackage{color}
\definecolor{DarkBlue}{rgb}{0.1,0.1,0.5}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{Red}{rgb}{0.6,0.2,0} %{0.694,0.305,0.09}
\definecolor{LightGray}{rgb}{0.7,0.7,0.7}

\definecolor{ItalColor}{rgb}{0,0,0} %{0.2,0.6,0.2}
\definecolor{BoldColor}{rgb}{0,0,0} %{0.8,0.3,0.1}
\definecolor{TextColor}{rgb}{0,0,0} %{0.1,0.1,0.5}
\definecolor{CodeColor}{rgb}{0,0,0} %{0.1,0.1,0.1}
\definecolor{HeadColor}{rgb}{0.1,0.1,0.5}

% see documentation for a0poster class for the size options here
\let\Textsize\normalsize
\def\Head#1{\noindent\hbox to \hsize{\hfil{\huge\color{HeadColor} #1}}\bigskip}
\def\AHead#1{\bigskip\bigskip\noindent{\Large\color{HeadColor} #1}\smallskip}
\def\LHead#1{\bigskip\bigskip\noindent{\huge\color{HeadColor} #1}\smallskip}
\def\Subhead#1{\noindent{\huge\color{HeadColor} #1}}
\def\Title#1{\noindent{\VeryHuge\color{DarkBlue} #1}}

\TPGrid[40mm,40mm]{15}{25}  % 3 - 1 - 7 - 1 - 3 Columns

% Mess with these as you like
\parindent=0pt
%\parindent=1cm
\parskip=0.5\baselineskip

% abbreviations
\newcommand{\ddd}{\,\mathrm{d}}
\newcommand{\up}{\vspace*{-1em}}
\newcommand{\down}{\vspace*{1em}}
\newcommand{\I}[1]{{\color{ItalColor}\textit{#1}}\color{TextColor}}
\newcommand{\B}[1]{{\color{BoldColor}\textbf{#1}}\color{TextColor}}
\newcommand{\T}{\texttt}

\newcommand{\F}[1]{\B{FIXME: #1}}

\usepackage{srcltx}
\usepackage{fancyvrb}
\usepackage{ifpdf}

\DefineVerbatimEnvironment{mycode}{Verbatim}
{
  label=Code Example,
  fontsize=\normalsize,
  frame=single,
  framerule=1pt,
  framesep=1em,
% numbers=left,
  gobble=2
}

\begin{document}

\begin{textblock}{11.2}(0,0)
\baselineskip=3\baselineskip 
\Title{Enabling Distributed Applications with SAGA \\
\Huge~%Subtitle
}
\end{textblock}

\begin{textblock}{11.2}(0,1.35)
\AHead{Ole C Weidner\\[0.2em]
\large~Center for Computation \& Technology, Louisiana State University, Baton Rouge, U.S.A.
}
\end{textblock}

\begin{textblock}{3.8}(11.9,-0.2)
  \includegraphics[width=150mm]{cctfullcolortower}
\end{textblock}

\begin{textblock}{15}(0,2.6)
\color{LightGray}\rule{\linewidth}{2pt}
\end{textblock}

\begin{textblock}{15}(0,3.0)
  \includegraphics[width=788mm]{bigpicture}
\end{textblock}

\begin{textblock}{7}(0,8.9)
  \LHead{Introduction}
  
  \large 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
Although task farming is common practice on cluster systems using shared 
filesystems and local batch queueing systems, task farming on distributed Grid 
resources is still far from being ubiquitous due to the heterogeneous, 
potentially unreliable, and unpredictable nature of computational Grids. 
Additionally, the vast amount of middleware, transport protocols, and 
programming interfaces makes it exceptionally difficult to run task farming jobs 
transparently on distributed Grid resources.\\[0.4em]
Given the task to run a large parameter survey for a sequential code that 
simulates the biology and behaviour of brown shrimp in a realistic marsh 
environment [1] we evaluated several task farming tools including Condor-G, 
Nimrod/G, and others. Since none of them could completely satisfied our 
requirements we decided to design and implement our own middleware independent 
ad-hoc task farming application based on the following design objectives:\\[3.6em]

\color{DarkBlue}
\begin{textblock}{3}(0.5,13.6)
  \color{DarkBlue}
  \begin{itemize}
    \item \textbf{Grid-Enabled} 
    \item \textbf{Portable / Scalable}
    \item \textbf{Middleware Independent}
  \end{itemize}
\end{textblock}

\begin{textblock}{7}(3.7,13.6)
  \color{DarkBlue}
  \begin{itemize}
    \item \textbf{Zero Configuration (Ad-Hoc)}
    \item \textbf{Lightweight}
    \item \textbf{User-Friendly}
  \end{itemize}
\end{textblock}
\color{Black}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\LHead{Implementation}\\[.4em]
Our task farming application [2] was designed as a set of independent agents 
around a central persistent Advert DB. The database acts as both job data storage
and communication hub for the agents. No agent-to-agent communication is 
necessary. A set of command line utilities (\texttt{submit}, \texttt{control}, 
and \texttt{monitor}) are availabe for submitting and interacting with an active 
task farming instance. The basic application flow and component interaction is 
as follows:\\ 

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_01}\end{minipage}
\begin{minipage}{13.35in}
  The \texttt{submit} tool parses the TFDL job description, checks its validity, 
  and prepares a new session.
\end{minipage}\\

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_02}\end{minipage}
\begin{minipage}{13.35in}
  The \texttt{submit} tool verifies the existence of application binaries and
  input data files described in (1) which can be both physical and logical URLs.
\end{minipage}\\

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_03}\end{minipage}
\begin{minipage}{13.35in}
  If steps (1), (2) were successful, the \texttt{submit} tool creates a
  new session structure in the Advert DB and populates it with data
  verified in the previous steps.
\end{minipage}\\

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_04}\end{minipage}
\begin{minipage}{13.35in}
  Once the DB is set up, the \texttt{submit} tool launches the 
  \texttt{agents} on a set of remote hosts and exits providing a UUID 
  for client connections (A), (B).
\end{minipage}\\

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_05}\end{minipage}
\begin{minipage}{13.35in}
  The \texttt{agents} perform a token-based leadership election to select
  a master agent. The master agent keeps track of the remaining agents and 
  restores consistency in case an agent dies. If the master dies, the 
  remaining agents perform a re-election.
\end{minipage}\\[.3em]

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_06}\end{minipage}
\begin{minipage}{13.35in}
  A \texttt{agent} gathers system, performance, and queue statistics and 
  advertises them periodically to the DB as a foundation for overall scheduling 
  decisions.
\end{minipage}\\

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_07}\end{minipage}
\begin{minipage}{13.35in}
  An \texttt{agent} decides based on the scheduling data in the DB wether or 
  not to start a new task. If so, it tries to retrieve an application image 
  and input files for the next available task and runs them on its locally
  accessible resources (this can be a local CPU as well as a batch queuing system).
\end{minipage}\\[.3em]

\begin{minipage}{1in}\includegraphics[width=20mm]{bullet_08}\end{minipage}
\begin{minipage}{13.35in}
  After a successful execution, each \texttt{agent} announces the results 
  and the location of output and error files to the advert DB and continues 
  with step (6).
\end{minipage}\\

\end{textblock}

\begin{textblock}{7}(8,9.85)

\color{Black}\large 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
All components were implemented in C++ using the SAGA (Simple API for Grid
Applications) libraries and adaptors [3] to gain transparent access to the Grid
middleware used in our testbeds which include Globus, PBS, Condor and the 
PostgreSQL-based Advert DB. We use SAGA's file package API for data transfer, 
the replica package for logical file handling, the job package for remote 
execution and monitoring, and the advert package API for accessing the Advert
DB.\\[-1.4em]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\LHead{Job Description}

The current version of our application uses an extended version of the JSDL 1.0 [4]
XML schema - TFDL (Task Farming Description Language) to describe a task farming 
instance. TFDL's extension to JSDL comprises a JSDL-compliant schema add-on which
allows the description of independent work packages ("chunks") for a task farming 
job which is currently not possible using plain JSDL.
For future versions of our application, we plan to adopt the upcoming JSDL 2.0 
standard which will provide all necessary schema properties for task farming job
description and doesn't need any extensions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\LHead{Results}

\textbf{\color{DarkBlue}(1)} We wanted to develop an easy to use task farming 
application capable of executing large parameter surveys on heterogeneous Grid 
computing resources. Using our application, we successfully conducted an 
initial survey of 250 input parameter permutations for the shrimp model with 
minimal preparation time on a Globus/PBS/Condor testbed.\\[0.4em]
\textbf{\color{DarkBlue}(2)} We wanted to show that the emerging standards in 
Grid computing like SAGA and JSDL finally enable developers to rapidly implement 
applications with focus on the application logic and the engineering process 
without the need to deal with middleware layer implementation details. We found 
that the SAGA API provides the required level of abstraction and all necessary 
functional packages to implement a Grid-enabled and portable application within 
a short timeframe (the first running prototype was ready after only one week of 
development). The major drawback was that the availability of middleware bindings
is currently restricted to local resources (local filesystem, fork) and Globus
(GRAM2, GridFTP, RLS). Especially the absence of apropriate adaptors for the 
widespread queueing systems PBS and Condor and a usable Service Discovery API 
forced us to implement parts of the scheduling and local job execution code using 
vendor-specific APIs and custom scripts.\\[0.4em]
However, we're looking forward to test and use the already announced SAGA Service 
Discovery API and batch system adaptors to leverage our application as a truly 
middleware independent and portable task farming tool.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\LHead{References}

[1] Haas, H. L., K. A. Rose, B. Fry, T. J. Minello, and L. P. Rozas, "Brown shrimp on the
edge: linking habitat to survival using an individual-based simulation model", 2004. 

[2] SAGA-based task farming application, [Online]. http://cct.lsu.edu/\~{}oweidner/tf/

[3] SAGA - A Simple API for Grid Applications, [Online]. http://saga.cct.lsu.edu

[4] JSDL Spec., Version 1.0 [Online].
http://www.ogf.org/documents/GFD.56.pdf

\end{textblock}

\begin{textblock}{15}(0,24.5)
\color{LightGray}
\rule{\linewidth}{2pt}
\end{textblock}

\end{document}

