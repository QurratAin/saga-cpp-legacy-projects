\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{epsfig}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifpdf}
\usepackage{listings}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{subfigure}
\usepackage{times}
\usepackage{url}
\usepackage{xspace}
\usepackage{booktabs}

%\setlength\topmargin{0in}
%\setlength\headheight{0in}
%\setlength\headsep{0in}
%\setlength\textheight{9.5in}
%\setlength\textwidth{6.5in}
%\setlength\oddsidemargin{0in}
%\setlength\evensidemargin{0in}
%\setlength\parindent{0.1in}
%\setlength\parskip{0.25em}

\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\note}[1]{ {\textcolor{red} { ***NOTE: #1 }}}

\newif\ifdraft
\drafttrue

\ifdraft
\newcommand{\todo}[1]{     {\textcolor{red}  { ***TODO      #1 }}}
\newcommand{\amnote}[1]{   {\textcolor{gree} { ***Andre:    #1 }}}
\newcommand{\jhanote}[1]{  {\textcolor{red}  { ***Shantenu: #1 }}}
\newcommand{\onote}[1]{    {\textcolor{blue} { ***Ole:      #1 }}}
\else
\newcommand{\todo}[1]{}
\newcommand{\amnote}[1]{}
\newcommand{\jhanote}[1]{}
\newcommand{\onote}[1]{}
\fi

\newcommand{\spec}{\sagaspec}
\newcommand{\impl}{\sagaimpl}
\newcommand{\lf}{Look-\&-Feel}

\newcommand{\I}[1]{\textit{#1}\xspace}
\newcommand{\B}[1]{\textbf{#1}\xspace}
\newcommand{\T}[1]{\texttt{#1}\xspace}


\begin{document}

\title{ \large \vspace{-3.5em} SAGA: An Access Layer to Distributed CI
  and Providing Abstractions for Distributed Applications}


\author{\normalsize Shantenu Jha$^{1}$, Andre Merzky$^{2}$, Ole
  Weidner$^{2}$, \\ \small{\emph{$^{1}$Rutgers University, NJ, 08804,
      USA}}\\ \small{\emph{$^{2}$Center for Computation \& Technology,
      Louisiana State University, USA}}\\ } \date{}
 \maketitle

\abstract{The abstract.}
 
\section{Introduction}\todo{SJ}
 \label{intro}

\begin{verbatim}
   - Grand intellectual challenges of designing DCIs
     - how to design infrastructures to bridge gap
     - what is role of abstractions/interfaces in general, and for
       SAGA
       - interface necessary, but sufficient?
       - should be sufficient, if fully functional (contract)
       - but what are the challenges of providing a functional interface?
       - at the end deep integration!
       - from there follows design, limitations
         (possibly goes partially into conclusions)

    - roles for SAGA: 
      - shield from environment
      - need to be able to reason about distribution without
      considering those env details

    - Limitations of SAGA:
     -- APIs are never enough! The challenge of implementing them. 

\end{verbatim}

Distributed applications utilize multiple resources, or are capable of
utilizing them. One could argue that any application that would
benefit from increased peak performance, throughput, or reduced time
to solution, by using multiple compute and distributed data resources,
can be classified as a distributed application, or a candidate to be
formulated as such.

% Although \ci technologies have matured considerably over the past
% few years, applications that can effectively utilize these
% technologies are far from ubiquitous.

The ability to develop or formulate scientific applications as
distributed applications,
% Advances in distributed applications have 
has simply not kept pace with advances in other aspects of distributed
cyberinfrastructure (CI). This is true whether measured by the number
of novel applications developed to exploit distributed infrastructure,
or even by something simpler, such as the number of applications that
can use multiple resources to reduce the time-to-solution of
scientific problems.  There are at least three complex
reasons~\cite{dpa_grid09}, which defy over-simplification. We believe
the main issue is simply that developing large-scale distributed
applications is fundamentally a difficult process~\cite{dpa-paper},
made more difficult due to the scarcity of high-level programming
abstractions and interfaces that bridge the divide between the needs
of distributed applications and the capabilities offered by middleware
and system-level interfaces~\cite{cloud-saga-paper}. Second,
deployment and execution concerns are often disjoint from the
development process~\cite{dpa_grid09}. Finally, the range of tools,
programming systems, and environments is bewildering large, making
extensibility and interoperability difficult.  SAGA will help
applications and tools fulfill the goal: ``As much as possible,
software should run independent of specific hardware and should use
intuitive interfaces that do not depend upon extensive knowledge of
the operating environment,'' as recommended in a recent draft report
from the NSF workshop on Cyberinfrastructure Software Sustainability
and Reusability~\cite{CISSR}.


Against this backdrop, the distributed infrastructures available to
scientists continue to evolve in scale and capability, as well as
complexity.  Investments in legacy applications need to be preserved,
while at the same time, development of functionally novel and
architecturally different applications for new and evolving
environments needs to be facilitated. 

Developing versus Deployment versus Using

For context: it is still very difficult to develop a distributed
application that can use O(1000) processors, transfer/handle O(100) GB
data and use O(10) arbitrarily chosen sites, repeated over 10
arbitrary chosen days. The only science projects that can do so
currently are Big Science projects, with very large teams and levels
of effort.  Individual PIs/scientists are unable to do so, but there
are many who clamor and need to be able to do so This fundamental
mismatch between requirement of DA and capabilities of DCI is one of
the intellectual problems that this paper (and solutions therein) are
trying to address.



\section{Critical Perspective on DCIs}\todo{SJ}


\subsection{DCI Challenges: Infrastructure Perspective}

 \subsubsection{The complexity of DCIs}

  It is well known engineering practice to keep systems as modular and
  simple as possible, as those attributes are major indicators for
  maintainability and stability.  Simplicity is also a significant
  contributor to ease-of-use.  DCIs are, of course, designed with
  those objectives in mind -- so, why do they appear to be inherently
  complex, fragile, and difficult to use?

  The reasons are manifold, and not always obvious.  First, unlike
  many commercial IT infrastructures, academic DCIs tend to serve a
  considerably large, and importantly \I{diverse}, set of user
  communities.  In particular, this diversity of users and use cases
  imposes a large number of functionality requirements on the DCI --
  and those requirements are often not well specified, or are expected
  to evolve over the lifetime of the DCI.  Those requirements in turn
  imply a large number of design constraints, which are sometimes even
  contradictory.  That makes it basically impossible to come up with
  \I{simple} DCI software stacks.  Along the same lines, the
  heterogeneity, which is inherent to DCIs on many layers, including
  the hardware resource layer, is also a reflection of the large and
  diverse set of use cases and user communities.

  The modularity of the stacks should actually be encouraged by the
  large set of functionality requirements -- on the first glance, that
  seems to be the only viable option to manage those requirements in a
  scalable and evolvable way.  But there are several boundary
  conditions which act diametrical to the modularity principle.

  First, academic software is rarely designed from scratch, but rather
  grown.  That may not hold true for individual elements of the stack
  (although it often does), but it certainly holds true for the DCI
  stack as a whole.

  Secondly, very few software components are backed by a sustained
  software support and maintenance model -- instead, the usual
  approach of funding software in small, very finite chunks (called
  projects), results in software that is, once the project concludes,
  in limbo.  The notion of follow-up and integration projects exists,
  of course, which try to address exactly that problem, but those
  projects are rare, and also finite and short.  In general, the
  current scheme of software funding favors research level software
  over production level software -- maintenance and sustainability are
  often an appendix in project proposals, and not the core.  Funding
  agencies have begun to realize the problems with that approach --
  but it will need significant time and culture change to address it.

  Thirdly, academic DCIs are very often not centrally controlled.
  Instead, they frequently represent a federation of relatively
  independent resource providers, which work together toward a common
  (set of) goal(s).  That is in sharp contrast to commercial IT
  infrastructures, where heterogeneity and autonomy can, at least
  in principle, be controlled at any level.

  % Finally, there is ego.  Well, plural, there are egos, which is
  % exactly the problem.


  



\begin{verbatim}

Why are DCIs complex in the first
place?  Many requirements, many different usage modes, no simple
straight-forward solution (i.e. engineering approach) possible.
Plethora of point-wise solutions vs. end-to-end solutions
 

DCI is not just scaling up a single computing resource. DCI is
complex: heterogeneous software, access-layers, policy.. 
An engineering challenges. 
Difficult to integrate services \& software (Service-level Interop)
Middleware: Heterogeneity and semantic incompatibility

This is not Google where a top-down solution, as much of a sociocultural
challenge as a technical one. Slow/lack of agreement towards
a standards-based software
 
Fundamental: How to design and implement DCI such that the
whole is greater than the sum of the parts? (where each of the parts
is complex heterogeneous systems!!)
 
DCI: Difficult to use for (domain) scientists, Complexity O(N), likely worse

Narrow grids vs. broad grids: narrow grids provide a more limited set
of solutions (cater to more limited set of requirements), and can thus
potentially be implemented on a lower complexity level.

\end{verbatim}


\subsection{DCI Challenges: Application Perspective}

\begin{verbatim}

End-to-end application support missing

Many moving and changing parts insufficient / partial coverage

Complex coordination requirements; How to manage coordination?

Well defined interfaces; Standard-layers handle hard parts, 
allowing innovation elsewhere

Abstractions Support: Where, when, how to distribute? 

Both Development and System/Infrastructure level abstractions

Effective Dynamic resource utilization and execution models
Beyond simple static single batch-mode

\end{verbatim}

A distributed application has some unique challenges: a distributed
 application/developer has to reason about the environment that the
 application will execute in, has to make assumptions about the
 runtime availability, and has to assume a failure model that
 transcends complete knowledge of the application or even predicates
 it upon knowledge of a system/resource.  Whereas the choice of tools
 will always be influenced by soft factors, the challenge for us is to
 think of abstractions that enable the developer to reason about the
 above hard factors, and not just the tools, services and
 capabilities.

The process of developing and deploying large-scale distributed
 applications presents a critical and challenging agenda for
 researchers and CI developers.  In spite of the tremendous potential
 of distributed systems, there have only been a limited number of
 successful distributed applications; in the case of the TG, where
 there has been success, the effort required has been {\it heroic} but
 unsustainable and thus not surprisingly heavily biased towards big
 showcase projects. It is difficult to examine under the covers of
 these prestige projects, but there has not been a trickle down
 advantage to communities of smaller users, who cannot sustain heroic
 efforts in order to accomplish their science.


 \jhanote{Some text about the mismatch between DCA requirements and
  DCI capabilities}

\section{Access Layers to DCI and Abstractions for DA}\todo{AM, SJ}

Revisiting the reasons why production DCI have not been used in more
innovative ways, reveals that there are currently gaps at several
levels: application development and runtime capabilities, as well as
system software and deployment support~\cite{dpagrid2009}.  No single
solution can address gaps at all levels, or for the entire spectrum of
applications.  

We posit, however, that a well-defined, stable general purpose API is
one critical element of the solution, as that exposes the basic
distributed capabilities to serve as an uniform access layer to the
infrastructure layer as well as a building blocks for higher-level
applications, capabilities and tools.

We will substantiate this claim from two different
viewpoints/directions: in the first, we will examine the role of an
API that acts as an Access Layer to the levels/layers of
infrastructure beneath. The second viewpoint will examine how we can
build tools \& services using such an API...

The vertical axis can be thought of as a non-continuous ordering, with
the bottom level being closer to the hardware and the upper levels
being closer to the application.

It is important to note that every API can be considered as an
abstraction to underlying layers: the first challenge when designing
an API the challenge is to define the level for such an abstraction
layer.  

It is often misunderstood that placing an abstraction level at a given
level, implies that all capabilities below that level should be
supported. However this is not the case, and a second challenge is to
define the scope, viz., which features and capabilities should the API
provide an abstraction too.

\jhanote{This section should result in the motivation of the API:
  level and scope}

%\jhanote{Q: Determine whether HG metaphor is 2 dimensional or 3?}

\begin{verbatim}
   - Role of an Access Layer as defined:
      - provide abstractions to set-of/selected levels/capabilities below
      - support heterogeneity, environment (elaborate on environment..), 
      - provide uniformity

    - Role for the abstraction to DA 
      - need to be able to reason about applications without 
        considering those environment details

   - Placement of the neck, and width/scope of the HG.
     Placing the access layer/level-of-abstraction/where is the neck
     of our hour glass?

   - Define where we are placing it. THAT IS SAGA...
\end{verbatim}

\section{Design Objectives and Principles}\label{saga_impls}

% \subsection{Design Objectives and Principles}

 \jhanote{Objectives should be drawn from both the role of access
   layer and role as an abstraction/BB for DA}

 \jhanote{Manage heterogeneity, complexity, simplicity,
   sustainability, enable reasoning, construction}

 \jhanote{Can someone remind me what the Design principles we
   converged on were?}

 \subsection{Design Objectives}


 \subsubsection{Objective: Manage Heterogeneity}
  \begin{verbatim}
    Objective: Interoperability
    Principle: ?
    Solution:  Adaptor
   \end{verbatim}


  \begin{verbatim}
    Objective: Dynamic Execution
    Principle: ?
    Solution:  ?
   \end{verbatim}

  \begin{verbatim}
    Objective: ?
    Principle: ?
    Solution:  ?
   \end{verbatim}

 \subsubsection{Objective: Manage Complexity}
 
  \begin{verbatim}
    Objective: complex software environment 
    Principle: 
    Solution:  
   \end{verbatim} 

   \begin{verbatim}
    Objective: complex deployment and runtime environment
    Principle: 
    Solution:  
   \end{verbatim}

   \begin{verbatim}
    Objective: failure/fragile runtime 
    Principle: 
    Solution:  
   \end{verbatim}

 \subsubsection{Objective: Scalability}

   \begin{verbatim}
     Scale-Up: Multiple Cores, people, Scale-Out: Multiple tasks/units,
Scale-Across: distinct computational resources
   \end{verbatim}


\subsubsection{Objective: Sustainability}
  \begin{verbatim}
    Objective: Towards a community Standard 
    Principle: 
    Solution:  
   \end{verbatim}

  \begin{verbatim}
    Objective: Community Uptake
    Principle: 
    Solution:  
   \end{verbatim}

\subsubsection{Objective: Usability}

  \begin{verbatim}
    Objective: Extensibility
    Principle: ?
    Solution:  ?
   \end{verbatim}

  \begin{verbatim}
    Objective: Simplicity
    Principle: ?
    Solution:  ?
 \end{verbatim}

%  \subsubsection{Manage Heterogeneity}
%   \begin{verbatim}
%     Objective: sustainability
%     Principle: stability
%     Solution: standard
%    \end{verbatim}

 \jhanote{take the rest of section 4 and put it into
   Objective/Principle/Solutions tuple style}

 \subsection{Old Notes}

\begin{verbatim}
    -> How approached -> Design Principles, next section
    - challenge of environment (define env: fragile, lossy, heterog,
      reliability/failure, complex, dynamic, evolving, ) 
      - adaptors: approach to heterogeneity (different syntax, different
        semantics, late binding, heterogeneous in time -> dynamic), also supports 
        separation of concern
      - reliability: we have a model (define it), but is addressed elsewhere
      - continous testing is part of the answer to dynamic env /
        boundary condition

    - challenge of diverging and multitude of application
      requirements?

     -> be relevent to large user base and longish time scales
     -> good scoping API, use cases, requests, common practice
     -> still too large, apps are moving, no 1st principle apps,
        stability vs. agility, poorly understood use cases, moving targets, 

     -> Manage Heterogeneity
     -> portable, adaptor based
     -> deployment vs coding, 'semantic equivalence'
  
     -> easy to deploy / easy to integrate
     -> components, containment, loose coupling
     -> tight coupling, leaky abstractions
  
     -> extensibility
     -> adaptors, packages, higher level abstraction
     -> adaptors: hard to enforce semantic coherence
        packages: ok (mod impl)
        HLA:      hindered by impl deficiencies
  
     -> sustainable production code in academic env
     -> community involvement, vendor uptake/buy-in, small code base,
        standardization (see Zakopane paper)
     -> integration with ecosystem (technical and social), 
   \end{verbatim}

 {\it The objective of SAGA, the 'Simple API for Grid Applications is
   to provide this missing critical component in the distributed
   cyberinfrastructure ecosystem.}\footnote{While the API's name
   suggests its string ties to Grid based DCIs, it is in fact a
   general purpose API for distributed -- which is historically rooted
   in the Grid community.}  SAGA can provide effective abstractions
 that can hide the environmental complexity, supplement the
 incompleteness and lack-of-extensibility of many tools used whilst
 promoting interoperability as first-class design objective.  On the
 other hand it must provide the building blocks upon which the
 distributed applications, tools and frameworks can be built...


\jhanote{This section should end up motivating the Architecture and
 Implementation}

\section{Conceptual Architecture and Implementation} \todo{AM (layer 1), Ole (layer 2, 3)}

\jhanote{All three levels are to be covered: API, Implementation of
  the API and the adaptors: (i) API Packages Layer with cross-cutting
  properties, (ii) Adaptor Manager Layer (iii) Adaptor Layer}

 Realization of the principles; provide integrated realization of the
 principle, which leads to an overall implementation..

 \subsection{Conceptual Architecture}

 \subsection{Implementation}

 \subsection{Performance}



\section{Implementation and Solution Challenges}\todo{Ole}

Having an architecture is only half the battle -- one also needs an
implementation of the architecture.


\subsection{Software Challenges}

\subsubsection{packaging challenges}
\subsection{Deployment and Integration} 

\jhanote{distributed testing}

\subsubsection{Integration with Middleware}
\subsubsection{Integration with Infrastructure}


\section{Applications and Frameworks}\todo{SJ}
\label{apps_and_frameworks}


Addressing this reiterates the importance of a well-defined general
purpose API that provides the basic distributed capabilities to serve
as building blocks for further applications and tools. The status of
the current workflow tools and enactment engines provides an
illustrative example~\cite{nsf-workflow,1196459}. Had SAGA or a
SAGA-like API been around, it is very likely that many distributed
workflow engines would have utilized SAGA (or parts thereof), instead
of proprietary solutions, to implement {\it common and basic}
distributed functionality, such as distributed job submission and
distributed file movement/management. SAGA's impact on the workflow
world can be seen through the consequences of its absence: in spite of
significant effort, workflow interoperability at multiple levels --
application, tools, enactment engines and components remains difficult
if not infeasible.  Significant effort has been invested towards
workflow interoperability at these different levels -- if nothing
else, providing post-facto justification of its importance.
Additionally, workflow capabilities and engines are typically tied to
specific tools and infrastructure (e.\,g.\ DAGMan-Condor) and require
the adaption of the application/usage modes to the workflow engine as
opposed to the other way around.



The situation now is potentially very different for emerging tools and
infrastructure such as Pilot-Jobs. A well defined API for distributed
applications in the form of Pilot-API now exists; a stable
implementation of it is on the horizon; the importance of
extensibility, interoperability and lessons from the workflow
experience have hopefully been learned and there is a willingness to
adopt and integrate...

\section{Discussion}\todo{All}

\subsection{Lessons Learned}

\subsubsection{Role of Standards?}

\subsection{Related Work}

\subsubsection{The Interface Standards Landscape}\label{interface_landscape}

\subsection{DCI and DA: The Road Ahead}

\subsubsection{Emergence of Clouds}

\subsubsection{Data as First-Class Entity}

\subsubsection{Application-Level Dynamism}

\bibliographystyle{IEEEtran} \bibliography{sagapaper,saga_ogf}


\end{document}

