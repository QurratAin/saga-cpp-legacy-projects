\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{times}
\usepackage{multirow}
\usepackage{listings}
\usepackage{times}
\usepackage{paralist}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage[hypertex]{hyperref}
\usepackage{subfigure}
\usepackage{color}
\usepackage{xspace}

%\documentclass{rspublic}

\usepackage{ifpdf}

\newcommand{\I}[1]{\textit{#1}}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\BI}[1]{\textbf{\textit{#1}}}
\newcommand{\T}[1]{\texttt{#1}}

\newcommand{\sagaspec}{\textit{SAGA}\xspace}
\newcommand{\sagaimpl}{\textit{SAGA}\xspace}

\newcommand{\spec}{\sagaspec}
\newcommand{\impl}{\sagaimpl}

\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.5in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\setlength\parindent{0.1in}
\setlength\parskip{0.25em}


\ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg}
\else
 \DeclareGraphicsExtensions{.eps, .ps}
\fi

\newcommand{\note}[1]{ {\textcolor{red} { ***NOTE: #1 }}}

\newif\ifdraft
\drafttrue

\ifdraft
\newcommand{\amnote}[1]{   {\textcolor{magenta} { ***Andre:    #1 }}}
\newcommand{\jhanote}[1]{  {\textcolor{red}     { ***Shantenu: #1 }}}
\else
\newcommand{\amnote}[1]{}
\newcommand{\jhanote}[1]{}
\fi

\begin{document}

 \title{ \Large \vspace{-3.5em} Overcoming Global Infrastructure Barriers on Application Level with SAGA }
 
 \author{Shantenu Jha$^{1,2,3}$, Hartmut Kaiser$^{1}$, Andre Merzky$^{1}$, Ole Weidner$^{1}$ \\
   \small{\emph{$^{1}$Center for Computation \& Technology, Louisiana State University, USA}}\\
   \small{\emph{$^{2}$Department of Computer Science, Louisiana State University, USA}}\\
   \small{\emph{$^{3}$e-Science Institute, University of Edinburgh, UK}}
 }
 \date{}
 \maketitle
 

% \jhanote{Remember in addition to serving as an abstract, this will
%   serve as a summary of what will go to the 3 editors of the journals
%   that we are considering publishing a full paper in. Thus some more
%   information/discussion on what the underlying problem and context
%   will be about.}


% \jhanote{Once we have defined / introduced SAGA, we should probably
%   have 3 subsections -- interface, library and adatptors/backends?}

\subsection*{Introduction}
\vspace{-0.5em}
Attempts to establish a global distributed computing infrastructure ('grid') and make it transparently accessible to scientific applications have been ongoing for some time. Although some infrastructure providers are dedicated to advance the integration of their systems, the very idea of a global computing grid, seamless sharing of resources across administrative as well as technical domains, is not reality yet. This is why still relatively few existing distributed applications exploit the full potential of these global distributed environments. Especially on the technical side, application developers are facing difficulties in their attempt to master the complexity and heterogeneity of the underlying infrastructure and the still existing barriers between different distributed systems.

With \impl, the \textit{Simple API for Grid Applications}, we introduce a community driven standard and its implementation in C++/Python that can help to overcome most of the remaining technical barriers in global distributed systems. \impl provides the application developer with and extensible, high-level API that unifies the access to common grid functionality (job, namespace, file and replica handling, streams and RPC). Along with a lightweight runtime-system for logging and error handling, and an expanding number of middleware \textit{adaptors} (plug-ins to access distributed middleware services), \impl provides a simple, yet powerful interface to develop portable distributed applications, tools and frameworks that can take full advantage of a growing global infrastructure.

\vspace{-0.8em}

\subsection*{A Powerful, Community-Driven Standard}
\vspace{-0.5em}
 The \spec effort was initially triggered by several early grid adopter communities, which perceived the need for a simple, uniform, and stable programmatic interface for distributed (grid) applications that is widely-adopted and widely-available. The distributed computing community was looking for something similar to what the Message Passing Interface (MPI) standard is for the parallel computing community - a ``\textit{grid-counterpart to MPI}``, that allows the development of portable distributed applications.
 
 
 The scope and requirements of the \spec API is
 formally defined by the Open Grid Forum's (OGF)~\cite{ogf} SAGA Working Group (SAGA-WG), and were
 derived from use cases collected from a broad user community (see
 GFD.70~\cite{ogf-gfd-70} and GFD.71~\cite{ogf-gfd-71}). The result
 of this 5-year process is the \spec Core API
 specification 1.0 (GFD.90~\cite{ogf-gfd-90}) which defines the \spec
 Core (including error handling, session management, monitoring,
 notification, and asynchronous operations) and the \spec \textit{Functional API
 Packages} (jobs, namespaces, files, replicas, streams, RPC).
  Additional API extension packages, such as
 Checkpoint \& Recovery (CPR) (GWD-R.96~\cite{ogf-gwd-r-96}), Adverts
 (GFD-R-P.XX~\cite{ogf-gwd-r-p-xx}), and Messaging
 (GWD-R.94~\cite{ogf-gwd-r-94}) are currently under development and
 follow a similar, well-defined community-driven standardization and
 approval process. 

 
The \spec interface follows a clean class-based object-oriented design paradigm and is 
 formulated in an abstract way (using SIDL) which allows implementations of the standard in
 most object-oriented and even procedural programming languages. GFD.90 is now an Open Grid Forum proposed recommendation on the path to becoming a full standard in 2010. \spec is probably the most advanced and also most complete attempt and to create a standard that defines a unified programming interface for the distributed-application community - something the parallel-application community has benefited from for the past 16 years since the release of the MPI 1.0 standard in 1994. 
 
\vspace{-0.8em}


\subsection*{A Modular and Extensible Grid Programming System}
\vspace{-0.5em}
The \impl \I{Core Components} and \I{Adaptors} an implementation
of the \spec API Specification written in C++ and Python. \impl is
Open Source software, released under the Boost Software
License 1.0~\cite{boost_license_web}. It can be divided into
three major components (as depicted in Fig. \ref{fig:saga_arch}):
the \I{Core Components} which provide the API functionality, the
\I{Adaptors} which translate API calls into native middleware calls,
the Python API \I{Language Bindings} and a set of \I{Command Line
  Tools}. The \impl \I{Core Components} are a collection of dynamic
libraries and header files that represent the functional API packages
(see section 2.1) along with a lightweight, highly-configurable
\I{Engine Component} that manages call dispatching and the dynamic
runtime loading of the \I{Middleware Adaptors}.


Each of these \I{Adaptors} implements the functionality of a specific
functional package (e.g., job adaptors, file adaptors) for a specific
middleware system. Adaptors are also realized as dynamic
libraries. \impl provides adaptors for many grid and distributed
computing middleware, including the Globus Toolkit, Condor, Platform
LSF and Amazon EC2. Several other adaptors, notably adaptors for PBS,
gLite and BES are under development. The Python API \I{Language
  Bindings} are an optional component of \impl that adds a thin Python
layer on top of the native C++ API. This simple but very popular
component allows application developers to quickly prototype and
implement \impl-based applications in Python.  The layered, decoupled
architecture of \impl allows for maximum flexibility at compile and
runtime. It allows the user of to freely and selectively combine the
library components and easily develop additional components orthogonal
to the existing ones. More details on \impl's architecture and its
implementation details can be found in \cite{OOPSLA_PAPER}.

%  The forth and last
% component are the \I{Command Line Tools}. They provide a
% non-programmatic access to each of \impl's functional packages: the
% \I{file tool} provides access to file operations, like read, copy,
% delete, move, etc., the \textit{job tool} allows simple submission and
% control ofcompute jobs, and so on.
\vspace{-0.8em}


\subsection*{A Mature Software Engineering Process\label{engineering}}
\vspace{-0.5em}
The \impl engineering process is closely supervised by the technical
project manager. It follows an iterative and incremental model in
which the evaluation and learning phase is strongly community
driven. \impl provides independent releases for the \I{Core
  Components}, the \I{Language Bindings} and the \I{Adaptors}, which
provides maximum flexibility and short shortest reaction times for
bugfix-releases. All releases are available on the saga
website~\cite{saga_downloads_web} and are fed into a very responsive
community of users, which subsequently files bugs and suggests
improvement through a central ticket
system~\cite{saga_bugtracking_web} which is tightly integrated into
the development process. These reports along with strategic long-term
development goals form the requirements for the next
iteration. Individual developers are usually responsible for specific
components over the component's whole lifetime. This does not only
ensure clearly defined targets for task assignments, but also results
in growing expertise and specialization for the individual
developers. The core \impl development team has been working together
for more than three years and has evolved into a very smooth running
operation. Nevertheless, the \impl development process is completely
open: community involvement is not only accepted but encouraged and
has lead to successful collaborations and enrichment of the \impl
landscape in the past.

Along with the development of \impl, we maintain and constantly extend a broad set of unit and conformance tests to verify proper functioning and to validate OGF standard compliance. Most of the tests are written on a per-package basis using the Boost Test library~\cite{boost_test_web} and Python's built-in unit test framework. To facilitate the continuous integration (CI) aspect in the \impl development process, all tests are run constantly and automated using an automated CI rig\cite{buildbot_web} which provides feedback for every single change in the saga source tree. This way build problems and failing tests are pinpointed quickly and the responsible developer can take action. These automated tests are  our most valuable tool for early error and bug detection and has lead to a constantly higher quality of our releases since its introduction.
 \vspace{-0.8em}
%\subsection*{A Strong and Diverse Application Community}

\subsection*{SAGA: Sustainability}
\vspace{-0.5em}
\subsection*{Addressing the needs of the e-Science Community}
\jhanote{SJ Will write} \note{Shantenu's playground: talk about
  scientific applications using saga directly (...), talk about CS
  people taking saga and use it to build higher-level frameworks and
  tools (faust, bigjob, diggedag...). The usual stuff ;-)}

SAGA is being used by a broad set of users in many different ways --
both to support production-grade science as well as to facilitate
research into distributed systems and applications.  For applications,
the most common mode of uptake has been in the development of
``frameworks'' -- logical compoments that meet specific application
requirements. Some specific examples of such frameworks, include the
Pilot-Job Framework (BigJob) and a self-adapting computing framework
(Lazarus); other frameworks are based upon generalisations of well
known patterns such as All-Pairs. SAGA-based frameworks support a
wide-range of scientific activity, ranging from the Virtual
Physiological Human (VPH) to Resorvoir simulations hierarchichal
molecular dynamics simulations on the TeraGrid.

Another common mode of SAGA usage is the creation of tools that are
extensible and work over different infrastructure. Once again,
SAGA-based tools are being utilised for production-grade as well as
research-prototyping. Prominent examples of the former, include the
GANGA-DIANE toolset, JSAGA, NAREGI job submission/management
system. Examples of research prototypes include digedag -- an
experimental system to support the flexible execution of DAG-based
workflow applications.

Finally, several applications (e.g., numerical relativity
applications) have used SAGA directly to support remote job submission
and file/date transfer. Although this was an initial target usage
mode, the cumulative number of such users is less than the previous
two modes. It is worth mentioning that applications typically tend to
use SAGA directly in early (fast-track) stages, but then move to
deeper integration via frameworks.
\vspace{-0.8em}
\pagebreak

\begin{figure}[hb]
  \centering
  \includegraphics[width=4in]{./figures/saga-architecture}
 \vspace{-1em}	
  \caption{\footnotesize Layered schematic of the different
    components of \impl.  Middleware specific adaptors make
    applications developed using \impl portable.  Schematic showing
    the different ways in which \impl can be used to develop
    distributed applications. (i) Using native \impl calls to
    implement distributed functionality; (ii) Through the use of
    frameworks which provide either application-level usage modes,
    patterns and thus shielding the application from directly
    interfacing with the infrastructure.}
%\vspace{-1.5em}
  \label{fig:saga_arch}
\end{figure}

 \bibliographystyle{IEEEtran} 
 \bibliography{saga_ahm_abstract,saga_ogf}


\end{document}

