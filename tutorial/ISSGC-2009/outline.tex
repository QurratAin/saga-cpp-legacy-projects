\title{A 90 Minute \textit{SAGA} Hands-On Tutorial\\[1em]
\Large{ISSGC, Nice, France, July 5-17 2009 }}

\documentclass[12pt]{article}

\usepackage{color}
\newif\ifdraft
\drafttrue
\ifdraft
\newcommand{\amnote}[1]{   {\textcolor{magenta} { ***Andre: #1 }}}
\newcommand{\olenote}[1]{{\textcolor{blue}    { ***Ole: #1 }}}
\newcommand{\hartmutnote}[1]{  {\textcolor{green}     { ***Hartmut:    #1 }}}
\newcommand{\jhanote}[1]{  {\textcolor{red}     { ***Shantenu:    #1 }}}
 \usepackage[pdftex,colorlinks=true, linkcolor=blue,citecolor=blue,
       urlcolor=blue]{hyperref}
\else
\newcommand{\amnote}[1]{}
 \newcommand{\olenote}[1]{}
\newcommand{\note}[1]{}
\newcommand{\hartmutnote}[1]{}
 \newcommand{\jhanote}[1]{}
\fi
\begin{document}
\maketitle

%\begin{abstract}
%This is the paper's abstract \ldots
%t\end{abstract}

\section*{Scope of this Tutorial}
The scope of this tutorial is to provide the audience with the required resources and technical knowledge (hands-on experience) to start hacking their own distributed applications with SAGA.

\subsection*{Prerequisites} This tutorial requires basic knowledge of the C/C++ programming language. Experience using the command line on a Linux/UNIX based operating system and a basic idea of what a compiler, a linker and a Makefile is might come in handy.\\[0.4em]
Unless this tutorial is going to be preceded by a SAGA installation tutorial, the students are required to have a fully working installation of SAGA on their laptops/lab machines (preferred), or remote access (e.g. via SSH) to a machine with SAGA installed. 
	
\subsection*{Cheat Sheat} At the beginning of the tutorial we're going to hand out the SAGA Cheat Sheet (yet to be created). The cheat sheet is a double-sided % (laminated, so people won't throw it away!)
letter-sized piece of paper with hints and tips for writing, compiling, and running SAGA applications.

\subsection*{Unit I (15 min)} \textbf{A minimal SAGA application.} Every application that uses just a single SAGA call is considered a SAGA applications, since it triggers the whole stack. SAGA is not a framework. It doesn’t impose a specific programming model or way to use it  (like, e.g. MPI). Look at it as a TOOLBOX for distributed computing.

\jhanote{Remember, we are going to use SSH adaptors for everything and nothing will USE Globus}

\jhanote{Points/Issues to consider here: (i) Avoid Context, (ii) Copy a file given 2 URLS, and (iii) Command line Tools. Make Use of material already in the programming manual}

\begin{verbatim}
<CODE>
\end{verbatim}

\subsection*{Unit II (15 min)} \textbf{Compiling and linking.} Demonstrate how to include the SAGA Makefiles to compile and link a SAGA application. Explain the concept of packages as independent shared libraries. Demonstrate static vs. dynamic linking.

\begin{verbatim}
<CODE>
\end{verbatim}

\subsection*{Unit III (15 min)} \textbf{Running a SAGA application.} Explain what needs to be in the loader path. Explain the effects of SAGA\_VERBOSE and how it can be used to debug a saga application. Demonstrate how the engine launches adaptor loading, etc... in the background.

\begin{verbatim}
<CODE>
\end{verbatim}

\subsection*{Unit IV (20 min)} \textbf{Hello distributed world!} Submit three jobs to three machines. One returns “Hello”, one returns “Distributed” and one returns “World”. They may or may not return in the right order. This should give the student an idea how they could potentially speed up their application using multiple resources. 

\jhanote{Deployment, (i) Local machines/desktop, (ii) A Cluster/Server (there are TeraGrid training accounts. I will find out more) (iii) Remote Machines.}

\begin{verbatim}
<CODE>
\end{verbatim}

\subsection*{Unit V (20 min)} \textbf{Applications} The aim of this section is to see how SAGA is used to implement common {\it higher-level} functionality that is used by Distributed Applications (DA). Specifically, we will look at two commonly occuring functionality required by DA.

{\bf Example 1:} Here we will demonstrate the ability to checkpoint, use a specified resource, self-migrate and restart on a different computational resource. There are multiple reasons this might be required (see lecture notes). Here we will demonstrate this capability using the \textbf{Hello distributed world!} example discussed in Unit IV.  Instead of launching three jobs on three machines, we will launch one job on one machine, which will then launch itself on another machine, which in turn will do so onto yet another machine. 


\begin{verbatim}
<CODE>
\end{verbatim}

Once developed, this capability can be utilized by a wide range of different applications. In other words this capability described/shown above is  independent of any specific application logic. Do you know of a
(Scientific) application that could utilize this feature?

{\bf Example 2:} Here we will briefly discuss MapReduce -- a computational pattern made famous by Google's use for its Search Engine Infrastructure.  The fundamental idea is that there is a Master which coordinates the distribution of work to a large number of Workers, and manages the merging of the output of the computation that the Workers produce. In addition to performance, a fundamental challenge is the need to be able to coordinate Master-Workers across a wide range of distributed systems.

\begin{verbatim}
<CODE>
\end{verbatim}

Not surprisingly the code snippet above is independent of any application specific details and focusses on the assignment of workloads to workers, execution and then retrival. This specific approach adopted here relies heavily on the use of the Advert Service.  Although introduced in the context of MapReduce, the requirement of coordination of distributed, often heteregenous units is a fundamental {\it vector} of distributed applications. (See Lecture Notes).

\subsection*{Excercise (20 min)} \textbf{Show what you've learned!} Have the students write a distributed application We have to come up with something neat, fun!!!, and simple enough that can be solved by all students within 20 minutes and the help of the cheat sheet. 

\begin{verbatim}
<CODE>
\end{verbatim}

\subsection*{Conclusion}

\end{document}
