#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
%% LyX 1.5.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.



\makeatletter

\makeatother
\end_preamble
\options a4paper,onecolumn
\language english
\inputencoding default
\fontscheme default
\graphics default
\paperfontsize 11
\spacing single
\papersize default
\use_geometry false
\use_amsmath 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title

\size larger
Specification and Implementation of a Python to SAGA Language Binding
\size normal

\newline
 Computer Science Master Thesis
\size larger
 
\end_layout

\begin_layout Author
P.F.A.
 van Zoolingen
\size normal

\newline
 1284657, pzn400@few.vu.nl
\end_layout

\begin_layout Abstract
This thesis describes how I created a Python language binding for SAGA,
 the Simple API for Grid Applications, and how I implemented the language
 binding on top of the Java reference implementation.
 Using this functionality, Python programmers can use SAGA to program grid
 aware applications and to shield themselves from all the details which
 come with grids.
 The language binding and its implementation add to the adopting of SAGA
 in a world of with many different APIs and middleware layers.
\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
This Master thesis is not a trivial subject for many people, and thus I
 found it desireable to write this introduction in two languages, English
 and Dutch.
\end_layout

\begin_layout Subsection
Introduction English
\end_layout

\begin_layout Standard
SAGA stands for Simple API for Grid Applications and was developed to offer
 users a simple tool to program applications for heterogeneous grids.
 These grids often consist of different types of hardware, operating systems
 and middleware software and are hard to program.
 SAGA is developed to be independent of any underlying hardware or software
 and to shield the user from all the details and to let him focus on programming
 grid aware applications.
\end_layout

\begin_layout Standard
To use this API, the functionality described by SAGA has to be implemented
 by another piece of software.
 This is called the SAGA implementation.
 At this point there are two different reference implementations which are
 programmed in the programming languages Java and C++.
 In a general sense, only Java and C++ applications can easily use SAGA
 to access the grid in an easy way.
 This thesis describes how I added another language to that list, namely
 Python.
 Python is partially supported by the C++ reference implementation, but
 there is no specific Python language binding available.
 A language binding is a set of classes and methods which describes the
 SAGA functionality in Python specific way, independent of the chosen reference
 implementation.
 During the course of my master project I have specified the Python language
 binding and have implemented the language binding for the Java reference
 implementation.
\end_layout

\begin_layout Standard
This thesis is divided into different pieces.
 First I will describe and explain what SAGA is, where it comes from and
 how it is implemented.
 Then I will continue with a description of Python and a special implementation
 of Python called Jython, followed by the specification of the language
 binding and its implementation.
 After that I will conclude with the testing, discussion, future work and
 the conclusion.
\end_layout

\begin_layout Subsection
Introduction Dutch
\end_layout

\begin_layout Standard
SAGA staat voor Simpele API voor Grid Applicaties en is ontwikkeld als een
 simpel stuk gereedschap om het programmeren op hetrogene grids te vergemakkelij
ken.
 Dit soort grids bestaan vaak uit verschillende hardware, besturingssystemen
 en middleware software en het is vaak lastig om hier grid applicaties voor
 te programmeren.
 SAGA is ontwikkeld als een aanspreekpunt voor de grid, onafhankelijk van
 de onderliggende hard- en software.
 Tevens houdt de API de programmeur weg bij de onderliggende details, die
 per platform zeer kunnen verschillen, en laat de programmeur zich bezighouden
 met het programmeren van een hogere abstractie niveau voor zijn applicatie.
\end_layout

\begin_layout Standard
Om de API te kunnen gebruiken moet de functionaliteit beschreven door SAGA
 ge
\begin_inset ERT
status inlined

\begin_layout Standard


\backslash
"i
\end_layout

\end_inset

mplementeerd worden door andere software, ook wel de SAGA implementatie
 genoemd.
 Momenteel bestaan twee verschillende referentie implementaties die gemaakt
 zijn in de programmeertalen Java en C++.
 Dit houdt globaal in dat het in de talen C++ en Java redelijk eenvoudig
 is om een applicatie te programmeren en de achterliggende implementatie
 en daarmee het grid te gebruiken.
 Deze Master these beschrijft hoe daar een derde taal aan toe is gevoegd,
 namelijk Python.
 Python word op dit moment al deels ondersteund door de C++ referentie implement
atie maar er is geen Python 'language binding', beschikbaar voor.
 De language binding specificeerd een set van klassen en methodes die de
 SAGA functionaliteit beschrijft in een Python specifieke manier, onafhankelijk
 van de onderliggende referentie implementatie.
 Tijdens mijn Master project heb ik een Python language binding voor SAGA
 gespecificeerd en daarnaast ge
\begin_inset ERT
status inlined

\begin_layout Standard


\backslash
"i
\end_layout

\end_inset

mplementeerd bovenop de Java referentie implementatie.
 Deze implementatie zou in theorie moeten werken op elke Java referentie
 implementatie.
 
\end_layout

\begin_layout Standard
Deze these is onderverdeeld in verschillende delen.
 Eerst zal ik uitleggen wat SAGA is, waar het vandaan komt en hoe het geimplemen
teerd is.
 Ik zal doorgaan met een beschrijving van Python en een specifieke implementatie
 van Python genaamd Jython, gevolgd door de specificatie van de language
 binding en zijn implementatie.
 Ik zal besluiten met het test gedeelte, de discussie, het vooruitzicht
 en de conclusie.
\end_layout

\begin_layout Section
SAGA
\end_layout

\begin_layout Standard
In this section I will describe what SAGA is, how it was created and the
 packages which are part of SAGA.
 In the last part I will discuss the reference implementations and how they
 work.
\end_layout

\begin_layout Subsection
SAGA
\end_layout

\begin_layout Standard
As mentioned in the introduction, SAGA stands for Simple API for Grid Applicatio
ns.
 SAGA came as an idea in a time when multiple middleware projects and applicatio
ns groups were looking for higher-level programming abstractions and the
 simplification of programming for the grid 
\begin_inset LatexCommand \cite{SAGA}

\end_inset

.
 A SAGA research group (SAGA-RG) was founded within the Global Grid Forum
 (GGF), which later merged into the Open Grid Forum (OGF).
 The aim of the group has been to identify a set of basic grid operations
 and derive a simple consistent API, which eases the development of applications
 that make use of grid technologies.
 
\end_layout

\begin_layout Subsection
Use Cases
\end_layout

\begin_layout Standard
To poll the needs of users, the research group sent out a call for use cases.
 In these use cases users described many subjects such as their application
 area, the desired look and feel of the API and resource, performance, security
 considerations.
 The majority of use cases which were returned came from scientific users
 
\begin_inset LatexCommand \cite{UseCases}

\end_inset

, which probably biased SAGA in the analysis of the use cases towards scientific
 applications.
 In this analysis, the research group focused on the identification of the
 SAGA API scope, on the level of abstraction wanted and needed by the applicatio
n programmers.
 Non-functional requirements and requirements from other projects, such
 as GAT 
\begin_inset LatexCommand \cite{GAT}

\end_inset

 and CoG 
\begin_inset LatexCommand \cite{CoG}

\end_inset

 were also considered.
\end_layout

\begin_layout Subsection
The API
\end_layout

\begin_layout Standard
With 24 use cases available, the requirements from the users could be distilled
 
\begin_inset LatexCommand \cite{ReqAnalysis}

\end_inset

.
 A design team was formed to use these requirements to design and develop
 the API.
 A few general design issues were considered and agree upon.
\end_layout

\begin_layout Itemize
The API would be designed and developed in a object-oriented manner using
 a language-neutral representation.
\end_layout

\begin_layout Itemize
Asynchronicity is prefered to be handled by a polling mechanism rather than
 a subscribe/listen mechanism to make implementations in non-multithreaded
 environment easier.
\end_layout

\begin_layout Itemize
Grid subsystems should be specified independent from each other to allow
 independent development and implementation of parts of the API.
\end_layout

\begin_layout Itemize
Sessions and Security should be an essential part of SAGA since applications
 often run accros administrative domains and security boundaries.
\end_layout

\begin_layout Itemize
Data Management like remote file access and replica catalogs are also an
 important part of grid applications and should therefore also be in SAGA.
\end_layout

\begin_layout Itemize
Remote jobs and asynchronous operations are a common requirement for grid
 applications and must be supported in the API.
\end_layout

\begin_layout Itemize
SAGA should support interprocess communication as a stream concept, similar
 to BSD sockets.
\end_layout

\begin_layout Standard
Ultimately, the purpose of SAGA is to provide an simple API that can be
 used with much less effort compared to the vanilla interfaces of existing
 grid middleware.
 A guiding principle for achieving this simplicity is the 80/20 rule: serve
 80% of the use cases with 20% of the effort needed for serving 100 % of
 all possible requirements and to provide a standardized, common interface
 across various grid middleware systems and their versions.
 
\end_layout

\begin_layout Standard
After determining the requirements, a so-called SAGA Strawman API was developed
 to accomodate the requirements and after some iterations SAGA was released
 in January 2008 
\begin_inset LatexCommand \cite{GFD.90}

\end_inset

.
 SAGA is described in a document called 
\emph on

\begin_inset Quotes eld
\end_inset

A Simple API for Grid Applications (SAGA)
\begin_inset Quotes erd
\end_inset

 
\emph default
or GFD.90.
 GFD.90 specifies the core components of SAGA has formed the basis of specificati
on of the Python language-binding, which will be explained in section 
\begin_inset LatexCommand \ref{sec:Specification}

\end_inset

, and the reference implementations.
 It is aimed at implementors of the API and not directly at end-users.
 The end-users can use the documentation and specific language-bindings
 given by the implementors of the reference implentations.
 The document holds much information about the complete SAGA project but
 what is interesting for building a language-binding is stated in section
 3 and 4 of GFD.90.
 These sections consists out of a number of interface and class specifications,
 which are divided in multiple packages.
 
\end_layout

\begin_layout Subsection
SAGA API 
\end_layout

\begin_layout Standard
SAGA is devided into two parts.
 A Look & Feel part containing the base classes and interfaces and an API
 part which represents explicit entities and actions of some backend system.
\end_layout

\begin_layout Subsubsection
Look & Feel
\end_layout

\begin_layout Standard
The SAGA Look & Feel is defined by a number of classes and interfaces which
 ensure the non-functional properties of the SAGA API.
 These interfaces and classes are intended to be used by the functional
 SAGA API packages and are shown in table 
\begin_inset LatexCommand \ref{tab: LF}

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Object
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
URL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Buffer
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Session
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Context
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Permission
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Attributes
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Monitoring
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab: LF}

\end_inset

Look and Feel packages
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Error package contains all the exceptions which can raised or thrown
 by SAGA API calls.
 GFD.90 also describes an 
\family typewriter
error_handler
\family default
 which allows a user of the API to query for the latest error associated
 with a SAGA ob ject but should not be included in language bindings of
 languages which have exception handling capabilities of their own, such
 as Python.
\end_layout

\begin_layout Standard
The Object package provides mechanisms which are needed by all SAGA objects,
 such as cloning and getting the type, ID and Session of the object.
\end_layout

\begin_layout Standard
URL is used reference local or remote resources.
 Using a separate URL class simplifies the construction, parsing and checking
 of URLs in applications and unifies the signatures of SAGA method calls
 which accept URLs.
\end_layout

\begin_layout Standard
Buffer is designed as a container for data and is used in combination with
 a number of SAGA calls which perform byte-level I/O operations.
 The data can be either allocated and maintained in application memory or
 by managed by the SAGA implementation.
\end_layout

\begin_layout Standard
The session object provides the functionality of a session, which isolates
 independent sets of SAGA objects from each other.
 Sessions also support the management of security information by using contexts.
\end_layout

\begin_layout Standard
The Context class is a container for security information and is attached
 to a Session to make the information available to all objects instantiated
 in that session.
 Multiple contexts can co-exist in one session for different method calls
 and can be shared between Sessions.
 
\end_layout

\begin_layout Standard
Permission package contains the interface to let applications allow or deny
 specific operations on SAGA objects or grid entities for different types
 of users.
 Because it is difficult to anticipate how different types of middleware
 handle these permissions, applications using the Permission package are
 not expected to be fully portable between SAGA applications.
 In addition, each implementation must specify which permission it supports
 and for which operation.
\end_layout

\begin_layout Standard
The Attributes package provides an interface for storing and retrieving
 attributes accociated with SAGA objects.
 The supported attributes of an object are included in the description of
 the object.
\end_layout

\begin_layout Standard
The Monitoring package provides a mechanism to monitor certain properties
 of monitorable SAGA objects by exposing metrics to the application.
 These metrics which represent monitorable entities, such as state or CPU
 time used.
 Steerable objects even allow certain metric values to be changed.
\end_layout

\begin_layout Standard
The last package of the Look & Feel is Task.
 Tasks are representations of asynchronous operations and each SAGA object
 which implements the 
\family typewriter
async
\family default
 interface is obliged to offer synchronous and asynchronous method calls.
 
\end_layout

\begin_layout Subsubsection
API Packages
\end_layout

\begin_layout Standard
The interfaces, classes and methods defined in API packages of GFD.90 are,
 in general, representing explicit entities and actions of some backend
 system.
 The currently specified packages are shown in table 
\begin_inset LatexCommand \ref{tab:API-Packages}

\end_inset

, but new packages may be added in the future.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Job
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Namespace
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
File
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Replica
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Stream
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RPC
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:API-Packages}

\end_inset

API Packages
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Job offers the functionality to submit jobs to grid resources and to monitor
 and control these jobs.
 Job submitting can be done in batch mode or interactive mode and jobs be
 controlled through different methods calls such as 
\family typewriter
run()
\family default
 and 
\family typewriter
suspend()
\family default
.
 Status information can be retreived for both running and completed jobs.
 
\end_layout

\begin_layout Standard
The Namespace package describes notions of namespace entries and directories
 allows to navigate through a namespace such as filesystems.
 
\end_layout

\begin_layout Standard
The File package is an extention of Namespace and also allows access to
 the contents of the files regardless of their location.
 It also offers the Scattered, Pattern-Based and Extended I/O paradigms.
\end_layout

\begin_layout Standard
The Replica package describes the interaction with replica systems, especially
 logical files, logical directories and creating replicas.
 
\end_layout

\begin_layout Standard
The Stream specifies the functionality to create simple remote socket to
 establish connections between components.
 These components can then form a distributed application together.
\end_layout

\begin_layout Standard
The RPC or Remote Procedure Call Package specifies the dealing with invoking
 of methods on different machines.
 A high level API called GridRPC 
\begin_inset LatexCommand \cite{GridRPC}

\end_inset

 is imported into SAGA and adapted to the SAGA look and feel.
 Semantically, GridRPC maps to the RPC package.
\end_layout

\begin_layout Subsection
Reference Implementations
\end_layout

\begin_layout Standard
SAGA currently has two reference implementations, one written in Java and
 one written in C++.
 In this section I will explain what they are and how they work.
\end_layout

\begin_layout Subsubsection
Java SAGA Reference Implementation
\end_layout

\begin_layout Standard
After GFD.90 was released in January 2008, a Java SAGA reference implementation
 was created at the Vrije Universiteit and released in September 2008 
\begin_inset LatexCommand \cite{SJava}

\end_inset

.
 It is largly based on JavaGAT 
\begin_inset LatexCommand \cite{JavaGAT}

\end_inset

, a toolkit which provides a high-level middleware-independent and site-dependen
t interface to grids.
 JavaGAT is the reference implementation for the GAT API 
\begin_inset LatexCommand \cite{GAT}

\end_inset

, which shares many goals with SAGA.
 Common goals are the aim to make it easier for grid users to create complex
 grid applications and to shield them from the underlying middleware.
 
\end_layout

\begin_layout Standard
The structure of JavaGAT can be seen in figure 
\begin_inset LatexCommand \ref{fig:JavaGAT structure}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename JavaGATFigure1.png
	scale 50
	keepAspectRatio
	clip

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:JavaGAT structure}

\end_inset


\end_layout

\begin_layout Standard
The structure of the JavaGAT implemententation, taken from 
\begin_inset LatexCommand \cite{JavaGAT}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It consists out of different layers which all have its own responsibility.
 The top layer is the API that serves as the interface to the user.
 Below the API resides the engine.
 The engine is responsible for delegating the API calls to the correct middlewar
e.
 The Capability Provider Interface is the layer which connects the engine
 to middleware specific software, called adaptors.
 When the engine receives a request, i.e, to copy a file, it selects the
 right adaptor with help from the CPI.
 The adaptor then delegates the copy request to the actual middleware that
 copies the file.
 
\end_layout

\begin_layout Standard
Principles used from JavaGAT in the SAGA Java reference implementation include
 the intelligent dispatching, nested exceptions and the adaptor writing
 framework.
 The intelligent dispatching is the process where the engine chooses the
 correct adaptor for the requested action and the related preferences.
 Nested exceptions are special aggregations of exceptions which come from
 the different adaptors.
 Adaptors might raise exceptions when they fail at a certain action or do
 not implement the requested action.
 All these exceptions are stored in a nested exception and is only thrown
 to the grid application if every adaptor failed at fulfilling the request.
 The adaptor writing framework makes it easy for users to write or change
 adaptors with little effort.
 This is an advantage because there are many middleware systems available
 and they are changing often.
\end_layout

\begin_layout Standard
The Java reference implementation implements SAGA completely since this
 is a requirement in the SAGA specification.
 There are still some deviations from GFD.90, such as links and permissions.
 Java does not have a notion of links and permissions so it is not possible
 to include them.
 If methods relating to them are called, the implementation will throw a
 
\family typewriter
NotImplementedException
\family default
.
 The implemented Java language binding also contains small extentions like
 file streams and using RPC with objects instead of using Byte arrays.
\end_layout

\begin_layout Standard
Adaptors currently included with the Java reference implementation are XMLRPC
 for RPC, Socket for streams, Gridsam for jobs, and Adaptors from JavaGAT.
\end_layout

\begin_layout Subsubsection
C++ SAGA Reference Implementation
\end_layout

\begin_layout Standard
Before the GFD.90 specification for SAGA was released a group at the Louisiana
 State University 
\begin_inset LatexCommand \cite{LSU}

\end_inset

 started to build a C++ reference implementation 
\begin_inset LatexCommand \cite{C++SAGA}

\end_inset

.
 People from the group were also involved in the SAGA design process and
 the developing of GAT and pioneered in implementing a SAGA C++ implementation.
 This implementation works in a similar way as the Java implementation as
 that it also includes call routing through to the adaptors.
 It also features the probing of multiple adaptors and the variable adaptor
 strategies.
 In addition, it tries latency hiding strategies such as bulk optimalization
 and automatic load distribution over multiple adaptors.
\end_layout

\begin_layout Standard
The implementation offers wrappers for C and Python but they are not fully
 functional as they are in alpha stage.
 A Python language binding is not available and the wrapper closely follows
 the syntax of the underlying C++ layer.
 My Python language binding is specified top-down from the SAGA specification,
 the wrapper is designed bottom-up from the implementation.
\end_layout

\begin_layout Section
Python
\end_layout

\begin_layout Standard
The Python language binding for SAGA is a specification of the classes and
 methods in the programming language Python.
 In this section I will explain parts of Python and how it influences the
 specification.
 
\end_layout

\begin_layout Subsection
Introduction to Python
\end_layout

\begin_layout Standard
Python was created in 1989 by Guido van Rossum who was working at the Centrum
 voor Wiskunde en Informatica (CWI) in the Netherlands.
 He worked on the programming language ABC, but needed some extra features.
 Not wanting to fall back to C, he created his own language called Python.
 
\end_layout

\begin_layout Standard
Python is a high level interpreted scripting language and applications do
 not have to be explicitly compiled.
 It is Object Oriented but also borrows some features from functional languages.
 The Python interpreter is written in C, sometimes called CPython, and is
 extensible by writing your own modules or by writing special C modules
 for it.
 Because the interpreter is written in C it is portable to platforms which
 support the ANSI C compiler and scripts have to be written only once to
 be run on many platforms.
 Some projects have rewritten the interpreter in different programming languages
 to take advantage of the distict features of the language.
 These projects include Jython for a Java interpreter and IronPython for
 a C# version.
 According to estimations 
\begin_inset LatexCommand \cite{ProgLang}

\end_inset

, the popularity of Python is around 5%, after Java, C, C++, VB and PHP.
 This rating is based on information from search engines, engineers and
 companies world-wide.
 Together with Java, C++ and C, support for Python will give users enough
 choice for developing applications using SAGA.
\end_layout

\begin_layout Subsection
Syntax Features
\end_layout

\begin_layout Standard
Python has some features in its syntax which influenced the SAGA language
 binding, and makes one to one copying of the SAGA specification not as
 straight forward as it seems.
 In this section I will explain which features those are.
\end_layout

\begin_layout Subsubsection
Dynamic Typing
\end_layout

\begin_layout Standard
Python uses dynamic typing, which means that the type of a variable is bound
 to the type of variable value, and can change regulary.
 In static typing, the type is set when the variable is created and cannot
 be changed afterwards.
 This gives new possibilities when dealing with return values and parameter
 types.
 A commonly heard term is that Python uses 'Duck Typing' (
\begin_inset Quotes eld
\end_inset

If it looks like a duck and quacks like a duck, it must be a duck.").
 This means that calling a method of an object is always possible.
 If it actually succeeds and does not result in a runtime error depends
 on the object.
 In this context it means that if you can call quack() and walk() on an
 object, the type was probably Duck.
 If it gave a runtime error, the object was definitly not a Duck.
 There are ways check the type of a variable, like 
\family typewriter
type(), isinstance(), issubclass() or variable.__class__
\family default
 .
\end_layout

\begin_layout Subsubsection
Keywords and builtins
\end_layout

\begin_layout Standard
Python has reserved keywords just like every programming language.
 Most of these are are similar to other languages, but Python has some specific
 ones which are also used in the SAGA specification.
 In the 
\family typewriter
Permission
\family default
 enum 
\family typewriter
Exec
\family default
 and 
\family typewriter
None
\family default
 are mentioned, but both 
\family typewriter
exec
\family default
 and 
\family typewriter
None
\family default
 are reserved.
 Although Python is case-sensitive, this gives problems when defining a
 consequent namescheme.
\end_layout

\begin_layout Standard
Python also has some standard functions which are available.
 These include functions like 
\family typewriter
list()
\family default
, 
\family typewriter
tuple()
\family default
, 
\family typewriter
dir()
\family default
 and 
\family typewriter
type()
\family default
.
 SAGA has some parameters names like which interfere with the built in methods,
 such as 
\family typewriter
type
\family default
 in the 
\family typewriter
Metric 
\family default
constructor.
\end_layout

\begin_layout Subsubsection
Methods
\end_layout

\begin_layout Standard
Methods are defined in Python by using the 
\family typewriter
def
\family default
 keyword followed by the method name and the parameters in brackets.
 
\family typewriter
def
\family default
 defines a method, but can also be used to overwrite the previously defined
 method with the same name.
 This makes it impossible to do overloading, defined as defining multiple
 methods with the same name but only differing in parameter types.
 The same effect can still be archieved in Python since the parameter type
 is not defined in the method declaration.
 
\end_layout

\begin_layout Standard
Named Parameters, default parameters, return values, overloading
\end_layout

\begin_layout Subsubsection
Extending Python
\end_layout

\begin_layout Subsubsection
Future versions of Python
\end_layout

\begin_layout Subsection
Jython
\end_layout

\begin_layout Subsection
Difference Jython - Python
\end_layout

\begin_layout Section
Specification
\begin_inset LatexCommand \label{sec:Specification}

\end_inset


\end_layout

\begin_layout Subsection
All Modules Specified with Design Decisions
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Previous work // Solutions Tested
\end_layout

\begin_layout Subsection
Delegate Object
\end_layout

\begin_layout Subsection
Convert Exception
\end_layout

\begin_layout Subsection
Tasks
\end_layout

\begin_layout Subsection
Inheritance
\end_layout

\begin_layout Subsection
Get_id()
\end_layout

\begin_layout Subsection
All Modules Specified with Design Decisions
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Subsection
Test Environment
\end_layout

\begin_layout Subsection
scripts
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Subsection
Repository
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Subsection
Synchronize specification with LSU
\end_layout

\begin_layout Subsection
Extending the API
\end_layout

\begin_layout Standard
Extention packages
\end_layout

\begin_layout Subsection
Special Python operators
\end_layout

\begin_layout Subsection
Updating Implementation with new Reference Implementations
\end_layout

\begin_layout Section
List of Frequently Used Terms
\end_layout

\begin_layout Itemize
API: Application Programming Interface.
 A set of variables, methods and classes that is offered by an operating
 system or software library to support requests made by computer programs.
 
\end_layout

\begin_layout Itemize
Grid: A collection of interconnected computers consisting of different hardware,
 placed in different locations and belonging to different organizations.
 
\end_layout

\begin_layout Itemize
Grid Aware: Applications which are grid aware are designed to run on a grid
 and use the possibilities of the grid, such as distributing workload between
 available nodes in the grid.
 
\end_layout

\begin_layout Itemize
Language Binding: An API in a specific programming language which gives
 access to a library or service
\end_layout

\begin_layout Itemize
Reference Implementation: First working software which implements the functional
ity described by SAGA.
 New applications can link to this software and call methods described in
 SAGA to use the grid.
\end_layout

\begin_layout Itemize
SAGA: Simple API for Grid Applications 
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Section
Bibliography
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[bibtotoc,plain]{Thesis}

\end_inset


\end_layout

\begin_layout Section
Acknowledgments
\end_layout

\begin_layout Section
Appendix A: Installing and Running JySaga
\end_layout

\begin_layout Section
Appendix B: Proof of a Higgs-boson
\end_layout

\end_body
\end_document
